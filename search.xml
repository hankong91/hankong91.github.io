<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo+Github搭建个人博客</title>
    <url>/2022/02/02/Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h1><ul>
<li>Hexo需要Node.js支持</li>
<li>Node.js下载地址：<a href="https://nodejs.org/en/">nodejs.org</a></li>
<li>安装完以后会有两个组件，Node.js + npm包管理器</li>
</ul>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">node</span> <span class="title">-v</span></span><br><span class="line">v16.<span class="number">13.1</span></span><br><span class="line"></span><br><span class="line">$ npm -v</span><br><span class="line"><span class="number">8.1</span>.<span class="number">2</span></span><br></pre></td></tr></table></figure>

<h1 id="安装cnpm，淘宝镜像源"><a href="#安装cnpm，淘宝镜像源" class="headerlink" title="安装cnpm，淘宝镜像源"></a>安装cnpm，淘宝镜像源</h1><ul>
<li>借助npm安装Hexo博客框架，但由于国内镜像源速度慢，可以利用npm安装一个cnpm，淘宝的源</li>
</ul>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">$ npm install -g cnpm --registry=https:<span class="regexp">//</span>registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/blog/image-20220105234517559.png"></p>
<h1 id="使用cnpm安装Hexo博客"><a href="#使用cnpm安装Hexo博客" class="headerlink" title="使用cnpm安装Hexo博客"></a>使用cnpm安装Hexo博客</h1><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">$ cnpm install -g hexo-<span class="keyword">cli</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/blog/image-20220105235001374.png"></p>
<h1 id="使用Hexo搭建博客"><a href="#使用Hexo搭建博客" class="headerlink" title="使用Hexo搭建博客"></a>使用Hexo搭建博客</h1><ul>
<li>创建博客目录</li>
<li>初始化博客</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">$ hexo <span class="keyword">init</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/blog/image-20220105235806763.png"></p>
<ul>
<li>启动博客</li>
</ul>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>hexo s</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/blog/image-20220105235937501.png"></p>
<ul>
<li>浏览器访问<a href="http://localhost:4000/">http://localhost:4000/</a></li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/blog/image-20220106000154817.png"></p>
<ul>
<li>新建一篇博客，并编辑</li>
</ul>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>hexo n <span class="string">&quot;My First Blog&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/blog/image-20220106000542115.png"></p>
<ul>
<li>清理，重新生成，并启动博客</li>
</ul>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>hexo clean</span><br><span class="line"><span class="variable">$ </span>hexo g</span><br><span class="line"><span class="variable">$ </span>hexo s</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/blog/image-20220106001429254.png"></p>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/blog/image-20220106001505606.png"></p>
<h1 id="将博客部署到远端，比如GitHub"><a href="#将博客部署到远端，比如GitHub" class="headerlink" title="将博客部署到远端，比如GitHub"></a>将博客部署到远端，比如GitHub</h1><ul>
<li>创建一个新的仓库，注意：仓库名必须为GitHub用户名+github.io</li>
<li>使用cnpm安装git部署插件</li>
</ul>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">$ cnpm install <span class="comment">--save hexo-deployer-git</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/blog/image-20220106002928759.png"></p>
<ul>
<li>修改博客目录下的_config.yml</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/blog/image-20220117230537645.png"></p>
<ul>
<li>部署到远端</li>
</ul>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>hexo d</span><br></pre></td></tr></table></figure>

<ul>
<li>会提示你输入GitHub用户名和密码，但是重点来了，这里试了好几次，明明用户名和密码都正确，就是部署不上去，提示Authentication failed &amp; Error: Spawn failed</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/blog/image-20220117230617045.png"></p>
<ul>
<li>不知道是不是HTTPS的问题，不过以前也确实没用过HTTPS的方式，又尝试了SSH的方式，修改如下，注意如果以前没有在GitHub上添加过SSH Keys的话需要添加下，参考链接：<a href="https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent">Generating a new SSH key and adding it to the ssh-agent</a></li>
<li>重新修改_config.yml如下</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/blog/image-20220117231656787.png"></p>
<ul>
<li>重新部署成功</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/blog/image-20220117231858319.png"></p>
<ul>
<li>将仓库地址复制到浏览器中打开，就可以正常打开个人博客</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/blog/image-20220117232211582.png"></p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的变量初始化</title>
    <url>/2022/02/05/C++%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<h1 id="默认初始化"><a href="#默认初始化" class="headerlink" title="默认初始化"></a>默认初始化</h1><ul>
<li>定义变量时没有指定初值时进行的初始化操作。如int a; MyClass obj;等，这些变量被定义了而不是仅仅被声明，而且没有显示的赋初始值。特别的，如果采用动态分配内存的方式创建的变量，不加括号（如int *p = new int;）也是默认初始化，加了括号（如int *p = new int();）为值初始化。变量的值与变量定义的位置有关</li>
</ul>
<blockquote>
<p>对于内置变量类型（如int，double，bool等），如果定义为全局变量，则变量被默认初始化为0；如果定义为局部变量，变量将拥有未定义的值</p>
<p>对于类类型（如string或其他自定义类型），不管定义予何处，都会执行默认构造函数。如果该类没有默认构造函数，则会引发编译错误</p>
</blockquote>
<ul>
<li>对于内置类型的局部变量，其默认初始化后，值可能为0，比如在g++和msvc中，这可能跟编译器和操作系统有关，具体可以参考：<a href="https://stackoverflow.com/questions/11143354/why-are-local-variables-initialized-to-0-in-g-compiler-for-c-in-ubuntu-linux">Why are local variables initialized to 0 in g++ compiler for c++ in ubuntu linux?</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> global_value;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> local_value;</span><br><span class="line">    <span class="keyword">int</span> *new_value = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;global_value: &quot;</span> &lt;&lt; global_value &lt;&lt; endl;   <span class="comment">// 0</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;local_value: &quot;</span> &lt;&lt; local_value &lt;&lt; endl;     <span class="comment">// 在g++和msvc中可能为0</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;new_value: &quot;</span> &lt;&lt; *new_value &lt;&lt; endl;        <span class="comment">// 未定义</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="值初始化"><a href="#值初始化" class="headerlink" title="值初始化"></a>值初始化</h1><ul>
<li>定义变量时使用了初始化器（即圆括号或者大括号），但却没有提供初始值的情况，如int *p = new int(); vector&lt;string&gt; vec(10)等</li>
<li>注意，当不采用动态分配内存的方式（即不采用new运算符）时，写成int a();是错误的值初始化方式，因为这种方式声明了一个函数而不是进行值初始化。如果一定要进行值初始化，必须结合拷贝初始化使用，即写成int a = int();值初始化和默认初始化一样，对于内置类型初始化为0，对于类类型则调用其默认构造函数，如果没有默认构造函数，则不能进行初始化</li>
<li>只要使用了括号（圆括号或花括号）但没有给出具体初始值，就是值初始化。可以简单理解为括号告诉编译器你希望该对象初始化。没有使用括号，就是默认初始化。可以简单理解成，你放任不管，允许编译器使用默认行为，通常这是糟糕的行为</li>
</ul>
<h1 id="直接初始化和拷贝初始化"><a href="#直接初始化和拷贝初始化" class="headerlink" title="直接初始化和拷贝初始化"></a>直接初始化和拷贝初始化</h1><ul>
<li><p>直接初始化：定义变量时采用小括号的方式进行变量初始化，且小括号里一定要有初始值，如果没有初始值，那就是值初始化了，如int a(12); MyClass obj(param); string s(“123”);等</p>
</li>
<li><p>拷贝初始化：定义变量时采用等号的方式进行变量初始化，如int a = 12; string s = “123”等，拷贝初始化像是给变量赋值，实际上执行了初始化操作，与先定义再赋值本质不同</p>
</li>
<li><p>对于内置类型，直接初始化和拷贝初始化差别可以忽略不计；对于类类型，直接初始化调用类的构造函数（调用参数最匹配的那个），拷贝初始化调用类的拷贝构造函数</p>
</li>
<li><p>对于示例，s的初始化书本说是直接初始化，看起来似乎像是拷贝初始化，其实的确是直接初始化，因为直接初始化是用参数来直接匹配某一个构造函数，而拷贝构造函数和其他构造函数形成了重载，以至于刚好调用了拷贝构造函数</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">dots</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;.&#x27;</span>)</span></span>;   <span class="comment">// 直接初始化</span></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(dots)</span></span>;         <span class="comment">// 直接初始化</span></span><br></pre></td></tr></table></figure>

<ul>
<li>C++语言标准规定拷贝初始化应该是先调用对应的构造函数创建一个临时对象，然后拷贝构造函数再将构造的临时对象拷贝给要创建的对象，如string a = “hello”;，因为“hello”的类型是const char *，所以string类的string(const char *)构造函数会被首先调用，创建一个临时对象，然后拷贝构造函数将这个临时对象复制到a。但是标准还规定，为了提高效率，允许编译器跳过创建临时对象这一步，直接调用构造函数构造要创建的对象，从而忽略调用拷贝构造函数进行优化，这样就完全等价于直接初始化了，当然可以使用-fno-elide-constructors选项来禁用优化</li>
</ul>
<h1 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h1><ul>
<li>列表初始化是C++ 11新引进的初始化方式，它采用一对花括号进行初始化操作。能用直接初始化和拷贝初始化的地方都能用列表初始化，而且列表初始化能对容器进行方便的初始化，因此在新的C++标准中，推荐使用列表初始化的方式进行初始化，如int a{12}; string s{“123”}; vector&lt;int&gt; vec{1,2,3};等</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接列表初始化</span></span><br><span class="line"><span class="keyword">int</span> x&#123;&#125;;</span><br><span class="line"><span class="keyword">int</span> y&#123; <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> array1[]&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">char</span> s1[<span class="number">3</span>]&#123; <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;k&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">char</span> s2[]&#123;<span class="string">&quot;Hello&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝列表初始化</span></span><br><span class="line"><span class="keyword">int</span> z = &#123; <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> array2[] = &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line"><span class="keyword">char</span> s3[] = &#123; <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;k&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">char</span> s4[] = &#123; <span class="string">&quot;Hello&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">char</span> s5[] = <span class="string">&quot;Hello&quot;</span>; </span><br></pre></td></tr></table></figure>

<ul>
<li>用于内置类型的变量时，若使用列表初始化且初始值存在丢失信息的风险，则编译器将报错，即列表初始化不允许“窄化”</li>
</ul>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul>
<li>初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来代替</li>
<li>使用等号（=）初始化一个类变量执行的是拷贝初始化，编译器会把等号右侧的初始值拷贝到新创建的对象中去，不使用等号则执行的是直接初始化</li>
<li>默认初始化是定义对象时，没有使用初始化器，也即没有做任何初始化说明时的行为</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec;</span><br></pre></td></tr></table></figure>

<ul>
<li>值初始化是定义对象时，要求初始化，但没有给出初始值的行为</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>();</span><br><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>&#123;&#125;;  <span class="comment">// C++11</span></span><br></pre></td></tr></table></figure>

<ul>
<li>当用于类类型对象时，初始化的复制形式和直接形式有所不同：直接初始化直接调用与实参匹配的构造函数，复制初始化总是调用复制构造函数。复制初始化首先使用指定构造函数创建一个临时对象，然后用复制构造函数将那个临时对象复制到正在创建的对象</li>
<li>直接初始化和拷贝初始化主要是相对于我们自定义的对象的初始化而言的，对于内置类型，这两者没有区别。对于自定义对象，直接初始化和拷贝初始化区别是直接调用构造函数还是用”=”来进行初始化</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>)</span></span>;     <span class="comment">// 直接初始化，匹配某一构造函数</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">v2</span><span class="params">(<span class="number">10</span>)</span></span>;  <span class="comment">// 直接初始化，匹配某一构造函数</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v3 = v1;    <span class="comment">// 拷贝初始化，使用 = 进行初始化</span></span><br></pre></td></tr></table></figure>

<ul>
<li>列表初始化是C++新标准给出的一种初始化方式，可用于内置类型，也可以用于自定义对象，前者比如数组，后者比如vector</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> array[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>尽量使用列表初始化，除非你有个很好不用它的理由</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://blog.csdn.net/u014359097/article/details/50788911">谈谈C++中各种初始化方式</a></li>
<li><a href="https://segmentfault.com/a/1190000039844285">五花八门的C++初始化规则</a></li>
<li><a href="https://www.cnblogs.com/pluse/p/7088880.html">C++的各种初始化方式</a></li>
<li><a href="https://blog.csdn.net/ljianhui/article/details/9245661">C++的一大误区——深入解释直接初始化与复制初始化的区别</a></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>初始化</tag>
      </tags>
  </entry>
  <entry>
    <title>const</title>
    <url>/2022/02/06/const/</url>
    <content><![CDATA[<h1 id="const对象的多文件访问"><a href="#const对象的多文件访问" class="headerlink" title="const对象的多文件访问"></a>const对象的多文件访问</h1><ul>
<li>若需要多个文件访问const对象，则对于const变量不管是声明还是定义都添加extern关键字</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file.cpp定义并初始化一个常量, 改常量能被其他文件访问</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufsize = <span class="number">1024</span>;</span><br><span class="line"><span class="comment">// file.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufsize;</span><br></pre></td></tr></table></figure>

<ul>
<li>若无const，则定义时没有限制要加上extern</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file.cpp</span></span><br><span class="line"><span class="keyword">int</span> bufsize = <span class="number">1024</span>;</span><br><span class="line"><span class="comment">// file.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> bufsize;</span><br></pre></td></tr></table></figure>

<h1 id="顶层const-amp-底层const"><a href="#顶层const-amp-底层const" class="headerlink" title="顶层const &amp; 底层const"></a>顶层const &amp; 底层const</h1><ul>
<li>顶层const：指针本身是一个常量，一般也可表示任意的对象是常量</li>
<li>底层const：指针所指向的对象是一个常量</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p1 = &amp;i;       <span class="comment">// 不能改变p1的值, 这是一个顶层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">1</span>;         <span class="comment">// 不能改变ci的值, 这是一个顶层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p2 = &amp;ci;      <span class="comment">// 允许改变p2的值, 这是一个底层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p3 = p2; <span class="comment">// 右侧const是顶层const, 左侧const是底层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *r = i;         <span class="comment">// 用于声明引用的const都是底层const</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>const</tag>
      </tags>
  </entry>
  <entry>
    <title>move和完美转发</title>
    <url>/2022/02/24/move%E5%92%8C%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/</url>
    <content><![CDATA[<h1 id="move"><a href="#move" class="headerlink" title="move"></a>move</h1><ul>
<li>在<a href="https://hankong91.github.io/2022/02/17/%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/">左值和右值</a>一文中提到了移动语义，通过移动构造函数解决了临时变量拷贝产生的性能损失问题，且移动语义是通过右值引用来匹配临时值</li>
<li>普通的左值是否也能通过移动语义来优化性能，C++11为了解决这个问题，提供了std::move方法将左值转换为右值，从而方便应用移动语义</li>
<li>move是将对象资源的所有权从一个对象转移到另一个对象，只是转移，没有内存的拷贝</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string str1&#123; <span class="string">&quot;Hello World&quot;</span> &#125;;</span><br><span class="line">string str2 = str1;             <span class="comment">// Copy</span></span><br><span class="line">string str3 = std::<span class="built_in">move</span>(str1);  <span class="comment">// Move</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; str1 &lt;&lt; endl;   <span class="comment">// null</span></span><br><span class="line">cout &lt;&lt; str2 &lt;&lt; endl;   <span class="comment">// Hello World</span></span><br><span class="line">cout &lt;&lt; str3 &lt;&lt; endl;   <span class="comment">// Hello World</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v1&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v2 = v1;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v3 = std::<span class="built_in">move</span>(v1);     <span class="comment">// v1.size() = 0</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果不用std::move，拷贝的代价很大，性能较低。使用move几乎没有任何代价，只是转换了资源的所有权。它实际上将左值变成右值引用，然后应用移动语义，调用移动构造函数，就避免了拷贝，提高了程序性能。如果一个对象内部有较大的对内存或者动态数组时，很有必要写move语义的拷贝构造函数和赋值函数，避免无谓的深拷贝，以提高性能。事实上，C++11中所有的容器都实现了移动语义，方便我们做性能优化</li>
<li>move实际上并不能移动任何东西，它唯一的功能是将一个左值强制转换为一个右值引用。如果是一些基本类型比如int和char[10]定长数组等类型，使用move的话仍然会发生拷贝（因为没有对应的移动构造函数）。所以，move对于含资源（堆内存或句柄）的对象来说更有意义</li>
<li>std::move是一个非常有迷惑性的函数，不理解左右值概念的话往往以为它能把一个变量里的内容移动到另一个变量，但事实上std::move移动不了什么，唯一的功能是把左值强制转化为右值，让右值引用可以指向左值。其实现等同于一个类型转换：static_cast&lt;T&amp;&amp;&gt;(lvalue)。所以，单纯的std::move(xxx)不会有性能提升</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; ref_a_left = a;                <span class="comment">// 左值引用指向左值</span></span><br><span class="line"><span class="keyword">int</span>&amp;&amp; ref_a_right = std::<span class="built_in">move</span>(a);   <span class="comment">// 通过std::move将左值转化为右值, 可以被右值引用指向</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;                  <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<ul>
<li>被声明出来的左、右值引用都是左值。因为被声明出的左、右值引用是有地址的，也位于等号左边</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>&amp;&amp; right_value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    right_value = <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span>&amp; ref_a_left = a;</span><br><span class="line">    <span class="keyword">int</span>&amp;&amp; ref_a_right = std::<span class="built_in">move</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">//     func(a);            // 编译报错: an lvalue to an rvalue reference</span></span><br><span class="line"><span class="comment">//     func(ref_a_left);   // 编译报错: an lvalue to an rvalue reference</span></span><br><span class="line"><span class="comment">//     func(ref_a_right);  // 编译报错: an lvalue to an rvalue reference</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>(std::<span class="built_in">move</span>(a));</span><br><span class="line">    <span class="built_in">func</span>(std::<span class="built_in">move</span>(ref_a_left));</span><br><span class="line">    <span class="built_in">func</span>(std::<span class="built_in">move</span>(ref_a_right));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印三个左值的地址都一样</span></span><br><span class="line">    cout &lt;&lt; &amp;a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &amp;ref_a_left &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ref_a_left &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &amp;ref_a_right &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ref_a_right &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>右值引用既可以是左值也可以是右值，如果有名称则为左值，否则是右值。或者说：作为函数返回值的&amp;&amp;是右值，直接声明出来的&amp;&amp;是左值。其实引用和普通变量是一样的，int &amp;&amp;ref = std::move(a)和int a = 5没有什么区别，等号左边就是左值，右边就是右值</li>
<li>vector::push_back使用std::move提高性能</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::string str1&#123; <span class="string">&quot;Hello World&quot;</span> &#125;;</span><br><span class="line">std::vector&lt;std::string&gt; vec;</span><br><span class="line"></span><br><span class="line">vec.<span class="built_in">push_back</span>(str1);                <span class="comment">// Copy</span></span><br><span class="line">vec.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(str1));     <span class="comment">// 调用移动语义的push_bak方法, 避免拷贝, str1会失去原有值, 变成空字符串</span></span><br><span class="line">vec.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(str1));  <span class="comment">// emplace_back效果相同, str1会失去原有值</span></span><br><span class="line">vec.<span class="built_in">emplace_back</span>(<span class="string">&quot;abcd&quot;</span>);           <span class="comment">// 直接接右值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// vector方法定义</span></span><br><span class="line"><span class="comment">// void push_back (const value_type&amp; val);</span></span><br><span class="line"><span class="comment">// void push_back(value_type&amp;&amp; val);</span></span><br><span class="line"><span class="comment">// void emplace_back (Args&amp;&amp;... args);</span></span><br></pre></td></tr></table></figure>

<h1 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h1><ul>
<li>这里继续转载博文<a href="https://www.cnblogs.com/qicosmos/p/4283455.html">从4行代码看右值引用</a>中的第四行代码</li>
</ul>
<h2 id="第四行代码"><a href="#第四行代码" class="headerlink" title="第四行代码"></a>第四行代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; val)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(std::forward&lt;T&gt;(val));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>C++11之前调用模板函数时，存在一个比较头疼的问题，如何正确的传递参数。比如</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forwardValue</span><span class="params">(T&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">processValue</span>(val);  <span class="comment">// 右值参数会变成左值 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forwardValue</span><span class="params">(<span class="keyword">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">processValue</span>(val);  <span class="comment">// 参数都变成常量左值引用了 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不能安装本来的参数类型进行转发</li>
<li>C++11引入了完美转发：在函数模板中，完全依照模板的参数的类型（即保持参数的左值、右值特征），将参数传递给函数模板中调用的另外一个函数。C++11中的std::forward正是做这个事情的，他会按照参数的实际类型进行转发</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processValue</span><span class="params">(<span class="keyword">int</span>&amp; a)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;lvalue&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processValue</span><span class="params">(<span class="keyword">int</span>&amp;&amp; a)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;rvalue&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forwardValue</span><span class="params">(T&amp;&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">processValue</span>(std::forward&lt;T&gt;(val)); <span class="comment">// 按照参数本来的类型进行转发</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    forwardValue(i);    <span class="comment">// 传入左值</span></span><br><span class="line">    forwardValue(<span class="number">0</span>);    <span class="comment">// 传入右值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// lvalue</span></span><br><span class="line"><span class="comment">// rvalue</span></span><br></pre></td></tr></table></figure>

<ul>
<li>右值引用T&amp;&amp;是一个universal references，可以接受左值或者右值，正是这个特性让他适合作为一个参数的路由，然后再通过std::forward按照参数的实际类型去匹配对应的重载函数，最终实现完美转发</li>
</ul>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul>
<li>C++11正是通过引入右值引用来优化性能，具体来说是通过移动语义来避免无谓拷贝的问题，通过move语义来将临时生成的左值中的资源无代价的转移到另外一个对象中去，通过完美转发来解决不能按照参数实际类型来转发的问题（同时，完美转发获得的一个好处是可以实现移动语义）</li>
<li>从性能上讲，左右值引用没有区别，传参使用左右值引用都可以避免拷贝</li>
<li>右值引用可以直接指向右值，也可以通过std::move指向左值；而左值引用只能指向左值（const左值引用也能指向右值）</li>
<li>作为函数形参时，右值引用更灵活。虽然const左值引用也可以做到左右值都接受，但它无法修改，有一定局限性</li>
<li>可移动对象在需要拷贝且被拷贝者之后不再被需要的场景，建议使用std::move触发移动语义，提升性能</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.cnblogs.com/qicosmos/p/4283455.html">从4行代码看右值引用</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/335994370">一文读懂C++右值引用和std::move</a></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>右值引用</tag>
        <tag>move</tag>
        <tag>完美转发,forward</tag>
      </tags>
  </entry>
  <entry>
    <title>关于extern &quot;C&quot;</title>
    <url>/2022/03/01/%E5%85%B3%E4%BA%8Eextern%20C/</url>
    <content><![CDATA[<h1 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h1><ul>
<li>被extern “C”修饰的代码会按照C语言的方式去编译，C语言不支持函数name mangling</li>
<li>extern “C”的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern “C”后，会指示编译器这部分代码按C语言（而不是C++）的方式进行编译。由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func(int)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者用大括号</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func(int)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译报错</span></span><br><span class="line">error C2733: <span class="string">&#x27;func&#x27;</span>: second C linkage of overloaded function <span class="keyword">not</span> allowed</span><br></pre></td></tr></table></figure>

<ul>
<li>如果函数同时有声明和实现，要让函数声明被extern “C”修饰，函数实现可以不修饰</li>
<li>在C/C++混合编程过程中，第三方框架/库可能是用C语言写的开源库，在C++中调用过程中，由于C++对函数有name mangling，若在库函数声明中未标注extern “C”，则会对库函数进行name mangling，而库函数的实现又是以C的方式进行编译，不会进行name mangling，从而链接失败</li>
<li>C语言中不支持extern “C”声明，在.c文件中包含了extern “C”时会出现编译时错误</li>
<li>与extern对应的关键字是static，被它修饰的全局变量和函数只能在本模块中使用。因此，一个函数或变量只可能被本模块使用时，其不可能被extern “C”修饰</li>
</ul>
<h1 id="C和C-互相调用"><a href="#C和C-互相调用" class="headerlink" title="C和C++互相调用"></a>C和C++互相调用</h1><h2 id="C-中调用C代码"><a href="#C-中调用C代码" class="headerlink" title="C++中调用C代码"></a>C++中调用C代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TestC.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TEST_C_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST_C_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TestC.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TestC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = a + b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, c);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TestC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// gcc -c TestC.c</span></span><br><span class="line"><span class="comment">// ar -r libTestC.a TestC.o</span></span><br><span class="line"><span class="comment">// g++ -o TestCpp TestCpp.cpp -L. -lTestC</span></span><br></pre></td></tr></table></figure>

<h2 id="C中调用C-代码"><a href="#C中调用C-代码" class="headerlink" title="C中调用C++代码"></a>C中调用C++代码</h2><ul>
<li>C语言没法直接调用C++的函数，但可以使用包裹函数来实现。C++文件.cpp中可以调用C和C++的函数，但是C代码.c只能调用C的函数，所以可以用包裹函数去包裹C++函数，然后把这个包裹函数以C的规则进行编译，这样C就可以调用这个包裹函数了</li>
<li>调用普通函数例子</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TestCpp.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TEST_CPP_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST_CPP_H_</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TestCpp.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TestCpp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = a + b;</span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TestWrapper.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TEST_CPP_WRAPPER_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST_CPP_WRAPPER_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">funcWrapper</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TestWrapper.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TestCppWrapper.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TestCpp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">funcWrapper</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">func</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TestCppWrapper.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">funcWrapper</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// g++ -c TestCpp.cpp</span></span><br><span class="line"><span class="comment">// ar -r libTestCpp.a TestCpp.o</span></span><br><span class="line"><span class="comment">// g++ -c TestCppWrapper.cpp</span></span><br><span class="line"><span class="comment">// ar -r libTestCppWrapper.a TestCppWrapper.o</span></span><br><span class="line"><span class="comment">// gcc -o TestC TestC.c -L. -lTestCppWrapper -lTestCpp -lstdc++</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注意链接顺序，必须要先链接TestCppWrapper，再链接TestCpp，如果使用C++库，还需外额外添加</li>
<li>调用类成员函数例子</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TestCpp.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TEST_CPP_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST_CPP_H_</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestCpp</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TestCpp.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TestCpp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TestCpp::func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = a + b;</span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TestCppWrapper.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TEST_CPP_WRAPPER_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST_CPP_WRAPPER_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">getHandle</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">funcWrapper</span><span class="params">(<span class="keyword">void</span>* handle, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TestCppWrapper.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TestCppWrapper.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TestCpp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">getHandle</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> TestCpp c;</span><br><span class="line">    <span class="keyword">return</span> &amp;c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">funcWrapper</span><span class="params">(<span class="keyword">void</span>* handle, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TestCpp* p = <span class="keyword">static_cast</span>&lt;TestCpp*&gt;(handle);</span><br><span class="line">    <span class="keyword">return</span> p-&gt;<span class="built_in">func</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TestCppWrapper.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* handle = <span class="built_in">getHandle</span>();</span><br><span class="line">    <span class="built_in">funcWrapper</span>(handle, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// g++ -c TestCpp.cpp TestCppWrapper.cpp</span></span><br><span class="line"><span class="comment">// ar -r libTestCpp.a TestCpp.o TestCppWrapper.o</span></span><br><span class="line"><span class="comment">// gcc -o TestC TestC.c -L. -lTestCpp -lstdc++</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>函数重载</title>
    <url>/2022/02/06/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<h1 id="重载和const形参"><a href="#重载和const形参" class="headerlink" title="重载和const形参"></a>重载和const形参</h1><ul>
<li>顶层const不影响传入函数的对象，因此一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Phone)</span></span>;   <span class="comment">// 重复声明了Record lookup(Phone);</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone *)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone * <span class="keyword">const</span>)</span></span>; <span class="comment">// 重复声明了Record lookup(Phone *);</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时const是底层的，因为const不能转换成其他类型，只能把const对象传递给const形参，但当传递一个非常量对象或者非常量对象的指针时，编译器会优先选择非常量的版本</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于接受引用或指针的函数来说, 对象是常量还是非常量对应的形参不同</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone &amp;)</span></span>;         <span class="comment">// 函数作用于Phone的引用</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Phone &amp;)</span></span>;   <span class="comment">// 新函数, 作用于常量引用</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone *)</span></span>;         <span class="comment">// 新函数, 作用于指向Phone的指针</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Phone *)</span></span>;   <span class="comment">// 新函数, 作用与指向常量的指针</span></span><br></pre></td></tr></table></figure>

<h1 id="函数重载的本质"><a href="#函数重载的本质" class="headerlink" title="函数重载的本质"></a>函数重载的本质</h1><ul>
<li>采用了name mangling或者叫name decoration技术，C++编译器默认会对符号名（比如函数名）进行改编、修饰，重载时会生成多个不同的函数名，不同编译器有不同的生成规则，通过逆向工程IDA打开可以看到不同函数名，反汇编后也可以看到跳转到了不同的函数地址</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func(int)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> a)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func(double)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line"><span class="number">00B</span>31<span class="function">E8E E8 A5 F5 FF FF       call        <span class="title">func</span> <span class="params">(<span class="number">0B</span>31438h)</span>  </span></span><br><span class="line"><span class="function">    <span class="title">func</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="number">00B</span>31E93 <span class="number">6</span>A <span class="number">01</span>                push        <span class="number">1</span>  </span><br><span class="line"><span class="number">00B</span>31<span class="function">E95 E8 C1 F5 FF FF       call        <span class="title">func</span> <span class="params">(<span class="number">0B</span>3145Bh)</span>  </span></span><br><span class="line"><span class="function">00B31E9A 83 C4 04             add         esp,4  </span></span><br><span class="line"><span class="function">    <span class="title">func</span><span class="params">(<span class="number">1.0</span>)</span></span>;</span><br><span class="line"><span class="number">00B</span>31E9D <span class="number">83</span> EC <span class="number">08</span>             sub         esp,<span class="number">8</span>  </span><br><span class="line"><span class="number">00B</span>31EA0 F2 <span class="number">0F</span> <span class="number">10</span> <span class="number">05</span> <span class="number">48</span> <span class="number">8B</span> B3 <span class="number">00</span> movsd       xmm0,mmword ptr [__real@<span class="number">3f</span>f0000000000000 (<span class="number">0B</span>38B48h)]  </span><br><span class="line"><span class="number">00B</span>31EA8 F2 <span class="number">0F</span> <span class="number">11</span> <span class="number">04</span> <span class="number">24</span>       movsd       mmword ptr [esp],xmm0  </span><br><span class="line"><span class="number">00B</span>31<span class="function">EAD E8 B3 F5 FF FF       call        <span class="title">func</span> <span class="params">(<span class="number">0B</span>31465h)</span>  </span></span><br><span class="line"><span class="function">00B31EB2 83 C4 08             add         esp,8  </span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>函数重载</tag>
      </tags>
  </entry>
  <entry>
    <title>左值和右值</title>
    <url>/2022/02/17/%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/</url>
    <content><![CDATA[<h1 id="概念和语法"><a href="#概念和语法" class="headerlink" title="概念和语法"></a>概念和语法</h1><ul>
<li>C++98/03中的左值引用是这样的：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; ri = i;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里int&amp;是对左值进行绑定，但是int&amp;不能绑定右值，相应的，对右值进行绑定的引用就是右值引用，其语法是A&amp;&amp;，表示绑定类型为A的右值，比如</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp;&amp; ri = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>右值引用是C++11中新增的特性，主要用来解决C++98/03中遇到的两个问题，第一个问题就是临时对象非必要的昂贵拷贝操作，第二个问题是在模板函数中如何按照参数的实际类型进行转发。通过引入右值引用，很好的解决了这两个问题，改进了程序性能</li>
<li>当一个对象被用作右值的的时候，用的是对象的值（内容）</li>
<li>当对象被用作左值的时候，用的是对象的身份（在内存中的位置）</li>
<li>左值：定义了一个函数或者对象，它是一个可以取地址的表达式</li>
<li>纯右值：是不和对象相关联的值（字面量）或其求值结果是字面量或者一个匿名的临时对象</li>
<li>将亡值：将亡值也指定了一个对象，是一个将纯右值转换为右值引用的表达式</li>
</ul>
<h1 id="理解右值"><a href="#理解右值" class="headerlink" title="理解右值"></a>理解右值</h1><ul>
<li>这里主要转载博文<a href="https://www.cnblogs.com/qicosmos/p/4283455.html">从4行代码看右值引用</a></li>
</ul>
<h2 id="第一行代码"><a href="#第一行代码" class="headerlink" title="第一行代码"></a>第一行代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="built_in">getVar</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>这行代码会产生两种类型的值，一种为左值i，一种是函数getVar()返回的临时值，这个临时值在表达式结束后就销毁了，而左值i在表达式结束后仍然存在，这个临时值就是右值，具体来说就是纯右值，右值是不具名的</li>
<li>区分左值和右值的一个简单办法是：看能不能对表达式取地址，如果能，则为左值，否则为右值</li>
<li>所有的具名变量或对象都是左值，而匿名变量则是右值，比如，简单的赋值语句</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>在这条语句中，i是左值，0是字面量，就是右值。在上面的代码中，i可以被引用，0就不可以了。具体来说上面的表达式中等号右边的0是纯右值（prvalue），在C++11中所有的值必属于左值、将亡值、纯右值三者之一</li>
<li>比如，非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和lambda表达式等都是纯右值。而将亡值是C++11新增的、与右值引用相关的表达式，比如，将要被移动的对象、T&amp;&amp;函数返回值、std::move返回值和转换为T&amp;&amp;的类型的转换函数的返回值等</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> j = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [] &#123; <span class="keyword">return</span> <span class="number">5</span>; &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面代码中，5是一个原始字面量，[] { return 5; }是一个lambda表达式，都是属于纯右值，特点是在表达式结束之后就销毁了</li>
</ul>
<h2 id="第二行代码"><a href="#第二行代码" class="headerlink" title="第二行代码"></a>第二行代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp;&amp; k = <span class="built_in">getVar</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>第二行代码和第一行代码很像，只是相比第一行代码多了“&amp;&amp;”，它就是右值引用，我们知道左值引用是对左值的引用，那么对应的，对右值的引用就是右值引用，而且右值是匿名变量，我们也只能通过引用的方式来获取右值。虽然第二行代码和第一行代码看起来差别不大，但是实际上语义的差别很大，这里，getVar()产生的临时值不会像第一行代码那样，在表达式结束之后就销毁了，而是会被“续命”，他的生命周期将会通过右值引用得以延续，和变量k的声明周期一样长</li>
<li>右值引用的第一个特点：通过右值引用，右值由“重获新生”，其生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值临时量将会一直存活下去。如下例子观察生命周期</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g_ctorCnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> g_cpyCtorCnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> g_dtorCnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="built_in">A</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Ctor() - this: &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;, cnt: &quot;</span> &lt;&lt; ++g_ctorCnt &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">const</span> A&amp; a) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Copy Ctor() - this: &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;, cnt: &quot;</span> &lt;&lt; ++g_cpyCtorCnt &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Dtor() - this: &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;, cnt: &quot;</span> &lt;&lt; ++g_dtorCnt &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">getA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">A</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a = <span class="built_in">getA</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>为清楚观察临时值，在编译时设置编译选项-fno-elide-constructors用来关闭返回值优化效果，输出结果为</li>
</ul>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Ctor</span>() - this: <span class="number">0</span>x<span class="number">61</span>fdbf, cnt : <span class="number">1</span>            // getA()内部构造对象<span class="number">1</span></span><br><span class="line"><span class="attribute">Copy</span> Ctor() - this : <span class="number">0</span>x<span class="number">61</span>fe<span class="number">0</span>f, cnt : <span class="number">1</span>      // 对象<span class="number">1</span>拷贝构造临时对象<span class="number">2</span></span><br><span class="line"><span class="attribute">Dtor</span>() - this : <span class="number">0</span>x<span class="number">61</span>fdbf, cnt : <span class="number">1</span>           // 对象<span class="number">1</span>销毁</span><br><span class="line"><span class="attribute">Copy</span> Ctor() - this : <span class="number">0</span>x<span class="number">61</span>fe<span class="number">0</span>e, cnt : <span class="number">2</span>      // 临时对象<span class="number">2</span>拷贝构造对象<span class="number">3</span>(a)</span><br><span class="line"><span class="attribute">Dtor</span>() - this : <span class="number">0</span>x<span class="number">61</span>fe<span class="number">0</span>f, cnt : <span class="number">2</span>           // 临时对象<span class="number">2</span>销毁</span><br><span class="line"><span class="attribute">Dtor</span>() - this : <span class="number">0</span>x<span class="number">61</span>fe<span class="number">0</span>e, cnt : <span class="number">3</span>           // 对象<span class="number">3</span>销毁</span><br></pre></td></tr></table></figure>

<ul>
<li>从上面的例子中可以看到，在没有返回值优化的情况下，拷贝构造函数调用了两次，一次是getA()函数内部创建的对象返回出来构造一个临时对象产生的，另一次是在main函数中构造a对象产生的。第二次的Dtor是因为临时对象在构造a对象之后就销毁了。如果开启返回值优化的话，输出结果将是</li>
</ul>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Ctor</span>() - this: <span class="number">0</span>x<span class="number">61</span>fe<span class="number">0</span>f, cnt: <span class="number">1</span></span><br><span class="line"><span class="attribute">Dtor</span>() - this: <span class="number">0</span>x<span class="number">61</span>fe<span class="number">0</span>f, cnt: <span class="number">1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可以看到返回值优化将会把临时对象优化掉，但这不是c++标准，是各编译器的优化规则</li>
<li>在回到之前提到的可以通过右值引用来延长临时右值的生命周期，如果上面的代码中我们通过右值引用来绑定函数返回值的话，输出结果如下（设置-fno-elide-constructors）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A&amp;&amp; a = <span class="built_in">getA</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Ctor</span>() - this: <span class="number">0</span>x<span class="number">61</span>fdbf, cnt: <span class="number">1</span></span><br><span class="line"><span class="attribute">Copy</span> Ctor() - this: <span class="number">0</span>x<span class="number">61</span>fe<span class="number">07</span>, cnt: <span class="number">1</span></span><br><span class="line"><span class="attribute">Dtor</span>() - this: <span class="number">0</span>x<span class="number">61</span>fdbf, cnt: <span class="number">1</span></span><br><span class="line"><span class="attribute">Dtor</span>() - this: <span class="number">0</span>x<span class="number">61</span>fe<span class="number">07</span>, cnt: <span class="number">2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>通过右值引用，比之前少了一次拷贝构造和一次析构，原因在于右值引用绑定了右值，让临时右值的生命周期延长了。可以利用这个特点做一些性能优化，即避免临时对象的拷贝构造和析构</li>
<li>事实上，在c++98/03中，通过常量左值引用也经常用来做性能优化。上面的代码改成</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> A&amp; = <span class="built_in">getA</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>输出结果和右值一样。因为常量左值引用是一个“万能”的引用类型，可以接受左值、右值、常量左值和常量右值。需要注意的是普通的左值引用不能接受右值，比如这样的写法是不对的，编译报错，原因是非常量左值引用只能接受左值</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">A&amp; = <span class="built_in">getA</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>右值引用的第二个特点：右值引用独立于左值和右值。意思是右值引用类型的变量可能是左值也可能是右值，比如</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp;&amp; ri = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>ri类型为右值引用，但ri本身是左值，因为具名变量都是左值</li>
<li>T&amp;&amp;是什么，一定是右值吗？如下例子</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">10</span>);      <span class="comment">// t是右值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">f</span>(x);       <span class="comment">// t是左值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>右值引用的第三个特点：T&amp;&amp; t在发生自动类型推断的时候，它是未定的引用类型（universal references），如果被一个左值初始化，它就是一个左值；如果它被一个右值初始化，它就是一个右值，它是左值还是右值取决于它的初始化</li>
<li>对于函数template &lt;typename T&gt; void f(T&amp;&amp; t)，当参数为右值10的时候，根据universal references的特点，t被一个右值初始化，那么t就是右值；当参数为左值x时，t被一个左值引用初始化，那么t就是一个左值</li>
<li>需要注意的是，仅仅是当发生自动类型推导（如函数模板的类型自动推导，或auto关键字）的时候，T&amp;&amp;才是universal references。再看看下面的例子</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">    <span class="built_in">Test</span>(Test&amp;&amp; rhs);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面的例子中，param是universal reference，rhs是Test&amp;&amp;右值引用，因为模版函数f发生了类型推断，而Test&amp;&amp;并没有发生类型推导，因为Test&amp;&amp;是确定的类型了</li>
<li>正是因为右值引用可能是左值也可能是右值，依赖于初始化，并不是一下子就确定的特点，我们可以利用这一点做很多文章，比如移动语义和完美转发</li>
</ul>
<h2 id="第三行代码"><a href="#第三行代码" class="headerlink" title="第三行代码"></a>第三行代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">T</span>(T&amp;&amp; a) : <span class="built_in">m_val</span>(val) &#123; a.m_val = <span class="literal">nullptr</span>; &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这行代码实际上来自于一个类的构造函数，构造函数的一个参数是一个右值引用，为什么将右值引用作为构造函数的参数呢？在解答这个问题之前我们先看一个例子</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() : <span class="built_in">m_ptr</span>(<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">0</span>)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Ctor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">const</span> A&amp; a) : <span class="built_in">m_ptr</span>(<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(*a.m_ptr)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Copy Ctor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>* m_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">getA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">A</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a = <span class="built_in">getA</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// Ctor</span></span><br><span class="line"><span class="comment">// Copy Ctor</span></span><br><span class="line"><span class="comment">// Copy Ctor</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这个例子很简单，一个带有堆内存的类，必须提供一个深拷贝拷贝构造函数，因为默认的拷贝构造函数是浅拷贝，会发生“指针悬挂”的问题。如果不提供深拷贝的拷贝构造函数，上面的测试代码将会发生错误（打开编译选项-fno-elide-constructors），内部的m_ptr将会被释放三次，一次是getA()函数内部创建的对象析构的时候释放一次，第二次是临时右值析构的时候释放一次，第三次是外面构造的a对象释放时释放一次，而这三个对象的m_ptr是同一个指针，这就是所谓的指针悬挂问题</li>
<li>提供深拷贝的拷贝构造函数虽然可以保证正确，但是在有些时候会造成额外的性能损耗，因为有时候这种深拷贝是不必要的</li>
<li>面代码中的getA函数会返回临时变量，然后通过这个临时变量拷贝构造了一个新的对象a，临时变量在拷贝构造完成之后就销毁了，如果堆内存很大的话，那么这个拷贝构造的代价会很大，带来了额外的性能损失。每次都会产生临时变量并造成额外的性能损失，有没有办法避免临时变量造成的性能损失呢？C++11已经有了解决方法，通过移动构造函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() : <span class="built_in">m_ptr</span>(<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">0</span>)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Ctor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">const</span> A&amp; a) : <span class="built_in">m_ptr</span>(<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(*a.m_ptr)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Copy Ctor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">A</span>(A&amp;&amp; a) : <span class="built_in">m_ptr</span>(a.m_ptr) &#123;</span><br><span class="line">        a.m_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Move Ctor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>* m_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">getA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">A</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a = <span class="built_in">getA</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// Ctor</span></span><br><span class="line"><span class="comment">// Move Ctor</span></span><br><span class="line"><span class="comment">// Move Ctor</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这个构造函数并没有做深拷贝，仅仅是将指针的所有者转移到了另外一个对象，同时，将参数对象a的指针置为空，这里仅仅是做了浅拷贝，因此，这个构造函数避免了临时变量的深拷贝问题</li>
<li>上面这个函数其实就是移动构造函数，他的参数是一个右值引用类型，这里的A&amp;&amp;表示右值，为什么？前面已经提到，这里没有发生类型推断，是确定的右值引用类型。为什么会匹配到这个构造函数？因为这个构造函数只能接受右值参数，而函数返回值是右值，所以就会匹配到这个构造函数。这里的A&amp;&amp;可以看作是临时值的标识，对于临时值我们仅仅需要做浅拷贝即可，无需再做深拷贝，从而解决了前面提到的临时变量拷贝构造产生的性能损失的问题。这就是所谓的移动语义，右值引用的一个重要作用是用来支持移动语义的</li>
<li>提供移动构造函数的同时也会提供一个拷贝构造函数，以防止移动不成功的时候还能拷贝构造，使我们的代码更安全</li>
</ul>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul>
<li>有地址的变量就是左值，没有地址的字面量、临时值就是右值</li>
<li>左值引用能指向左值，不能指向右值，但是const左值引用是可以指向右值的</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; ref = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// push_back(5);</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> value_type&amp; value)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>右值引用专为右值而生，可以指向右值，不能指向左值。通过右值引用，右值由“重获新生”，其生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值临时量将会一直存活下去，避免临时对象的拷贝构造和析构</li>
<li>仅仅是当T&amp;&amp; t在发生自动类型推断的时候（如函数模板的类型自动推导，或auto关键字），它是未定的引用类型（universal references），如果被一个左值初始化，它就是一个左值；如果它被一个右值初始化，它就是一个右值，它是左值还是右值取决于它的初始化</li>
<li>为避免临时变量的深拷贝带来的开销，引入移动构造函数，传入右值引用参数，实现浅拷贝</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.cnblogs.com/qicosmos/p/4283455.html">从4行代码看右值引用</a></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>右值引用</tag>
        <tag>右值</tag>
        <tag>移动构造函数</tag>
      </tags>
  </entry>
  <entry>
    <title>异常</title>
    <url>/2022/03/01/%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h1 id="异常机制"><a href="#异常机制" class="headerlink" title="异常机制"></a>异常机制</h1><ul>
<li>异常处理是C++的一项语言机制，用于在程序中处理异常事件。异常事件在C++中表示为异常对象，异常事件发生时，程序使用throw关键字抛出异常表达式，抛出点称为异常出现点，由操作系统为程序设置当前异常对象，然后执行程序的当前异常处理代码块</li>
<li>在包含了异常出现点的最内层的try块，依次匹配catch语句中的异常对象，若匹配成功，则执行catch块内的异常处理语句，然后接着执行try…catch…块之后的代码。如果在当前的try…catch…块内找不到匹配该异常对象的catch语句，则由更外层的try…catch…块来处理该异常。如果当前函数内所有的try…catch…块都不能匹配该异常，则递归回退到调用栈的上一层去处理该异常。如果一直退到主函数main()都不能处理该异常，则调用系统函数terminate()终止程序</li>
<li>异常处理机制的优点：可将异常信息从被调函数带回给主函数</li>
<li>若对异常对象的内容不感兴趣，可省略catch参数，只保留类型</li>
</ul>
<h1 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h1><ul>
<li>执行throw语句时，throw表达式将作为对象被复制构造为一个新的对象，称为异常对象。异常对象放在内存的特殊位置，该位置既不是栈也不是堆，在Windows上是放在线程信息块TIB中。这个构造出来的新对象与本级的try所对应的catch语句进行类型匹配</li>
<li>异常对象是一种特殊的对象，编译器依据异常抛出表达式复制构造异常对象，这要求抛出异常表达式不能是一个不完全类型（一个类型在声明之后定义之前为一个不完全类型，不完全类型意味着该类型没有完整的数据与操作描述），而且可以进行复制构造，这就要求异常抛出表达式的复制构造函数（或移动构造函数）、析构函数不能是私有的</li>
</ul>
<h1 id="noexcept"><a href="#noexcept" class="headerlink" title="noexcept"></a>noexcept</h1><ul>
<li>noexcept修饰符是C++11新提供的异常说明符，用于声明一个函数不会抛出异常。编译器能够针对不抛出异常的函数进行优化，另一个显而易见的好处是你明确了某个函数不会抛出异常，别人调用你的函数时就知道不用针对这个函数进行异常捕获。在C++98中关于异常处理的程序中可能会看到这样的代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="title">throw</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">double</span>)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这是throw作为函数异常说明，前者表示func()这个函数可能会抛出int或double类型的异常，后者表示func()函数不会抛出异常。事实上前者很少被使用，在C++11这种做法已经被摒弃，而后者则被C++11的noexcept异常声明所代替</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="comment">// 等价于void func() throw() &#123; ... &#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在C++11中，编译器并不会在编译期检查函数的noexcept声明，因此被声明为noexcept的函数若携带异常抛出语句还是可以通过编译的。在函数运行时若抛出了异常，编译器可以选择直接调用terminate()函数来终结程序的运行，因此noexcept的一个作用是阻止异常的传播，提高安全性</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// noexcept声明符的语法: noexcept或者noexcept(布尔表达式)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="literal">true</span>)</span> </span>&#123;&#125;    <span class="comment">// noexcept(true)等价于noexcept</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;&#125;                   <span class="comment">// 可能会抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span> </span>&#123;&#125;   <span class="comment">// noexcept(false)等价于什么也不写, 可能会抛出异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// noexcept不能用于区分重载函数</span></span><br><span class="line"><span class="comment">// noexcept函数中抛出异常, 等价于调用std::terminate()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="comment">/* 潜在抛出异常 */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="built_in">f</span>();        <span class="comment">// 合法: 即使f抛出</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="number">42</span>;   <span class="comment">// 合法: 等效于调用 std::terminate()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.cnblogs.com/QG-whz/p/5136883.html">C++异常机制概述</a></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>noexcept</tag>
      </tags>
  </entry>
  <entry>
    <title>引用</title>
    <url>/2022/02/06/%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<h1 id="引用的使用"><a href="#引用的使用" class="headerlink" title="引用的使用"></a>引用的使用</h1><ul>
<li>引用（reference），为对象起了另外一个名字</li>
<li>引用并非对象，相反的，它只是为一个已存在的对象所起的另外一个名字</li>
<li>引用必须初始化，且不能使引用重新绑定到另外一个对象</li>
<li>引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起</li>
<li>引用本身不是对象，不能定义引用的引用</li>
<li>引用和指针的区别：指针指向内存中的某个对象，而引用绑定到内存中的某个对象，它们都实现了对其他对象的间接访问，两者的区别主要有两方面。第一，指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以指向几个不同的对象，引用不是一个对象，无法令引用重新绑定到另外一个对象；第二，指针无须在定义是赋初值，和其他内置类型一样，在块作用域内定义的指针如果没有初始化，也将拥有一个不确定的值，引用必须在定义时赋初值</li>
</ul>
<h1 id="引用的本质"><a href="#引用的本质" class="headerlink" title="引用的本质"></a>引用的本质</h1><ul>
<li>引用的本质就是指针，只是编译器削弱了它的功能，所以引用就是弱化了的指针，一个引用占用一个指针的大小</li>
<li>通过反汇编观察指令（msvc）如下</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="number">10</span>:     <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="number">008B</span>1010 C7 <span class="number">45</span> F8 <span class="number">0</span>A <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> mov         dword ptr [a],<span class="number">0</span>Ah  </span><br><span class="line">    <span class="number">11</span>:     <span class="keyword">int</span>* p = &amp;a;</span><br><span class="line"><span class="number">008B</span>1017 <span class="number">8</span>D <span class="number">45</span> F8             lea         eax,[a]  </span><br><span class="line"><span class="number">008B</span>101A <span class="number">89</span> <span class="number">45</span> F4             mov         dword ptr [p],eax  </span><br><span class="line">    <span class="number">12</span>:     <span class="keyword">int</span>&amp; ref = a;</span><br><span class="line"><span class="number">008B</span>101D <span class="number">8</span>D <span class="number">4</span>D F8             lea         ecx,[a]  </span><br><span class="line"><span class="number">008B</span>1020 <span class="number">89</span> <span class="number">4</span>D F0             mov         dword ptr [ref],ecx  </span><br></pre></td></tr></table></figure>

<h1 id="常引用可以指向不同类型的数据"><a href="#常引用可以指向不同类型的数据" class="headerlink" title="常引用可以指向不同类型的数据"></a>常引用可以指向不同类型的数据</h1><ul>
<li>常引用可以指向不同类型的数据，且此时会产生临时变量，即引用指向的并不是初始化的那个变量</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">long</span>&amp; ref = a;</span><br><span class="line">    a = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;      <span class="comment">// 20</span></span><br><span class="line">    cout &lt;&lt; ref &lt;&lt; endl;    <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">     <span class="number">7</span>:     <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">C7 <span class="number">45</span> F4 <span class="number">0</span>A <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> mov         dword ptr [ebp<span class="number">-0</span>Ch],<span class="number">0</span>Ah  </span><br><span class="line">     <span class="number">8</span>:     <span class="keyword">const</span> <span class="keyword">long</span>&amp; ref = a;</span><br><span class="line">            <span class="comment">// [ebp-24h] 为一个临时变量的地址</span></span><br><span class="line">            <span class="comment">// [ebp-18h] 为引用变量ref的地址</span></span><br><span class="line"><span class="number">8B</span> <span class="number">45</span> F4             mov         eax,dword ptr [ebp<span class="number">-0</span>Ch]  </span><br><span class="line"><span class="number">89</span> <span class="number">45</span> DC             mov         dword ptr [ebp<span class="number">-24</span>h],eax  </span><br><span class="line"><span class="number">8</span>D <span class="number">4</span>D DC             lea         ecx,[ebp<span class="number">-24</span>h]  </span><br><span class="line"><span class="number">89</span> <span class="number">4</span>D E8             mov         dword ptr [ebp<span class="number">-18</span>h],ecx  </span><br><span class="line">     <span class="number">9</span>:     a = <span class="number">20</span>;</span><br><span class="line">C7 <span class="number">45</span> F4 <span class="number">14</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> mov         dword ptr [ebp<span class="number">-0</span>Ch],<span class="number">14</span>h  </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>引用</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器</title>
    <url>/2022/02/06/%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<h1 id="迭代器使用"><a href="#迭代器使用" class="headerlink" title="迭代器使用"></a>迭代器使用</h1><ul>
<li>提供对对象的间接访问，所有标准容器都可以使用迭代器，但是仅有少数几种才能同时支持下标运算符</li>
<li>二分搜索例子</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vec必须是有序的</span></span><br><span class="line"><span class="comment">// beg和end表示需要搜索的范围</span></span><br><span class="line"><span class="keyword">auto</span> beg = vec.<span class="built_in">begin</span>(), end = vec.<span class="built_in">end</span>();</span><br><span class="line"><span class="keyword">auto</span> mid = beg + (end - beg) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (mid != end &amp;&amp; *mid != sought) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sought &lt; *mid)</span><br><span class="line">        end = mid;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        beg = mid + <span class="number">1</span>;</span><br><span class="line">    mid = beg + (end - beg) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><ul>
<li>C++并没有定义两个迭代器的加法运算，直接把两个迭代器加起来没有意义，但是定义了迭代器的减法运算，两个迭代器相减的结果是两个迭代器之间的距离，所以mid = (beg + end) / 2;不合法</li>
<li>向迭代器添加元素和从迭代器删除元素的代码可能会导致迭代器失效，因此必须保证每次改变容器的操作之后都正确地重新定位迭代器</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> iter = vec.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (iter != vec.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*iter == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">// erase 后一定要重新给迭代器赋值</span></span><br><span class="line">        iter = vec.<span class="built_in">erase</span>(iter);</span><br><span class="line">    &#125;</span><br><span class="line">    ++iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不要保存end返回的迭代器，必须反复调用end</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> begin = vec.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">// 在每个循环步添加/删除元素后都重新计算end</span></span><br><span class="line"><span class="keyword">while</span> (begin != vec.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    ++begin;</span><br><span class="line">    begin = vec.<span class="built_in">insert</span>(begin, <span class="number">42</span>);</span><br><span class="line">    ++begin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>迭代器</tag>
      </tags>
  </entry>
</search>
