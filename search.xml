<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Chap01_简介</title>
    <url>/2022/05/11/UNP/Chap01_%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li>计算机网络各层对等实体间交换的单位信息称为协议数据单元（protocol data unit，PDU），分节（segment）就是对应于TCP传输层的PDU</li>
<li>按照协议与服务之间的关系，除了最低层（物理层）外，每层的PDU通过由紧邻下层提供给本层的服务接口，作为下层的服务数据单元（service data unit，SDU）传递给下层，并由下层间接完成本层的PDU交换，简单来说就是本层的SDU（也叫payload）是上层的PDU</li>
<li>如果本层的PDU大小超过紧邻下层的最大SDU限制，那么本层还要事先把PDU划分成若干个合适的片段让下层分开载送，再在相反方向把这些片段重组成PDU。同一层内SDU作为PDU的净荷（payload）字段出现，因此可以说上层PDU由本层PDU（通过其SDU字段）承载。每层的PDU除用于承载紧邻上层的PDU（即承载数据）外，也用于承载本层协议内部通信所需的控制信息</li>
<li>应用层实体（如客户或服务器进程）间交换的PDU称为应用数据（application data），其中在TCP应用进程之间交换的是没有长度限制的单个双向字节流，在UDP应用进程之间交换的是其长度不超过UDP发送缓冲区大小的单个记录（record），在SCTP应用进程之间交换的是没有总长度限制的单个或多个双向记录流</li>
<li>传输层实体间交换的PDU称为消息（message），其中TCP的PDU特称为分节（segment）。消息或分节的长度是有限的。在TCP传输层中，发送端TCP把来自应用进程的字节流数据（即由应用进程通过一次次输出操作写出到发送端TCP套接字中的数据）按顺序经分割后封装在各个分节中传送给接收端TCP，其中每个分节所封装的数据既可能是发送端应用进程单次输出操作的结果，也可能是连续数次输出操作的结果，而且每个分节所封装的单次输出操作的结果或者首尾两次输出操作的结果既可能是完整的，也可能是不完整的，具体取决于可在连接建立阶段由对端通告的最大分节大小（maximum segment size，MSS）以及外出接口的最大传输单元（maximum transmission unit，MTU）或外出路径的路径MTU（如果网络层具有路径MTU发现功能，如IPV6）</li>
<li>分节除了用于承载应用数据外，也用于建立连接（SYN分节）、终止连接（FIN分节）、中止连接（RST分节）、确认数据接收（ACK分节）、刷送待发数据（PSH分节）和携带紧急数据指针（URG分节），而且这些功能（包括承载数据）可以灵活组合</li>
<li>UDP传输层相当简单，发送端UDP就把来自应用进程的单个记录整个封装在UDP消息中传送给接收端UDP</li>
<li>网络层实体间交换的PDU称为IP数据报（IP datagram），发送端IP把来自传输层的消息（或TCP分节）整个封装在IP数据报中传送。链路层实体间交换的PDU称为帧（frame），其长度取决于具体的接口。IP数据报由IP首部和所承载的传输层数据（即网络层的SDU）构成。过长的IP数据报无法封转在单个顿中，需要先对其SDU进行分片（fragmentation），再把分成的各个片段（fragmemt）冠以新的IP首部封装到多个帧中。在一个IP数据报从源端到目的端的传送过程中，分片操作既可能发生在源端，也可能发生在途中，而其逆操作即重组（reassembly）一般只发生在目的端：SCTP为了传送过长的记录采取了类似的分片和重组措施</li>
<li>不论是否分片，都由IP作为链路层的SDU传入链路层，并由链路层封装在帧中的数据称为分组（packet，俗称包）</li>
</ul>
<h1 id="一个简单的时间获取客户程序"><a href="#一个简单的时间获取客户程序" class="headerlink" title="一个简单的时间获取客户程序"></a>一个简单的时间获取客户程序</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;unp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd, n;</span><br><span class="line">    <span class="keyword">char</span> recvline[MAXLINE + <span class="number">1</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">        err_quit(<span class="string">&quot;usage: daytimetcpcli &lt;IPaddress&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        err_sys(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">    <span class="keyword">if</span> (inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;servaddr.sin_addr) &lt;= <span class="number">0</span>)</span><br><span class="line">        err_quit(<span class="string">&quot;inet_pton error for %s&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connect(sockfd, (SA *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) &lt; <span class="number">0</span>)</span><br><span class="line">        err_sys(<span class="string">&quot;connect error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((n = read(sockfd, recvline, MAXLINE)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        recvline[n] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fputs</span>(recvline, <span class="built_in">stdout</span>) == EOF)</span><br><span class="line">            err_sys(<span class="string">&quot;fputs error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        err_sys(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>int inet_pton(int af, const char *src, void *dst);，它是一个支持IPv6的新函数。以前的代码使用in_addr_t inet_addr(const char *cp);函数来把ASCII点分十进制数串变换成正确的格式，不过它有不少局限，而这些局限在inet_pton中得以纠正</li>
<li>如果服务器返回的数据量很大，就不能确保一次read调用能返回服务器的整个应答。因此从TCP套接字读取数据时，总是需要把read编写在某个循环中，当read返回0（表明对端关闭连接）或负值（表明发生错误）时终止循环</li>
<li>上述程序的IPv6版本</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> <span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((sockfd = socket(AF_INET6, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    err_sys(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line"></span><br><span class="line">bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">servaddr.sin6_family = AF_INET6;</span><br><span class="line">servaddr.sin6_port = htons(SERV_PORT);</span><br><span class="line"><span class="keyword">if</span> (inet_pton(AF_INET6, argv[<span class="number">1</span>], &amp;servaddr.sin6_addr) &lt;= <span class="number">0</span>)</span><br><span class="line">    err_quit(<span class="string">&quot;inet_pton error for %s&quot;</span>, argv[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<h1 id="一个简单的时间获取服务器程序"><a href="#一个简单的时间获取服务器程序" class="headerlink" title="一个简单的时间获取服务器程序"></a>一个简单的时间获取服务器程序</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;unp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buff[MAXLINE];</span><br><span class="line">    <span class="keyword">time_t</span> ticks;</span><br><span class="line"></span><br><span class="line">    listenfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_port = htons(SERV_PORT);</span><br><span class="line">    serveraddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    Bind(listenfd, (SA*)&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line"></span><br><span class="line">    Listen(listenfd, LISTENQ);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        connfd = Accept(listenfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        ticks = time(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">snprintf</span>(buff, <span class="keyword">sizeof</span>(buff), <span class="string">&quot;%24s\r\n&quot;</span>, ctime(&amp;ticks));</span><br><span class="line">        Write(connfd, buff, <span class="built_in">strlen</span>(buff));</span><br><span class="line"></span><br><span class="line">        Close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Close(listenfd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>INADDR_ANY要是服务器主机有多个网络接口，服务器进程就可以在任意网络接口上接受客户连接</li>
</ul>
]]></content>
      <categories>
        <category>UNIX网络编程</category>
      </categories>
      <tags>
        <tag>UNIX网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Chap02_传输层：TCP、UDP和SCTP</title>
    <url>/2022/05/11/UNP/Chap02_%E4%BC%A0%E8%BE%93%E5%B1%82%EF%BC%9ATCP%E3%80%81UDP%E5%92%8CSCTP/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li>传输层包括TCP、UDP和SCTP（Stream Control Transmission Protocol，流控制传输协议）</li>
<li>UDP是一个简单的、不可靠的数据报协议，而TCP是一个复杂、可靠的字节流协议。SCTP与TCP类似之处在于它也是一个可靠的传输协议，但它还提供消息边界、传输级别多宿（multihoming）支持以及将头端阻塞（head-of-line blooking）减少到最小的一种方法</li>
</ul>
<h1 id="用户数据报协议（UDP）"><a href="#用户数据报协议（UDP）" class="headerlink" title="用户数据报协议（UDP）"></a>用户数据报协议（UDP）</h1><ul>
<li>UDP是一个简单的传输层协议，应用进程往一个UDP套接字写入一个消息，该消息随后被封装（encapsulating）到一个UDP数据报，该UDP数据报进而又被封装到一个IP数据报，然后发送到目的地。UDP不保证UDP数据报会到达其最终目的地，不保证各个数据报的先后顺序跨网络后保持不变，也不保证每个数据报只到达一次</li>
<li>使用UDP进行网络编程所遇到的问题是它缺乏可靠性。如果一个数据报到达了其最终目的地，但是校验和检测发现有错误，或者该数据报在网络传输途中被丢弃了，它就无法被投递给UDP套接字，也不会被源端自动重传。如果想要确保一个数据报到达其目的地，可以往应用程序中添置一大堆的特性：来自对端的确认、本端的超时与重传等</li>
<li>每个UDP数据报都有一个长度。如果一个数据报正确地到达其目的地，那么该数据报的长度将随数据一道传递给接收端应用进程。TCP是一个字节流（byte-stream）协议，没有任何记录边界，这一点不同于UDP</li>
<li>UDP提供无连接的（connectionless）服务，因为UDP客户与服务器之间不必存在任何长期的关系。举例来说，一个UDP客户可以创建一个套接字并发送一个数据报给一个给定的服务器，然后立即用同一个套接字发送另一个数据报给另一个服务器。同样地，一个UDP服务器可以用同一个UDP套接字从若干个不同的客户接收数据报，每个客户一个数据报</li>
</ul>
<h1 id="传输控制协议（TCP）"><a href="#传输控制协议（TCP）" class="headerlink" title="传输控制协议（TCP）"></a>传输控制协议（TCP）</h1><ul>
<li>首先，TCP提供客户与服务器之间的连接（connection）。TCP客户先与某个给定服务器建立一个连接，再跨该连接与那个服务器交换数据，然后终止这个连接。其次，TCP还提供了可靠性（reliability）。当TCP向另一端发送数据时，它要求对端返回一个确认。如果没有收到确认，TCP就自动重传数据并等待更长时间。在数次重传失败后，TCP才放弃，如此在尝试发送数据上所花的总时间一般为4～10分钟（依赖于具体实现）</li>
<li>TCP通过给其中每个字节关联一个序列号对所发送的数据进行排序（sequencing）。假设一个应用写2048字节到一个TCP套接字，导致TCP发送2个分节：第一个分节所含数据的序列号为1～1024，第二个分节所含数据的序列号为1025～2048。如果这些分节非顺序到达，接收端TCP将先根据它们的序列号重新排序，再把结果数据传递给接收应用。如果接收端TCP接收到来自对端的重复数据（警如说对端认为一个分节已丢失并因此重传，而这个分节并没有真正丢失，只是网络通信过于拥挤），它可以（根据序列号）判定数据是重复的，从而丢弃重复数据</li>
<li>再次，TCP提供流量控制（fow control）。TCP总是告知对端在任何时刻它一次能够从对端接收多少字节的数据，这称为通告窗口（advertised window）。在任何时刻，该窗口指出接收缓冲区中当前可用的空间量，从而确保发送端发送的数据不会使接收缓冲区溢出。该窗口时刻动态变化：当接收到来自发送端的数据时，窗口大小就减小，但是当接收端应用从缓冲区中读取数据时，窗口大小就增大。通告窗口大小减小到0是有可能的：当TCP对应某个套接字的接收缓冲区已满，导致它必须等待应用从该缓冲区读取数据时，方能从对端再接收数据</li>
<li>TCP连接是全双工的</li>
</ul>
<h1 id="流控制传输协议（SCTP）"><a href="#流控制传输协议（SCTP）" class="headerlink" title="流控制传输协议（SCTP）"></a>流控制传输协议（SCTP）</h1><ul>
<li>SCTP在客户和服务器之间提供关联（association），并像TCP那样给应用提供可靠性、排序、流量控制以及全双工的数据传送。SCTP中使用“关联”一词取代“连接”是为了避免这样的内涵：一个连接只涉及两个IP地址之间的通信。一个关联指代两个系统之间的一次通信，它可能因为SCTP支持多宿而涉及不止两个地址</li>
<li>与TCP不同的是，SCTP是面向消意的（message-oriented）。它提供各个记录的按序递送服务。与UDP一样，由发送端写入的每条记录的长度随数据一道传递给接收端应用</li>
<li>SCTP能够在所连接的端点之间提供多个流，每个流各自可靠地按序递送消息。一个流上某个消息的丢失不会阻塞同一关联其他流上消息的投递。这种做法与TCP正好相反，就TCP而言，在单一字节流中任何位置的字节丢失都将阻塞该连接上其后所有数据的递送，直到该丢失被修复为止</li>
</ul>
<h1 id="TCP连接的建立和终止"><a href="#TCP连接的建立和终止" class="headerlink" title="TCP连接的建立和终止"></a>TCP连接的建立和终止</h1><h2 id="三路握手"><a href="#三路握手" class="headerlink" title="三路握手"></a>三路握手</h2><ul>
<li>建立一个TCP连接</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/unp/image-20221022103048199.png"></p>
<h2 id="TCP选项"><a href="#TCP选项" class="headerlink" title="TCP选项"></a>TCP选项</h2><ul>
<li>MSS选项。发送SYN的TCP一端使用本选项通告对端它的最大分节大小（maximum segmentsize）即MSS，也就是它在本连接的每个TCP分节中愿意接受的最大数据量。发送端TCP使用接收端的MSS值作为所发送分节的最大大小，可以使用TCP_MAXSEG套接字选项提取和设置这个TCP选项</li>
<li>窗口规模选项。TCP连接任何一端能够通告对端的最大窗口大小是65535，因为在TCP首部中相应的字段占16位。可以使用SO_RCVBUF套接字选项</li>
</ul>
<h2 id="TCP连接终止"><a href="#TCP连接终止" class="headerlink" title="TCP连接终止"></a>TCP连接终止</h2><ul>
<li>终止一个连接</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/unp/image-20221022103647833.png"></p>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/unp/image-20221022103817617.png"></p>
<ul>
<li>当套接字被关闭时，其所在端TCP各自发送了一个FIN。在图中指出，这是由应用进程调用close而发生的，不过需认识到，当一个Unix进程无论自愿地（调用exit或从main函数返回）还是非自愿地（收到一个终止本进程的信号）终止时，所有打开的描述符都被关闭，这也导致仍然打开的任何TCP连接上也发出一个FIN</li>
</ul>
<h2 id="TCP状态转换图"><a href="#TCP状态转换图" class="headerlink" title="TCP状态转换图"></a>TCP状态转换图</h2><p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/unp/image-20221022104422935.png"></p>
<ul>
<li>自ESTABLISHED状态引出的两个箭头处理连接的终止。如果某个应用进程在接收到一个FIN之前调用close（主动关闭），那就转换到FIN_WAIT_1状态。但如果某个应用进程在ESTABLISHED状态期间接收到一个FIN（被动关闭），那就转换到CLOSE_WAIT状态</li>
</ul>
<h2 id="观察分组"><a href="#观察分组" class="headerlink" title="观察分组"></a>观察分组</h2><p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/unp/image-20221022104714977.png"></p>
<ul>
<li>如果该连接的整个目的仅仅是发送一个单分节的请求和接收一个单分节的应答，那么使用TCP有8个分节的开销。如果改用UDP，那么只需交换两个分组：一个承载请求，一个承载应答。然而从TCP切换到UDP将丧失TCP提供给应用进程的全部可靠性，迫使可靠服务的一大堆细节从传输层（TCP）转移到UDP应用进程。TCP提供的另一个重要特性即拥塞控制也必须由UDP应用进程来处理。尽管如此，仍然许多网络应用是使用UDP构建的，因为它们需要交换的数据量较少，而UDP避免了TCP连接建立和终止所需的开销</li>
</ul>
<h2 id="TIME-WAIT状态"><a href="#TIME-WAIT状态" class="headerlink" title="TIME_WAIT状态"></a>TIME_WAIT状态</h2><ul>
<li>执行主动关闭的那端经历了TIME_WAIT状态。该端点停留在这个状态的持续时间是最长分节生命期（maximum segment lifetime，MSL）的两倍，有时候称之为2MSL。任何TCP实现都必须为MSL选择一个值。RFC1122的建议值是2分钟，不过源自Berkeley的实现传统上改用30秒这个值。这意味着TIME_WAIT状态的持续时间在1分钟到4分钟之间</li>
<li>MSL是任何IP数据报能够在因特网中存活的最长时间。这个时间是有限的，因为每个数据报含有一个称为跳限（hop limit）的8位字段，它的最大值为255。尽管这是一个跳数限制而不是真正的时间限制，仍然假设：具有最大跳限（255）的分组在网络中存在的时间不可能超过MSL秒</li>
<li>TIME_WAIT状态有两个存在的理由：（1）可靠地实现TCP全双工连接的终止；（2）允许老的重复分节在网络中消逝</li>
<li>第一个理由可以通过查看图2-5并假设最终的ACK丢失了来解释。服务器将重新发送它的最终那个FIN，因此客户必须维护状态信息，以允许它重新发送最终那个ACK。要是客户不维护状态信息，它将响应以一个RST，该分节将被服务器解释成一个错误。如果TCP打算执行所有必要的工作以彻底终止某个连接上两个方向的数据流（即全双工关闭），那么它必须正确处理连接终止序列4个分节中任何一个分节丢失的情况。本例子也说明了为什么执行主动关闭的那一端是处于TIME_WAIT状态的那一端：因为可能不得不重传最终那个ACK的就是那一端</li>
<li>为理解存在TIME_WAIT状态的第二个理由，假设在12.106.32.254的1500端口和206.168.112.219的21端口之间有一个TCP连接。关闭这个连接，过一段时间后在相同的IP地址和端口之间建立另一个连接。后一个连接称为前一个连接的化身（incarnation），因为它们的IP地址和端口号都相同。TCP必须防止来自某个连接的老的重复分组在该连接已终止后再现，从而被误解成属于同一连接的某个新的化身。为做到这一点，TCP将不给处于TIME_WAIT状态的连接发起新的化身。既然TIME_WAIT状态的持续时间是MSL的2倍，这就足以让某个方向上的分组最多存活MSL秒即被丢弃，另一个方向上的应答最多存活MSL秒也被丢弃。通过实施这个规则，就能保证每成功建立一个TCP连接时，来自该连接先前化身的老的重复分组都已在网络中消逝了</li>
</ul>
<h1 id="缓冲区大小及限制"><a href="#缓冲区大小及限制" class="headerlink" title="缓冲区大小及限制"></a>缓冲区大小及限制</h1><ul>
<li>当一个IP数据报将从某个接口送出时，如果它的大小超过相应链路的MTU，IPV4和IPV6都将执行分片（fragmentation）。这些片段在到达最终目的地之前通常不会被重组（reassembling）。IPV4主机对其产生的数据报执行分片，IPv4路由器则对其转发的数据报执行分片。然而IPV6只有主机对其产生的数据报执行分片，IPV6路由器不对其转发的数据报执行分片</li>
<li>每一个TCP套接字有一个发送缓冲区，我们可以使用SO_SNDBUF套接字选项来更改该缓冲区的大小。当某个应用进程调用write时，内核从该应用进程的缓冲区中复制所有数据到所写套接字的发送缓冲区。如果该套接字的发送缓冲区容不下该应用进程的所有数据（或是应用进程的缓冲区大于套接字的发送缓冲区，或是套接字的发送缓冲区中已有其他数据），该应用进程将被投入睡眠。这里假设该套接字是阻塞的，它是通常的默认设置。内核将不从write系统调用返回，直到应用进程缓冲区中的所有数据都复制到套接字发送缓冲区。因此，从写一个TCP套接字的write调用成功返回仅仅表示我们可以重新使用原来的应用进程缓冲区，并不表明对端的TCP或应用进程已接收到数据</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/unp/image-20221022113845380.png"></p>
<ul>
<li>以虚线框展示UDP套接字发送缓冲区，因为它实际上并不存在。任何UDP套接字都有发送缓冲区大小（可以使用SO_SNDBUF套接字选项更改它），不过它仅仅是可写到该套接字的UDP数据报的大小上限。如果一个应用进程写一个大于套接字发送缓冲区大小的数据报，内核将返回该进程一个EMSGSIZE错误。既然UDP是不可靠的，它不必保存应用进程数据的一个副本，因此无需一个真正的发送缓冲区。（应用进程的数据在沿协议栈向下传递时，通常被复制到某种格式的一个内核缓冲区中，然而当该数据被发送之后，这个副本就被数据链路层丢弃了。）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/unp/image-20221022114048504.png"></p>
]]></content>
      <categories>
        <category>UNIX网络编程</category>
      </categories>
      <tags>
        <tag>UNIX网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Chap04_基本TCP套接字编程</title>
    <url>/2022/05/11/UNP/Chap04_%E5%9F%BA%E6%9C%ACTCP%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="connect函数"><a href="#connect函数" class="headerlink" title="connect函数"></a>connect函数</h1><ul>
<li>客户在调用函数connect前不必非得调用bind函数，因为如果需要的话，内核会确定源IP地址，并选择一个临时端口作为源端口</li>
<li>如果是TCP套接字，调用connect函数将激发TCP的三路握手过程，而且仅在连接建立成功或出错时才返回，其中出错返回可能有以下几种情况：</li>
</ul>
<blockquote>
<p>（1）若TCP客户没有收到SYN分节的响应，则返回ETIMEDOUT错误。举例来说，调用connect函数时，4.4BSD内核发送一个SYN，若无响应则等待6s后再发送一个，若仍无响应则等待24s后再发送一个。若总共等了75s后仍未收到响应则返回本错误</p>
<p>（2）若对客户的SYN的响应是RST（表示复位），则表明该服务器主机在我们指定的端口上没有进程在等待与之连接（例如服务器进程也许没在运行）。这是一种硬错误，客户一接收到RST就马上返间ECONNREFUSED错误。RST是TCP在发生错误时发送的一种TCP分节。产生RST的三个条件是：目的地为某端口的SYN到达，然而该端口上没有正在监听的服务器；TCP想取消一个已有连接；TCP接收到一个根本不存在的连接上的分节</p>
<p>（3）若客户发出的SYN在中间的某个路由器上引发了一个“destination unreachable”（目的地不可达）ICMP错误，则认为是一种软错误。客户主机内核保存该消息，并按第一种情况中所述的时间间隔继续发送SYN。若在某个规定的时间（4.4BSD规定75s）后仍未收到响应，则把保存的消息（即ICMP错误）作为EHOSTUNREACH或ENETONREACH错误返回给进程。以下两种情形也是有可能的：一是按照本地系统的转发表，根本没有到达远程系统的路径；二是connect调用根本不等待就返回</p>
</blockquote>
<ul>
<li>按照TCP状态转换图，connect函数导致当前套接字从CLOSED状态（该套接字自从由socket函数创建以来一直所处的状态）转移到SYN_SENT状态，若成功则再转移到ESTABLISHED状态。若connect失败则该套接字不再可用，必须关闭，不能对这样的套接字再次调用connect函数。当循环调用函数connect为给定主机尝试各个IP地址直到有一个成功时，在每次connect失败后，都必须close当前的套接字描述符并重新调用socket</li>
</ul>
<h1 id="listen函数"><a href="#listen函数" class="headerlink" title="listen函数"></a>listen函数</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>backlog参数，内核为任何一个给定的监听套接字维护两个队列：（1）未完成连接队列（incomplete connection queue），每个这样的SYN分节对应其中一项：已由某个客户发出并到达服务器，而服务器正在等待完成相应的TCP三路握手过程。这些套接字处于SYN_RCVD状态。（2）已完成连接队列（completed connection queue），每个已完成TCP三路握手过程的客户对应其中一项。这些套接字处于ESTABLISHED状态</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/unp/image-20221022200015547.png"></p>
<h1 id="accept函数"><a href="#accept函数" class="headerlink" title="accept函数"></a>accept函数</h1><ul>
<li>接受连接并显示客户地址</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">socklen_t</span> len;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line"><span class="keyword">char</span> buff[MAXLINE];</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    connfd = Accept(listenfd, (SA *)&amp;cliaddr, &amp;len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connection from %s, port: %d\n&quot;</span>,</span><br><span class="line">           Inet_ntop(AF_INET, &amp;cliaddr.sin_addr, buff, <span class="keyword">sizeof</span>(buff)),</span><br><span class="line">           ntohs(cliaddr.sin_port));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="并发服务器"><a href="#并发服务器" class="headerlink" title="并发服务器"></a>并发服务器</h1><ul>
<li>典型的并发服务器轮廓</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">int</span> listenfd, connfd;</span><br><span class="line"></span><br><span class="line">listenfd = Socket(...);</span><br><span class="line">Bind(listenfd, ...)</span><br><span class="line">Listen(listenfd, LISTENQ);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    connfd = Accept(listenfd, ...);</span><br><span class="line">    <span class="keyword">if</span> ((pid = Fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">        Close(listenfd);</span><br><span class="line">        doit(connfd);</span><br><span class="line">        Close(connfd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    Close(connfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对一个TCP套接字调用close会导致发送一个FIN，随后是正常的TCP连接终止序列。为什么上述父进程对connfd调用close没有终止它与客户的连接，为了便于理解，每个文件或套接字都有一个引用计数。引用计数在文件表项中维护，它是当前打开着的引用该文件或套接字的描述符的个数。上述代码socket返回后与listenfd关联的文件表项的引用计数值为1。accept返回后与connfd关联的文件表项的引用计数值也为1。然而fork返回后，这两个描述符就在父进程与子进程间共享（也就是被复制），因此与这两个套接字相关联的文件表项各自的访问计数值均为2。这么一来，当父进程关闭connfd时，它只是把相应的引用计数值从2减为1。该套接字真正的清理和资源释放要等到其引用计数值到达0时才发生。这会在稍后子进程也关闭connfd时发生</li>
</ul>
<h1 id="getsockname和getpeername函数"><a href="#getsockname和getpeername函数" class="headerlink" title="getsockname和getpeername函数"></a>getsockname和getpeername函数</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockname</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpeername</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>这两个函数返回与某个套接字关联的本地协议地址（getsockname），或者返回与某个套接字关联的外地协议地址（getpeername）</li>
<li>当一个服务器是由调用过accept的某个进程通过调用exec执行程序时，它能够获取客户身份的唯一途径便是调用getpeername</li>
</ul>
]]></content>
      <categories>
        <category>UNIX网络编程</category>
      </categories>
      <tags>
        <tag>UNIX网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Chap03_套接字编程简介</title>
    <url>/2022/05/11/UNP/Chap03_%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="套接字地址结构"><a href="#套接字地址结构" class="headerlink" title="套接字地址结构"></a>套接字地址结构</h1><ul>
<li>大多数套接字函数都需要一个指向套接字地址结构的指针作为参数。每个协议族都定义它自己的套接字地址结构。这些结构的名字均以sockadar_开头，并以对应每个协议族的唯一后级结尾</li>
</ul>
<h2 id="IPv4套接字地址结构"><a href="#IPv4套接字地址结构" class="headerlink" title="IPv4套接字地址结构"></a>IPv4套接字地址结构</h2><p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/unp/image-20221022152427974.png"></p>
<ul>
<li>长度字段sin_len是为增加对OSI协议的支持而随4.3BSD-Rcno添加的。在此之前，第一个成员是sin_family，它是一个无符号短整数（unsigned short）。并不是所有的厂家都支持套接字地址结构的长度字段，而且POSIX规范也不要求有这个成员。即使有长度字段，也无须设置和检查它</li>
<li>POSIX规范只需要这个结构中的3个字段：sin_family、sin_addr和sin_port。对于符合POSIX的实现来说，定义额外的结构字段是可以接受的，这对于网际套接字地址结构来说也是正常的。几乎所有的实现都增加了sin_zero字段，所以所有的套接字地址结构大小都至少是16字节</li>
</ul>
<h2 id="通用套接字地址结构"><a href="#通用套接字地址结构" class="headerlink" title="通用套接字地址结构"></a>通用套接字地址结构</h2><ul>
<li>当作为一个参数传递进任何套接字函数时，套接字地址结构总是以引用形式（也就是以指向该结构的指针）来传递。然而以这样的指针作为参数之一的任何套接字函数必须处理来自所支持的任何协议族的套接字地址结构。在如何声明所传递指针的数据类型上存在一个问题。有了ANSI C后解决办法很简单：void*是通用的指针类型。然而套接字函数是在ANSIC之前定义的，在1982年采取的办法是在&lt;sys/socket.h&gt;头文件中定义一个通用的套接字地址结构</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/unp/image-20221022153323721.png"></p>
<h2 id="IPv6套接字结构"><a href="#IPv6套接字结构" class="headerlink" title="IPv6套接字结构"></a>IPv6套接字结构</h2><p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/unp/image-20221022153623674.png"></p>
<h2 id="套接字地址结构的比较"><a href="#套接字地址结构的比较" class="headerlink" title="套接字地址结构的比较"></a>套接字地址结构的比较</h2><p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/unp/image-20221022154135627.png"></p>
<h1 id="字节排序函数"><a href="#字节排序函数" class="headerlink" title="字节排序函数"></a>字节排序函数</h1><ul>
<li>小端：将低序字节存储在起始位置</li>
<li>大端：将高序字节存储在起始位置</li>
<li>字节序之间的转换</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="keyword">uint32_t</span> hostlong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="keyword">uint16_t</span> hostshort)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">uint32_t</span> netlong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">uint16_t</span> netshort)</span></span>;</span><br></pre></td></tr></table></figure>

<h1 id="inet-aton、inet-addr和inet-ntoa"><a href="#inet-aton、inet-addr和inet-ntoa" class="headerlink" title="inet_aton、inet_addr和inet_ntoa"></a>inet_aton、inet_addr和inet_ntoa</h1><ul>
<li>inet_aton、inet_addr和inet_ntoa在点分十进制数串（例如“206.168.112.96”）与它长度为32位的网络字节序二进制值间转换IPv4地址</li>
<li>两个较新的函数inet_pton和inet_ntop对于IPv4地址和IPv6地址都适用</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cp, struct in_addr *inp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">inet_ntoa</span><span class="params">(struct in_addr in)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个函数inet_aton将cp所指C字符串转换成一个32位的网络字节序二进制值，并通过指针inp来存储。若成功则返回1，否则返回0。inet_aton函数有一个没写入正式文档中的特征：如果inp指针为空，那么该函数仍然对输入的字符串执行有效性检查，但是不存储任何结果</li>
<li>inet_addr进行相同的转换，返回值为32位的网络字节序二进制值。该函数存在一个问题：所有2^32可能的二进制值都是有效的IP地址（从0.0.0.0到255.255.255.255），但是当出错时该函数返回INADDR_NONE常值（通常是一个32位均为1的值）。这意味着点分十进制数串255.255.255.255（这是IPV4的有限广播地址）不能由该函数处理，因为它的二进制值被用来指示该函数失败</li>
<li>inet_addr函数还存在一个潜在的问题：一些手册页面声明该函数出错时返回-1而不是INADDR_NONE。这样在对该函数的返回值（一个无特号的值）和一个负常值（-1）进行比较时可能会发生问题，具体取决于C编译器</li>
<li>inet_ntoa函数将一个32位的网络字节序二进制IPv4地址转换成相应的点分十进制数串。由该函数的返回值所指向的字符串驻留在静态内存中。这意味着该函数是不可重入的</li>
</ul>
<h1 id="inet-pton和inet-ntop"><a href="#inet-pton和inet-ntop" class="headerlink" title="inet_pton和inet_ntop"></a>inet_pton和inet_ntop</h1><ul>
<li>这两个函数是随IPv6出现的新函数，对于IPv4地址和IPv6地址都适用</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">void</span> *dst)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">char</span> *dst, <span class="keyword">socklen_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>

<h1 id="readn、writen和readline函数"><a href="#readn、writen和readline函数" class="headerlink" title="readn、writen和readline函数"></a>readn、writen和readline函数</h1><ul>
<li>字节流套接字上的read和write函数所表现的行为不同于通常的文件IO。字节流套接字上调用read或write输入或输出的字节数可能比请求的数量少，然而这不是出错的状态。这个现象的原因在于内核中用于套接字的缓冲区可能已达到了极限。此时所需的是调用者再次调用read或write函数，以输入或输出剩余的字节。这个现象在read一个字节流套接字时很常见，但是在write一个字节流套接字时只能在该套接字为非阻塞的前提下才出现</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;unp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readn</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> nleft;</span><br><span class="line">    <span class="keyword">ssize_t</span> nread;</span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line"></span><br><span class="line">    ptr = buf;</span><br><span class="line">    nleft = n;</span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((nread = read(fd, ptr, nleft)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">                nread = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        nleft -= nread;</span><br><span class="line">        ptr += nread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (n - nleft);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">writen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> nleft;</span><br><span class="line">    <span class="keyword">ssize_t</span> nwriten;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *ptr;</span><br><span class="line"></span><br><span class="line">    ptr = buf;</span><br><span class="line">    nleft = n;</span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((nwriten = write(fd, ptr, nleft)) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nwriten &lt; <span class="number">0</span> &amp;&amp; errno == EINTR)</span><br><span class="line">                nwriten = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nleft -= nwriten;</span><br><span class="line">        ptr += nwriten;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UNIX网络编程</category>
      </categories>
      <tags>
        <tag>UNIX网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Chap05_TCP客户/服务器程序示例</title>
    <url>/2022/05/15/UNP/Chap05_TCP%E5%AE%A2%E6%88%B7%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<h1 id="TCP回射服务器程序"><a href="#TCP回射服务器程序" class="headerlink" title="TCP回射服务器程序"></a>TCP回射服务器程序</h1><ul>
<li>main函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;unp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> childpid;</span><br><span class="line">    <span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">    <span class="keyword">socklen_t</span> clilen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    listenfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">    Bind(listenfd, (SA *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">    Listen(listenfd, LISTENQ);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">        connfd = Accept(listenfd, (SA *)&amp;cliaddr, &amp;clilen);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((childpid = Fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">            Close(listenfd);</span><br><span class="line">            str_echo(connfd);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>str_echo函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;unp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">str_echo</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> n;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">    <span class="keyword">while</span> ((n = read(sockfd, buf, MAXLINE)) &gt; <span class="number">0</span>)</span><br><span class="line">        Writen(sockfd, buf, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span> &amp;&amp; errno == EINTR)</span><br><span class="line">        <span class="keyword">goto</span> again;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        err_sys(<span class="string">&quot;str_echo: read error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="TCP回射客户程序"><a href="#TCP回射客户程序" class="headerlink" title="TCP回射客户程序"></a>TCP回射客户程序</h1><ul>
<li>main函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;unp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">        err_quit(<span class="string">&quot;usage: tcpcli &lt;IPaddress&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    sockfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">    Inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;servaddr.sin_addr);</span><br><span class="line"></span><br><span class="line">    Connect(sockfd, (SA *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">    str_cli(<span class="built_in">stdin</span>, sockfd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>str_cli函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;unp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">str_cli</span><span class="params">(FILE* fp, <span class="keyword">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> sendline[MAXLINE], recvline[MAXLINE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (Fgets(sendline, MAXLINE, fp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Writen(sockfd, sendline, <span class="built_in">strlen</span>(sendline));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Readline(sockfd, recvline, MAXLINE) == <span class="number">0</span>)</span><br><span class="line">            err_quit(<span class="string">&quot;str_cli: server terminated prematurely&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Fputs(recvline, <span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="正常终止"><a href="#正常终止" class="headerlink" title="正常终止"></a>正常终止</h1><ul>
<li>（1）当键入EOF字符时，fgets返回一个空指针，于是str_cli函数返回</li>
<li>（2）当str_cli返回到客户的main函数时，main通过调用exit终止</li>
<li>（3）进程终止处理的部分工作是关闭所有打开的描述符，因此客户打开的套接字由内核关闭。这导致客户TCP发送一个FIN给服务器，服务器TCP则以ACK响应，这就是TCP连接终止序列的前半部分。至此，服务器套接字处于CLOSE_WAIT状态，客户套接字则处于FIN_WAIT_2状态</li>
<li>（4）当服务器TCP接收FIN时，服务器子进程阻塞于read调用，于是read返回0。这导致str_echo函数返回服务器子进程的main函数</li>
<li>（5）服务器子进程通过调用exit来终止</li>
<li>（6）服务器子进程中打开的所有描述符随之关闭。由子进程来关闭已连接套接字会引发TCP连接终止序列的最后两个分节：一个从服务器到客户的FIN和一个从客户到服务器的ACK。至此，连接完全终止，客户套接字进入TIME_WAIT状态</li>
<li>（7）进程终止处理的另一部分内容是：在服务器子进程终止时，给父进程发送一个SIGCHLD信号。这一点在本例中发生了，但是没有在代码中捕获该信号，而该信号的默认行为是被忽略。既然父进程未加处理，子进程于是进入僵死状态</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/unp/image-20221023230248776.png"></p>
<h1 id="处理SIGCHLD信号"><a href="#处理SIGCHLD信号" class="headerlink" title="处理SIGCHLD信号"></a>处理SIGCHLD信号</h1><ul>
<li>Signal函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">void</span> <span class="title">Sigfunc</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Sigfunc *<span class="title">Signal</span><span class="params">(<span class="keyword">int</span> signo, Sigfunc *func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>, <span class="title">oact</span>;</span></span><br><span class="line"></span><br><span class="line">    act.sa_handler = func;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (signo == SIGALRM) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SA_INTERRUPT</span></span><br><span class="line">        act.sa_flags |= SA_INTERRUPT;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SA_RESTART</span></span><br><span class="line">        act.sa_flags |= SA_RESTART;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigaction(signo, &amp;act, &amp;oact) &lt; <span class="number">0</span>)</span><br><span class="line">        err_sys(<span class="string">&quot;sigaction error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oact.sa_handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>处理僵尸进程</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_chld</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> stat;</span><br><span class="line"></span><br><span class="line">    pid = wait(&amp;stat);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child %d terminated\n&quot;</span>, pid);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在信号处理函数中调用诸如printf这样的标准IO函数是不合透的，这里这是为查看子进程何时终止</li>
<li>当SIGCHLD信号递交时，父进程阻塞于accept调用。sig_chld函数（信号处理函数）执行，其wait调用取到子进程的PID和终止状态，随后是printf调用，最后返回。既然该信号是在父进程阻塞于慢系统调用（accept）时由父进程捕获的，内核就会使accept返回一个EINTR错误（被中断的系统调用）。而父进程不处理该错误，于是中止</li>
<li>在编写捕获信号的网络程序时，必须认清被中断的系统调用且处理它们。在这个运行在Solaris 9环境下特定例子中，标准C函数库中提供的signal函数不会使内核自动重启被中断的系统调用。也就是说，在Signal函数中设置的SA_RESTART标志在系统函数库的signal函数中并没有设置。另有些系统自动重启被中断的系统调用。如果在4.4BSD环境下照样使用系统函数库版本的Signal函数运行上述例子，那么内核将重启被中断的系统调用，于是accept不会返回错误</li>
<li>适用于慢系统调用的基本规则是：当阻塞于某个慢系统调用的一个进程捕获某个信号且相应信号处理函数返回时，该系统调用可能返回一个EINTR错误。有些内核自动重启某些被中断的系统调用。不过为了便于移植，当编写捕获信号的程序时（多数并发服务器捕获SIGCHLD），必须对慢系统调用返回EINTR有所准备。移植性问题是由早期使用的修饰词“可能”、“有些”和对POSIX的SA_RESTART标志的支持是可选的这一事实造成的。即使某个实现支持SA_RESTART标志，也并非所有被中断系统调用都可以自动重启。举例来说，大多数源自Berkeley的实现从不自动重启select，其中有些实现从不重启accept和recvfrom</li>
<li>为处理被中断的accept，修改如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line"><span class="keyword">if</span> ((connfd = accept(listenfd, (SA *)&amp;cliaddr, &amp;clilen)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        err_sys(<span class="string">&quot;accept error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="wait和waitpid"><a href="#wait和waitpid" class="headerlink" title="wait和waitpid"></a>wait和waitpid</h1><ul>
<li>为区分这两个函数用来清理已终止进程的区别，把TCP客户修改为同时建立5个与服务器的连接</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/unp/image-20221024001500009.png"></p>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/unp/image-20221024001522079.png"></p>
<ul>
<li>建立一个信号处理函数并在其中调用wait并不足以防止出现死进程。本问题在于：所有5个信号都在信号处理函数执行之前产生，而信号处理函数只执行一次，因为Unix信号一般是不排队的。更严重的是，本问题是不确定的。在刚刚运行的例子中，客户与服务器在同一个主机上，信号处理函数执行1次，留下4个僵死进程。但是如果在不同的主机上运行客户和服务器，那么信号处理函数一般执行2次：一次是第一个产生的信号引起的，由于另外4个信号在信号处理函数第一次执行时发生，因此该处理函数仅仅再被调用一次，从而留下3个僵死进程。不过有的时候，依赖于FIN到达服务器主机的时机，信号处理函数可能会执行3次甚至4次</li>
<li>正确的解决办法是调用waitpid而不是wait，原因在于：在一个循环内调用waitpid，以获取所有已终止子进程的状态。必须指定WNOHANG选项，它告知waitpid在有尚未终止的子进程在运行时不要阻塞。不能在循环内调用wait，因为没有办法防止wait在正运行的子进程尚有未终止时阻塞</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_chld</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> stat;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;stat, WNOHANG)) &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child %d terminated\n&quot;</span>, pid);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>服务器程序的最终版本。它正确处理accept返回的EINTR，并建立一个给所有已终止子进程调用waitpid的信号处理函数</li>
<li>本节的目的是示范我们在网络编程时可能会遇到的三种情况：</li>
</ul>
<blockquote>
<p>（1）当fork子进程时，必须捕获SIGCHLD信号；</p>
<p>（2）当捕获信号时，必须处理被中断的系统调用；</p>
<p>（3）SIGCHLD的信号处理函数必须正确编写，应使用waitpid函数以免留下僵死进程</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;unp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_chld</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> stat;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;stat, WNOHANG)) &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child %d terminated\n&quot;</span>, pid);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> childpid;</span><br><span class="line">    <span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">    <span class="keyword">socklen_t</span> clilen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    listenfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">    Bind(listenfd, (SA *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">    Listen(listenfd, LISTENQ);</span><br><span class="line"></span><br><span class="line">    Signal(SIGCHLD, sig_chld);      <span class="comment">// must call waitpid</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">        <span class="keyword">if</span> ((connfd = accept(listenfd, (SA *)&amp;cliaddr, &amp;clilen)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">                <span class="keyword">continue</span>;           <span class="comment">// back to for</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                err_sys(<span class="string">&quot;accept error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((childpid = Fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">            Close(listenfd);</span><br><span class="line">            str_echo(connfd);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="accept返回前连接中止"><a href="#accept返回前连接中止" class="headerlink" title="accept返回前连接中止"></a>accept返回前连接中止</h1><ul>
<li>类似于前一节中介绍的被中断系统调用的例子，另有一种情形也能够导致accept返回一个非致命的错误，在这种情况下，只需要再次调用accept。如图所示的分组序列在较忙的服务器（典型的是较忙的Web服务器）上已出现过。这里，三路握手完成从而连接建立之后，客户TCP却发送了一个RST（复位）。在服务器端看来，就在该连接已由TCP排队，等着服务器进程调用accept的时候RST到达。稍后，服务器进程调用accept</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/unp/image-20221024003219635.png"></p>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/unp/image-20221024003450887.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Accept</span><span class="params">(<span class="keyword">int</span> sockfd, SA *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">    <span class="keyword">if</span> ((n = accept(sockfd, addr, addrlen)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> EPROTO</span></span><br><span class="line">        <span class="keyword">if</span> (errno == EPROTO || errno == ECONNABORTED)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="keyword">if</span> (errno == ECONNABORTED)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            <span class="keyword">goto</span> again;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">            err_sys(<span class="string">&quot;accept error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="服务器进程终止"><a href="#服务器进程终止" class="headerlink" title="服务器进程终止"></a>服务器进程终止</h1><ul>
<li>启动客户/服务器对，然后杀死服务器子进程，模拟服务器进程崩溃的情形，所发生的步骤如下所述：</li>
<li>（1）在同一个主机上启动服务器和客户，并在客户上键入一行文本，以验证一切正常。正常情况下该行文本由服务器子进程回射给客户</li>
<li>（2）找到服务器子进程的进程ID，并执行kill命令杀死它。作为进程终止处理的部分工作，子进程中所有打开着的描述符都被关闭。这就导致向客户发送一个FIN，而客户TCP则响应以一个ACK。这就是TCP连接终止工作的前半部分</li>
<li>（3）SIGCHLD信号被发送给服务器父进程，并得到正确处理</li>
<li>（4）客户上没有发生任何特殊之事。客户TCP接收来自服务器TCP的FIN并响应以一个ACK，然而问题是客户进程阻塞在fgets调用上，等待从终端接收一行文本</li>
<li>（5）此时，在另外一个窗口上运行netstat命令，以观察套接字的状态，看到TCP连接终止序列的前半部分已经完成</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/unp/image-20221026232315609.png"></p>
<ul>
<li>（6）在客户上再键入一行文本</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/unp/image-20221026232503868.png"></p>
<ul>
<li>当键入“hello”时，strl_cli调用writen，客户TCP接着把数据发送给服务器。TCP允许这么做，因为客户TCP接收到FIN只是表示服务器进程已关闭了连接的服务器端，从而不再往其中发送任何数据而已。FIN的接收并没有告知客户TCP服务器进程已经终止（本例子中它确实是终止了）。当服务器TCP接收到来自客户的数据时，既然先前打开那个套接字的进程已经终止，于是响应以一个RST。通过使用tcpdump来观察分组，可以验证该RST确实发送了</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/unp/image-20221026232742202.png"></p>
<ul>
<li>（7）然而客户进程看不到这个RST，因为它在调用writen后立即调用readline，并且由于第2步中接收的FIN，所调用的readline立即返回0（表示EOF）。于是以出错信息“server terminated prematurely”（服务器过早终止）退出</li>
<li>（8）当客户终止时（通过调用err_quit），它所有打开着的描述符都被关闭</li>
<li>本例子的问题在于：当FIN到达套接字时，客户正阻塞在fgets调用上。客户实际上在应对两个描述符，套接字和用户输入，它不能单纯阻塞在这两个源中某个特定源的输入上，而是应该阻塞在其中任何一个源的输入上。这正是select和poll这两个函数的目的之一，重新编写str_cli函数之后，一且杀死服务器子进程，客户就会立即被告知已收到FIN</li>
</ul>
<h1 id="SIGPIPE信号"><a href="#SIGPIPE信号" class="headerlink" title="SIGPIPE信号"></a>SIGPIPE信号</h1><ul>
<li>当一个进程向某个已收到RST的套接字执行写操作时，内核向该进程发送一个SIGPIPE信号。该信号的默认行为是终止进程，因此进程必须捕获它以免不情愿地被终止。不论该进程是捕获了该信号并从其信号处理函数返回，还是简单地忽略该信号，写操作都将返回EPIPE错误</li>
<li>第一次写操作引发RST，第二次写引发SIGPIPE信号。写一个已接收了FIN的套接字不成问题，但是写一个己接收了RST的套接字则是一个错误</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">str_cli</span><span class="params">(FILE* fp, <span class="keyword">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> sendline[MAXLINE], recvline[MAXLINE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (Fgets(sendline, MAXLINE, fp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Writen(sockfd, sendline, <span class="number">1</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        Writen(sockfd, sendline + <span class="number">1</span>, <span class="built_in">strlen</span>(sendline) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Readline(sockfd, recvline, MAXLINE) == <span class="number">0</span>)</span><br><span class="line">            err_quit(<span class="string">&quot;str_cli: server terminated prematurely&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Fputs(recvline, <span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第一次把文本行数据的第一个字节写入套接字，暂停一秒钟后，第二次把同一文本行中剩余字节写入套接字。目的是让第一次writen引发一个RST，再让第二个writen产生SIGPIEE</li>
<li>处理SIGPIPE的建议方法取决于它发生时应用进程想做什么。如果没有特殊的事情要做，那么将信号处理办法直接设置为SIG_IGN，并假设后续的输出操作将捕捉EPIPE错误并终止。如果信号出现时需采取特殊措施（可能需在日志文件中登记），那么就必须捕获该信号，以便在信号处理函数中执行所有期望的动作。但是必须意识到，如果使用了多个套接字，该信号的递交无法告诉我们是哪个套接字出的错。如果确实需要知道是哪个write出了错，那么必须要么不理会该信号，要么从信号处理函数返回后再处理来自write的EPIPE</li>
</ul>
<h1 id="服务器主机崩溃"><a href="#服务器主机崩溃" class="headerlink" title="服务器主机崩溃"></a>服务器主机崩溃</h1><ul>
<li>必须在不同的主机上运行客户和服务器。先启动服务器，再启动客户，接着在客户上键入一行文本以确认连接工作正常，然后从网络上断开服务器主机，并在客户上键入另一行文本。这样同时也模拟了当客户发送数据时服务器主机不可达的情形（即建立连接后某些中间路由器不工作）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/unp/image-20221026234947945.png"></p>
<h1 id="服务器主机崩溃后重启"><a href="#服务器主机崩溃后重启" class="headerlink" title="服务器主机崩溃后重启"></a>服务器主机崩溃后重启</h1><p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/unp/image-20221026235122224.png"></p>
]]></content>
      <categories>
        <category>UNIX网络编程</category>
      </categories>
      <tags>
        <tag>UNIX网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Chap06_I/O复用：select和poll函数</title>
    <url>/2022/05/16/UNP/Chap06_IO%E5%A4%8D%E7%94%A8%EF%BC%9Aselect%E5%92%8Cpoll%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li>TCP回射例子中，TCP客户同时处理两个输入：标准输入和TCP套接字。遇到的问题是就在客户阻塞于（标准输入上的）fgets调用期间，服务器进程会被杀死。服务器TCP虽然正确地给客户TCP发送了一个FIN，但是既然客户进程正阻塞于从标准输入读入的过程，它将看不到这个EOF，直到从套接字读时为止（可能已过了很长时间）。这样的进程需要一种预先告知内核的能力，使得内核一旦发现进程指定的一个或多个IO条件就绪（也就是说输入已准备好被读取，或者描述符已能承接更多的输出），它就通知进程。这个能力称为I/O复用，是由select和poll这两个函数支持的</li>
</ul>
<h1 id="I-O模型"><a href="#I-O模型" class="headerlink" title="I/O模型"></a>I/O模型</h1><ul>
<li>对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待分组到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区</li>
</ul>
<h2 id="阻塞式I-O模型"><a href="#阻塞式I-O模型" class="headerlink" title="阻塞式I/O模型"></a>阻塞式I/O模型</h2><ul>
<li>默认情形下，所有套接字都是阻塞的。以数据报套接字（使用UDP而不是TCP作为例子的原因在于就UDP而言，数据准备好读取的概念比较简单：要么整个数据报已经收到，要么还没有）作为例子</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/unp/image-20221027001138791.png"></p>
<ul>
<li>进程调用recvfrom，其系统调用直到数据报到达且被复制到应用进程的缓冲区中或者发生错误才返回。最常见的错误是系统调用被信号中断。进程在从调用recvfrom开始到它返回的整段时间内是被阻塞的。recvfrom成功返回后，应用进程开始处理数据报</li>
</ul>
<h2 id="非阻塞式I-O模型"><a href="#非阻塞式I-O模型" class="headerlink" title="非阻塞式I/O模型"></a>非阻塞式I/O模型</h2><ul>
<li>进程把一个套接字设置成非阻塞是在通知内核：当所请求的IO操作非得把本进程投入睡眠才能完成时，不要把本进程投入睡眠，而是返回一个错误</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/unp/image-20221027001438316.png"></p>
<ul>
<li>前三次调用recvfrom时没有数据可返回，因此内核转而立即返回一个EWOULDBLOCK错误。第四次调用recvfrom时已有一个数据报准备好，它被复制到应用进程缓冲区，于是recvfrom成功返回</li>
<li>当一个应用进程像这样对一个非阻塞描述符循环调用recvfrom时，称之为轮询（polling）。应用进程持续轮询内核，以查看某个操作是否就绪，这么做往往耗费大量CPU时间</li>
</ul>
<h2 id="I-O复用模型"><a href="#I-O复用模型" class="headerlink" title="I/O复用模型"></a>I/O复用模型</h2><ul>
<li>可以调用select或poll，阻塞在这两个系统调用中的某一个之上，而不是阻塞在真正的IO系统调用上</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/unp/image-20221027001742157.png"></p>
<ul>
<li>阻塞于select调用，等待数据报套接字变为可读。当select返回套接字可读这一条件时，调用recvfrom把所读数据报复制到应用进程缓冲区。由于使用select需要两个而不是单个系统调用，使用select的优势在于可以等待多个描述符就绪</li>
</ul>
<h2 id="信号驱动式I-O模型"><a href="#信号驱动式I-O模型" class="headerlink" title="信号驱动式I/O模型"></a>信号驱动式I/O模型</h2><ul>
<li>可用用信号，让内核在描述符就绪时发送SIGIO信号通知到应用程序</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/unp/image-20221027002117473.png"></p>
<ul>
<li>首先开启套接字的信号驱动式IO功能，并通过sigaction系统调用安装一个信号处理函数。该系统调用将立即返回，进程继续工作，也就是说它没有被阻塞</li>
<li>当数据报准备好读取时，内核就为该进程产生一个SIGIO信号。随后既可以在信号处理函数中调用recvfrom读取数据报，并通知主循环数据已准备好待处理，也可以立即通知主循环，让它读取数据报。无论如何处理SIGIO信号，这种模型的优势在于等待数据报到达期间进程不被阻塞。主循环可以继续执行，只要等待来自信号处理函数的通知：既可以是数据已准备好被处理，也可以是数据报已准备好被读取</li>
</ul>
<h2 id="异步I-O模型"><a href="#异步I-O模型" class="headerlink" title="异步I/O模型"></a>异步I/O模型</h2><ul>
<li>工作机制：告知内核启动某个操作，并让内核在整个操作（包括将数据从内核复制到自己的缓冲区）完成后通知我们。这种模型与信号驱动模型的主要区别在于：信号驱动式IO是由内核通知我们何时可以启动一个I/O操作，而异步I/O模型是由内核通知我们I/O操作何时完成</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/unp/image-20221027002539032.png"></p>
<h2 id="各种I-O模型的比较"><a href="#各种I-O模型的比较" class="headerlink" title="各种I/O模型的比较"></a>各种I/O模型的比较</h2><p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/unp/image-20221027002729741.png"></p>
<ul>
<li>前4种模型的主要区别在于第一阶段，因为它们的第二阶段是一样的：在数据从内核复制到调用者的缓冲区期间，进程阻塞于recvfrom调用。相反，异步IO模型在这两个阶段都要处理，从而不同于其他4种模型</li>
<li>同步I/O操作（synchronous I/O operation）导致请求进程阻塞，直到IO操作完成</li>
<li>异步I/O操作（asynchronous I/O operation）不导致请求进程阻塞</li>
<li>前4种模型：阻塞式I/O模型、非阻塞式I/O模型、I/O复用模型和信号驱动式I/O模型都是同步IO模型，因为其中真正的I/O操作（recvfrom）将阻塞进程。只有异步I/O模型与POSIX定义的异步I/O相匹配</li>
</ul>
<h1 id="select函数"><a href="#select函数" class="headerlink" title="select函数"></a>select函数</h1><ul>
<li>该函数允许进程指示内核等待多个事件中的任何一个发生，并只在有一个或多个事件发生或经历一段指定的时间后才唤醒它</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class="line"><span class="params"><span class="function">    fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>timeout</li>
</ul>
<blockquote>
<p>（1）永远等待下去：仅在有一个描述符准备好I/O时才返回。把该参数设置为空指针</p>
<p>（2）等待一段固定时间：在有一个描述符准备I/O时返回，但是不超过由该参数所指向的timeval结构中指定的秒数和微秒数</p>
<p>（3）根本不等待：检查描述符后立即返回，称为轮询（poling）。该参数必须指向一个timeval结构，而且其中的定时器值（由该结构指定的秒数和微秒数）必须为0</p>
<p>前两种情形的等待通常会被进程在等待期间捕获的信号中断，并从信号处理函数返回</p>
</blockquote>
<ul>
<li>有些Linux版本会修改这个timeval结构，因此从移植性考虑，应该假设该timeval结构在select返回时未被定义，因而每次调用select之前都得对它进行初始化。POSIX规定对该结构使用const限定词</li>
<li>中间的三个参数readfds、writefds和exceptfds指定要让内核测试读、写和异常条件的描述符。目前支持的异常条件只有两个：</li>
</ul>
<blockquote>
<p>（1）某个套接字的带外数据的到达</p>
<p>（2）某个已置为分组模式的伪终端存在可从其主端读取的控制状态信息</p>
</blockquote>
<ul>
<li>select函数的中间三个参数中，如果对某一个的条件不感兴趣，就可以把它设为空指针。事实上，如果这三个指针均为空，就有了一个比Unix的sleep函数更为精确的定时器（sleep睡眠以秒为最小单位）。poll函数提供类似的功能，它的睡眠以微秒为单位</li>
<li>select函数修改由指针readfds、writefds和exceptfds所指向的的描述符集，因而这三个参数都是值一结果参数。调用该函数时，指定所关心的描述符的值，该函数返回时，结果将指示哪些描述符已就绪。该函数返回后，使用FD_ISSET宏来测试fa_set数据类型中的描述符。描述符集内任何与未就绪描述符对应的位返回时均清成0。为此，每次重新调用select函数时，都得再次把所有描述符集内所关心的位均置为1</li>
</ul>
<h2 id="描述符就绪条件"><a href="#描述符就绪条件" class="headerlink" title="描述符就绪条件"></a>描述符就绪条件</h2><p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/unp/image-20221028221143816.png"></p>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/unp/image-20221028221327894.png"></p>
<h1 id="str-cli函数（修订版）"><a href="#str-cli函数（修订版）" class="headerlink" title="str_cli函数（修订版）"></a>str_cli函数（修订版）</h1><ul>
<li>使用select重写上节中的str_cli函数，这样服务器进程一终止，客户就能马上得到通知。早先那个版本的问题在于：当套接字上发生某些事件时，客户可能阻塞于fgets调用。新版本改为阻塞于select调用，或是等待标准输入可读，或是等待套接字可读</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/unp/image-20221028222345112.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">str_cli</span><span class="params">(FILE *fp, <span class="keyword">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxfdp;</span><br><span class="line">    fd_set rset;</span><br><span class="line">    <span class="keyword">char</span> sendline[MAXLINE], recvline[MAXLINE];</span><br><span class="line"></span><br><span class="line">    FD_ZERO(&amp;rset);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        FD_SET(fileno(fp), &amp;rset);</span><br><span class="line">        FD_SET(sockfd, &amp;rset);</span><br><span class="line">        maxfdp = max(fileno(fp), sockfd) + <span class="number">1</span>;</span><br><span class="line">        Select(maxfdp, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(sockfd, &amp;rset)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Readline(sockfd, recvline, MAXLINE) == <span class="number">0</span>)</span><br><span class="line">                err_quit(<span class="string">&quot;str_cli: server terminated prematurely&quot;</span>);</span><br><span class="line"></span><br><span class="line">            Fputs(recvline, <span class="built_in">stdout</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(fileno(fp), &amp;rset)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Fgets(sendline, MAXLINE, fp) == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            Writen(sockfd, sendline, <span class="built_in">strlen</span>(sendline));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="shutdown函数"><a href="#shutdown函数" class="headerlink" title="shutdown函数"></a>shutdown函数</h1><ul>
<li>终止网络连接的通常方法是调用close函数。不过close有两个限制，却可以使用shutdowm来避免</li>
<li>（1）close把描述符的引用计数减1，仅在该计数变为0时才关闭套接字。使用shutdown可以不管引用计数就激发TCP的正常连接终止序列</li>
<li>（2）close终止读和写两个方向的数据传送。既然TCP连接是全双工的，有时候我们需要告知对端我们已经完成了数据发送，即使对端仍有数据要发送给我们</li>
<li>需要一种关闭TCP连接其中一半的方法。也就是说，想给服务器发送一个FIN，告诉它已经完成了数据发送，但是仍然保持套接字描述符打开以便读取</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/unp/image-20221028225815290.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> how)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>SHUT_RD：关闭连接的读这一半，套接字中不再有数据可接收，而且套接字接收缓冲区中的现有数据都被丢弃。进程不能再对这样的套接字调用任何读函数。对一个TCP套接字这样调用shutdown函数后，由该套接字接收的来自对端的任何数据都被确认，然后悄然丢弃</li>
<li>SHUT_WR：关闭连接的写这一半，对于TCP套接字，这称为半关闭。当前留在套接字发送缓冲区中的数据将被发送掉，后跟TCP的正常连接终止序列。不管套接字描述符的引用计数是否等于0，这样的写半部关闭照样执行。进程不能再对这样的套接字调用任何写函数</li>
<li>SHUT_RDWR：连接的读半部和写半部都关闭，这与调用shutdow两次等效：第一次调用指定SHUT_RD，第二次调用指定SHUT_WR</li>
</ul>
<h1 id="str-cli函数（再修订版）"><a href="#str-cli函数（再修订版）" class="headerlink" title="str_cli函数（再修订版）"></a>str_cli函数（再修订版）</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">str_cli</span><span class="params">(FILE *fp, <span class="keyword">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxfdp, stdineof;</span><br><span class="line">    fd_set rset;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    stdineof = <span class="number">0</span>;</span><br><span class="line">    FD_ZERO(&amp;rset);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stdineof == <span class="number">0</span>)</span><br><span class="line">            FD_SET(fileno(fp), &amp;rset);</span><br><span class="line">        FD_SET(sockfd, &amp;rset);</span><br><span class="line">        maxfdp = max(fileno(fp), sockfd) + <span class="number">1</span>;</span><br><span class="line">        Select(maxfdp, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(sockfd, &amp;rset)) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n = Read(sockfd, buf, MAXLINE)) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (stdineof == <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    err_quit(<span class="string">&quot;str_cli: server terminated prematurely&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Write(fileno(<span class="built_in">stdout</span>), buf, n);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(fileno(fp), &amp;rset)) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n = Read(fileno(fp), buf, MAXLINE)) == <span class="number">0</span>) &#123;</span><br><span class="line">                stdineof = <span class="number">1</span>;</span><br><span class="line">                Shutdown(sockfd, SHUT_WR);</span><br><span class="line">                FD_CLR(fileno(fp), &amp;rset);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Writen(sockfd, buf, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="TCP回射服务器程序（修订版）"><a href="#TCP回射服务器程序（修订版）" class="headerlink" title="TCP回射服务器程序（修订版）"></a>TCP回射服务器程序（修订版）</h1><ul>
<li> 上节TCP回射服务器程序，把它重写成使用select来处理任意个客户的单进程程序，而不是为每个客户派生一个子进程</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;unp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, maxi, maxfd, listenfd, connfd, sockfd;</span><br><span class="line">    <span class="keyword">int</span> nready, client[FD_SETSIZE];</span><br><span class="line">    <span class="keyword">ssize_t</span> n;</span><br><span class="line">    fd_set rset, allset;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="keyword">socklen_t</span> clilen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    listenfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">    Bind(listenfd, (SA *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">    Listen(listenfd, LISTENQ);</span><br><span class="line"></span><br><span class="line">    maxfd = listenfd;</span><br><span class="line">    maxi = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FD_SETSIZE; ++i)</span><br><span class="line">        client[i] = <span class="number">-1</span>;</span><br><span class="line">    FD_ZERO(&amp;allset);</span><br><span class="line">    FD_SET(listenfd, &amp;allset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        rset = allset;</span><br><span class="line">        nready = Select(maxfd + <span class="number">1</span>, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(listenfd, &amp;rset)) &#123;</span><br><span class="line">            clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">            connfd = Accept(listenfd, (SA *)&amp;cliaddr, &amp;clilen);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FD_SETSIZE; ++i)</span><br><span class="line">                <span class="keyword">if</span> (client[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    client[i] = connfd;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i == FD_SETSIZE)</span><br><span class="line">                err_quit(<span class="string">&quot;too many clients&quot;</span>);</span><br><span class="line"></span><br><span class="line">            FD_SET(connfd, &amp;allset);</span><br><span class="line">            <span class="keyword">if</span> (connfd &gt; maxfd)</span><br><span class="line">                maxfd = connfd;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &gt; maxi)</span><br><span class="line">                maxi = i;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= maxi; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((sockfd = client[i]) == <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (FD_ISSET(sockfd, &amp;rset)) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((n = Read(sockfd, buf, MAXLINE)) == <span class="number">0</span>) &#123;</span><br><span class="line">                    Close(sockfd);</span><br><span class="line">                    FD_CLR(sockfd, &amp;allset);</span><br><span class="line">                    client[i] = <span class="number">-1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    Writen(sockfd, buf, n);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="poll函数"><a href="#poll函数" class="headerlink" title="poll函数"></a>poll函数</h1><ul>
<li>poll函数提供的功能与select类似</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>   fd;         <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="keyword">short</span> events;     <span class="comment">/* requested events */</span></span><br><span class="line">    <span class="keyword">short</span> revents;    <span class="comment">/* returned events */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>要测试的条件由events成员指定，函数在相应的revents成员中返回该描述符的状态。（每个描述符都有两个变量，一个为调用值，另一个为返回结果，从而避免使用值-结果参数</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/unp/image-20221121231544644.png"></p>
<ul>
<li>如果不再关心某个特定描述符，那么可以把与它对应的pollfd结构的fd成员设置成一个负值。poll函数将忽略这样的pollfd结构的events成员，返回时将它的revents成员的值置为0</li>
<li>对于select，有FD_SETSIZE限制。有了poll就不再有那样的问题了，因为分配一个pollfd结构的数组并把该数组中元素的数目通知内核成了调用者的责任。内核不再需要知道类似fd_set的固定大小的数据类型</li>
</ul>
<h1 id="TCP回射服务器程序（再修订版）"><a href="#TCP回射服务器程序（再修订版）" class="headerlink" title="TCP回射服务器程序（再修订版）"></a>TCP回射服务器程序（再修订版）</h1><ul>
<li>用poll替代select重写TCP回射服务器程序。在使用select早先那个版本中，必须分配一个client数组以及一个名为rset的描述符集。改用poll后，只需分配一个pollfd结构的数组来维护客户信息，而不必分配另外一个数组。传递给poll的pollfd结构数组中的任何fd成员为负值的项都被poll忽略</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;unp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OPEN_MAX 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, maxi, listenfd, connfd, sockfd;</span><br><span class="line">    <span class="keyword">int</span> nready;</span><br><span class="line">    <span class="keyword">ssize_t</span> n;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="keyword">socklen_t</span> clilen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">client</span>[<span class="title">OPEN_MAX</span>];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    listenfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">    Bind(listenfd, (SA *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">    Listen(listenfd, LISTENQ);</span><br><span class="line"></span><br><span class="line">    client[<span class="number">0</span>].fd = listenfd;</span><br><span class="line">    client[<span class="number">0</span>].events = POLLRDNORM;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; OPEN_MAX; ++i)</span><br><span class="line">        client[i].fd = <span class="number">-1</span>;</span><br><span class="line">    maxi = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        nready = Poll(client, maxi + <span class="number">1</span>, INT_MAX);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (client[<span class="number">0</span>].revents &amp; POLLRDNORM) &#123;</span><br><span class="line">            clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">            connfd = Accept(listenfd, (SA *)&amp;cliaddr, &amp;clilen);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; OPEN_MAX; ++i)</span><br><span class="line">                <span class="keyword">if</span> (client[i].fd == <span class="number">-1</span>) &#123;</span><br><span class="line">                    client[i].fd = connfd;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i == OPEN_MAX)</span><br><span class="line">                err_quit(<span class="string">&quot;too many clients&quot;</span>);</span><br><span class="line"></span><br><span class="line">            client[i].events = POLLRDNORM;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; maxi)</span><br><span class="line">                maxi = i;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= maxi; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((sockfd = client[i].fd) == <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (client[i].revents &amp; (POLLRDNORM | POLLERR)) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((n = read(sockfd, buf, MAXLINE)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (errno == ECONNRESET) &#123;</span><br><span class="line">                        Close(sockfd);</span><br><span class="line">                        client[i].fd = <span class="number">-1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span></span><br><span class="line">                        err_sys(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">                    Close(sockfd);</span><br><span class="line">                    client[i].fd = <span class="number">-1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    Writen(sockfd, buf, n);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UNIX网络编程</category>
      </categories>
      <tags>
        <tag>UNIX网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Chap07_套接字选项</title>
    <url>/2022/05/18/UNP/Chap07_%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%89%E9%A1%B9/</url>
    <content><![CDATA[<h1 id="getsockopt和setsockopt函数"><a href="#getsockopt和setsockopt函数" class="headerlink" title="getsockopt和setsockopt函数"></a>getsockopt和setsockopt函数</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> *optlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> optlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/unp/image-20221127222803332.png"></p>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/unp/image-20221127222832704.png"></p>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/unp/image-20221127222908577.png"></p>
<h1 id="通用套接字选项"><a href="#通用套接字选项" class="headerlink" title="通用套接字选项"></a>通用套接字选项</h1><h2 id="SO-BROADCAST"><a href="#SO-BROADCAST" class="headerlink" title="SO_BROADCAST"></a>SO_BROADCAST</h2><ul>
<li>开启或禁止进程发送广播消息的能力。只有数据报套接字支持广播，并且还必须是在支持广播消息的网络上（例如以太网、令牌环网等）。不可能在点对点链路上进行广播，也不可能在基于连接的传输协议（例如TCP和SCTP）之上进行广播</li>
<li>由于应用进程在发送广播数据报之前必须设置本套接字选项，因此它能够有效地防止一个进程在其应用程序根本没有设计成可广播时就发送广播数据报</li>
</ul>
<h2 id="SO-ERROR"><a href="#SO-ERROR" class="headerlink" title="SO_ERROR"></a>SO_ERROR</h2><ul>
<li>当一个套接字上发生错误时，源自Berkeley的内核中的协议模块将该套接字的名为so_error的变量设为标准的Unix Ecxx值中的一个，称它为该套接字的待处理错误（pending error）。内核能够以下面两种方式之一立即通知进程这个错误</li>
<li>（1）如果进程阻塞在对该套接字的select调用上，那么无论是检查可读条件还是可写条件，select均返回并设置其中一个或所有两个条件</li>
<li>（2）如果进程使用信号驱动式IO模型，那就给进程或进程组产生一个SIGIO信号</li>
<li>进程然后可以通过访问SO_ERROR套接字选项获取so_error的值。由getsockopt返回的整数值就是该套接字的待处理错误。so_error随后由内核复位为0</li>
</ul>
<h2 id="SO-LINGER"><a href="#SO-LINGER" class="headerlink" title="SO_LINGER"></a>SO_LINGER</h2><ul>
<li>指定close函数对面向连接的协议（例如TCP和SCTP，但不是UDP）如何操作。默认操作是close立即返回，但是如果有数据残留在套接字发送缓冲区中，系统将试着把这些数据发送给对端</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/unp/image-20221130000659384.png"></p>
<h2 id="SO-RCVBUF-amp-SO-SNDBUF"><a href="#SO-RCVBUF-amp-SO-SNDBUF" class="headerlink" title="SO_RCVBUF &amp; SO_SNDBUF"></a>SO_RCVBUF &amp; SO_SNDBUF</h2><ul>
<li>接收缓冲区被TCP、UDP和SCTP用来保存接收到的数据，直到由应用进程来读取。对于TCP来说，套接字接收缓冲区中可用空间的大小限定了TCP通告对端的窗口大小。TCP套接字接收缓冲区不可能溢出，因为不允许对端发出超过本端所通告窗口大小的数据。这就是TCP的流量控制，如果对端无视窗口大小而发出了超过该窗口大小的数据，本端TCP将丢弃它们</li>
<li>然而对于UDP来说，当接收到的数据报装不进套接字接收缓冲区时，该数据报就被丢弃。UDP是没有流量控制的：较快的发送端可以很容易地淹没较慢的接收端，导致接收端的UDP丢弃数据报。事实上较快的发送端甚至可以淹没本机的网络接口，导致数据报被本机丢弃</li>
<li>对于不同的实现，默认值的大小可以有很大的差别。较早期的源自Berkeley的实现将TCP发送和接收缓冲区的大小均默认为4096字节，而较新的系统使用较大的值，可以是8192～61440字节间的任何值。如果主机支持NFS，那么UDP发送缓冲区的大小经常默认为9000字节左右的一个值，而UDP接收缓冲区的大小则经常默认为40 000字节左右的一个值</li>
<li>当设置TCP套接字接收缓冲区的大小时，函数调用的顺序很重要。这是因为TCP的窗口规模选项是在建立连接时用SYN分节与对端互换得到的。对于客户，这意味着SO_RCVBUF选项必须在调用connect之前设置；对于服务器，这意味着该选项必须在调用listen之前给监听套接字设置。给已连接套接字设置该选项对于可能存在的窗口规模选项没有任何影响，因为accept直到TCP的三路握手完成才会创建并返回已连接套接字。这就是必须给监听套接字设置本选项的原因。（套接字缓冲区的大小总是由新创建的已连接套接字从监听套接字继承而来）</li>
</ul>
<h2 id="SO-REUSEADDR-amp-SO-REUSEPORT"><a href="#SO-REUSEADDR-amp-SO-REUSEPORT" class="headerlink" title="SO_REUSEADDR &amp; SO_REUSEPORT"></a>SO_REUSEADDR &amp; SO_REUSEPORT</h2><ul>
<li>SO_REUSEADDR允许启动一个监听服务器并捆绑其众所周知端口，即使以前建立的将该端口用作它们的本地端口的连接仍存在</li>
<li>SO_REUSEADDR允许在同一端口上启动同一服务器的多个实例，只要每个实例捆绑一个不同的本地IP地址即可</li>
<li>SO_REUSEADDR允许单个进程捆绑同一端口到多个套接字上，只要每次捆绑指定不同的本地IP地址即可</li>
<li>SO_REUSEADDR允许完全重复的捆绑：当一个IP地址和端口已绑定到某个套接字上时，如果传输协议支持，同样的IP地址和端口还可以捆绑到另一个套接字上</li>
</ul>
<h1 id="TCP套接字选项"><a href="#TCP套接字选项" class="headerlink" title="TCP套接字选项"></a>TCP套接字选项</h1><h2 id="TCP-NODELAY"><a href="#TCP-NODELAY" class="headerlink" title="TCP_NODELAY"></a>TCP_NODELAY</h2><p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/unp/image-20221130002607791.png"></p>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/unp/image-20221130002857895.png"></p>
<h1 id="fcntl函数"><a href="#fcntl函数" class="headerlink" title="fcntl函数"></a>fcntl函数</h1><p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/unp/image-20221130003234418.png"></p>
]]></content>
      <categories>
        <category>UNIX网络编程</category>
      </categories>
      <tags>
        <tag>UNIX网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Chap08_基本UDP套接字编程</title>
    <url>/2022/05/18/UNP/Chap08_%E5%9F%BA%E6%9C%ACUDP%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li>UDP客户/服务器程序的函数调用。客户不与服务器建立连接，而是只管使用sendto函数给服务器发送数据报，其中必须指定目的地（即服务器）的地址作为参数。类似地，服务器不接受来自客户的连接，而是只管调用recvfrom函数，等待来自某个客户的数据到达。recvfrom将与所接收的数据报一道返回客户的协议地址，因此服务器可以把响应发送给正确的客户</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/unp/image-20221130214755540.png"></p>
<h1 id="recvfrom和sendto函数"><a href="#recvfrom和sendto函数" class="headerlink" title="recvfrom和sendto函数"></a>recvfrom和sendto函数</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">    struct sockaddr *src_addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> struct sockaddr *dest_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>recvfrom的最后两个参数类似于accept的最后两个参数：返回时其中套接字地址结构的内容告诉我们是谁发送了数据报（UDP情况下）或是谁发起了连接（TCP情况下）。sendto的最后两个参数类似于connect的最后两个参数：调用时其中套接字地址结构被我们填入数据报将发往（UDP情况下）或与之建立连接（TCP情况下）的协议地址</li>
<li>写一个长度为0的数据报是可行的。在UDP情况下，这会形成一个只包含一个IP首部（对于IPv4通常为20个字节，对于IPv6通常为40个字节）和一个8字节UDP首部而没有数据的IP数据报。这也意味着对于数据报协议，recvfrom返回0值是可接受的：它并不像TCP套接字上read返回0值那样表示对端已关闭连接。既然UDP是无连接的，因此也就没有诸如关闭一个UDP连接之类事情</li>
<li>如果recvfrom的src_addr参数是一个空指针，那么相应的长度参数（addrlen）也必须是一个空指针，表示我们并不关心数据发送者的协议地址。recvfrom和sendto都可以用于TCP，尽管通常没有理由这样做</li>
</ul>
<h1 id="UDP回射服务器程序：main函数"><a href="#UDP回射服务器程序：main函数" class="headerlink" title="UDP回射服务器程序：main函数"></a>UDP回射服务器程序：main函数</h1><p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/unp/image-20221204105114474.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;unp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    sockfd = Socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">    Bind(sockfd, (SA *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">    dg_echo(sockfd, (SA *)&amp;cliaddr, <span class="keyword">sizeof</span>(cliaddr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="UDP回射服务器程序：dg-echo函数"><a href="#UDP回射服务器程序：dg-echo函数" class="headerlink" title="UDP回射服务器程序：dg_echo函数"></a>UDP回射服务器程序：dg_echo函数</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;unp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dg_echo</span><span class="params">(<span class="keyword">int</span> sockfd, SA *pcliaddr, <span class="keyword">socklen_t</span> clilen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">socklen_t</span> len;</span><br><span class="line">    <span class="keyword">char</span> mesg[MAXLINE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        len = clilen;</span><br><span class="line">        n = Recvfrom(sockfd, mesg, MAXLINE, <span class="number">0</span>, pcliaddr, &amp;len);</span><br><span class="line"></span><br><span class="line">        Sendto(sockfd, mesg, n, <span class="number">0</span>, pcliaddr, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先，该函数永不终止，因为UDP是一个无连接的协议，它没有像TCP中EOF之类的东西。其次，该函数提供的是一个选代服务器（iterative server），而不是像TCP服务器那样可以提供一个并发服务器。其中没有对fork的调用，因此单个服务器进程就得处理所有客户。一般来说，大多数TCP服务器是并发的，而大多数UDP服务器是选代的</li>
<li>对于本套接字，UDP层中隐含有排队发生。事实上每个UDP套接字都有一个接收缓冲区，到达该套接字的每个数据报都进入这个套接字接收缓冲区。当进程调用recvfrom时，缓冲区中的下一个数据报以FIFO（先入先出）顺序返回给进程。这样，在进程能够读该套接字中任何已排好队的数据报之前，如果有多个数据报到达该套接字，那么相继到达的数据报仅仅加到该套接字的接收缓冲区中。然而这个缓冲区的大小是有限的。可以通过SO_RCVBUF套接字选项进行修改</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/unp/image-20221204113429315.png"></p>
<h1 id="UDP回射客户程序：main函数"><a href="#UDP回射客户程序：main函数" class="headerlink" title="UDP回射客户程序：main函数"></a>UDP回射客户程序：main函数</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;unp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">        err_quit(<span class="string">&quot;usage: udpcli &lt;IPaddress&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">    Inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;servaddr.sin_addr);</span><br><span class="line"></span><br><span class="line">    sockfd = Socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    dg_cli(<span class="built_in">stdin</span>, sockfd, (SA *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="UDP回射客户程序：dg-cli函数"><a href="#UDP回射客户程序：dg-cli函数" class="headerlink" title="UDP回射客户程序：dg_cli函数"></a>UDP回射客户程序：dg_cli函数</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;unp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dg_cli</span><span class="params">(FILE *fp, <span class="keyword">int</span> sockfd, <span class="keyword">const</span> SA *pservaddr, <span class="keyword">socklen_t</span> servlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> sendline[MAXLINE], recvline[MAXLINE + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (Fgets(sendline, MAXLINE, fp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Sendto(sockfd, sendline, <span class="built_in">strlen</span>(sendline), <span class="number">0</span>, pservaddr, servlen);</span><br><span class="line"></span><br><span class="line">        n = Recvfrom(sockfd, recvline, MAXLINE, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        recvline[n] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Fputs(recvline, <span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="数据报的丢失"><a href="#数据报的丢失" class="headerlink" title="数据报的丢失"></a>数据报的丢失</h1><ul>
<li>UDP客户/服务器例子是不可靠的。如果一个客户数据报丢失（警如说，被客户主机与服务器主机之间的某个路由器丢弃），客户将永远阻塞于dg_cli函数中的recvfrom调用，等待一个永远不会到达的服务器应答。类似地，如果客户数据报到达服务器，但是服务器的应答丢失了，客户也将永远阻塞于recvfrom调用。防止这样永久阻塞的一般方法是给客户的recvfrom调用设置一个超时</li>
</ul>
<h1 id="验证接收到的响应"><a href="#验证接收到的响应" class="headerlink" title="验证接收到的响应"></a>验证接收到的响应</h1><ul>
<li>知道客户临时端口号的任何进程都可往客户发送数据报，而且这些数据报会与正常的服务器应答混杂。解决办法是修改recvfrom调用以返回数据报发送者的I地址和端口号，保留来自数据报所发往服务器的应答，而忽略任何其他数据报</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dg_cli</span><span class="params">(FILE *fp, <span class="keyword">int</span> sockfd, <span class="keyword">const</span> SA *pservaddr, <span class="keyword">socklen_t</span> servlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">char</span> sendline[MAXLINE], recvline[MAXLINE + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">socklen_t</span> len = servlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *<span class="title">preply_addr</span>;</span></span><br><span class="line">    preply_addr = Malloc(servlen);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (Fgets(sendline, MAXLINE, fp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Sendto(sockfd, sendline, <span class="built_in">strlen</span>(sendline), <span class="number">0</span>, pservaddr, servlen);</span><br><span class="line"></span><br><span class="line">        n = Recvfrom(sockfd, recvline, MAXLINE, <span class="number">0</span>, preply_addr, &amp;len);</span><br><span class="line">        <span class="keyword">if</span> (len != servlen || <span class="built_in">memcmp</span>(pservaddr, preply_addr, len) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *<span class="title">sin</span> =</span> (struct sockaddr_in *)preply_addr;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;reply from %s ignored\n&quot;</span>, Inet_ntop(AF_INET, &amp;<span class="built_in">sin</span>-&gt;sin_addr, str, len));</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        recvline[n] = <span class="number">0</span>;</span><br><span class="line">        Fputs(recvline, <span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="服务器进程未运行"><a href="#服务器进程未运行" class="headerlink" title="服务器进程未运行"></a>服务器进程未运行</h1><ul>
<li>当服务器进程未运行时，客户端向服务器进程发送UDP数据报时，服务器主机响应的是一个“port  unreachable”（端口不可达）ICMP消息。不过这个ICMP错误不返回给客户进程</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/unp/image-20221213234006041.png"></p>
<ul>
<li>这个ICMP错误为异步错误（asynchronous error）。该错误由sendto引起，但是sendto本身却成功返回。从UDP输出操作成功返回仅仅表示在接口输出队列中具有存放所形成IP数据报的空间。该ICMP错误直到后来才返回，这就是称其为异步的原因</li>
<li>一个基本规则是：对于一个UDP套接字，由它引发的异步错误却并不返回给它，除非它已连接</li>
</ul>
<h1 id="UDP的connect函数"><a href="#UDP的connect函数" class="headerlink" title="UDP的connect函数"></a>UDP的connect函数</h1><ul>
<li>上述提到除非套接字已连接，否则异步错误是不会返回到UDP套接字的。确实可以给UDP套接字调用connect，然而这样做的结果却与TCP连接大相径庭：没有三路握手过程。内核只是检查是否存在立即可知的错误（例如一个显然不可达的目的地），记录对端的IP地址和端口号（取自传递给connect的套接字地址结构），然后立即返回到调用进程</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/unp/image-20221213235029403.png"></p>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/unp/image-20221213235056823.png"></p>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/unp/image-20221213235142233.png"></p>
<ul>
<li>UDP客户进程或服务器进程只在使用自己的UDP套接字与确定的唯一对端进行通信时，才可以调用connect。调用connect的通常是UDP客户，不过有些网络应用中的UDP服务器会与单个客户长时间通信（如TFTP），这种情况下，客户和服务器都可能调用connect</li>
</ul>
<h2 id="给一个UDP套接字多次调用connect"><a href="#给一个UDP套接字多次调用connect" class="headerlink" title="给一个UDP套接字多次调用connect"></a>给一个UDP套接字多次调用connect</h2><ul>
<li>拥有一个已连接UDP套接字的进程可出于下列两个目的之一再次调用conneet：1）指定新的IP地址和端口号；2）断开套接字</li>
<li>第一个目的（即给一个已连接UDP套接字指定新的对端）不同于TCP套接字中connect的使用：对于TCP套接字，connect只能调用一次</li>
<li>为了断开一个已UDP套接字连接，再次调用connect时把套接字地址结构的地址族成员设置为AF_UNSPEC。这么做可能会返回一个EAFNOSUPPORT错误，不过没有关系</li>
</ul>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/unp/image-20221213235918743.png"></p>
]]></content>
      <categories>
        <category>UNIX网络编程</category>
      </categories>
      <tags>
        <tag>UNIX网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+Github搭建个人博客</title>
    <url>/2022/02/02/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h1><ul>
<li>Hexo需要Node.js支持</li>
<li>Node.js下载地址：<a href="https://nodejs.org/en/">nodejs.org</a></li>
<li>安装完以后会有两个组件，Node.js + npm包管理器</li>
</ul>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">node</span> <span class="title">-v</span></span><br><span class="line">v16.<span class="number">13.1</span></span><br><span class="line"></span><br><span class="line">$ npm -v</span><br><span class="line"><span class="number">8.1</span>.<span class="number">2</span></span><br></pre></td></tr></table></figure>

<h1 id="安装cnpm，淘宝镜像源"><a href="#安装cnpm，淘宝镜像源" class="headerlink" title="安装cnpm，淘宝镜像源"></a>安装cnpm，淘宝镜像源</h1><ul>
<li>借助npm安装Hexo博客框架，但由于国内镜像源速度慢，可以利用npm安装一个cnpm，淘宝的源</li>
</ul>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">$ npm install -g cnpm --registry=https:<span class="regexp">//</span>registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/blog/image-20220105234517559.png"></p>
<h1 id="使用cnpm安装Hexo博客"><a href="#使用cnpm安装Hexo博客" class="headerlink" title="使用cnpm安装Hexo博客"></a>使用cnpm安装Hexo博客</h1><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">$ cnpm install -g hexo-<span class="keyword">cli</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/blog/image-20220105235001374.png"></p>
<h1 id="使用Hexo搭建博客"><a href="#使用Hexo搭建博客" class="headerlink" title="使用Hexo搭建博客"></a>使用Hexo搭建博客</h1><ul>
<li>创建博客目录</li>
<li>初始化博客</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">$ hexo <span class="keyword">init</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/blog/image-20220105235806763.png"></p>
<ul>
<li>启动博客</li>
</ul>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>hexo s</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/blog/image-20220105235937501.png"></p>
<ul>
<li>浏览器访问<a href="http://localhost:4000/">http://localhost:4000/</a></li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/blog/image-20220106000154817.png"></p>
<ul>
<li>新建一篇博客，并编辑</li>
</ul>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>hexo n <span class="string">&quot;My First Blog&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/blog/image-20220106000542115.png"></p>
<ul>
<li>清理，重新生成，并启动博客</li>
</ul>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>hexo clean</span><br><span class="line"><span class="variable">$ </span>hexo g</span><br><span class="line"><span class="variable">$ </span>hexo s</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/blog/image-20220106001429254.png"></p>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/blog/image-20220106001505606.png"></p>
<h1 id="将博客部署到远端，比如GitHub"><a href="#将博客部署到远端，比如GitHub" class="headerlink" title="将博客部署到远端，比如GitHub"></a>将博客部署到远端，比如GitHub</h1><ul>
<li>创建一个新的仓库，注意：仓库名必须为GitHub用户名+github.io</li>
<li>使用cnpm安装git部署插件</li>
</ul>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">$ cnpm install <span class="comment">--save hexo-deployer-git</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/blog/image-20220106002928759.png"></p>
<ul>
<li>修改博客目录下的_config.yml</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/blog/image-20220117230537645.png"></p>
<ul>
<li>部署到远端</li>
</ul>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>hexo d</span><br></pre></td></tr></table></figure>

<ul>
<li>会提示你输入GitHub用户名和密码，但是重点来了，这里试了好几次，明明用户名和密码都正确，就是部署不上去，提示Authentication failed &amp; Error: Spawn failed</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/blog/image-20220117230617045.png"></p>
<ul>
<li>不知道是不是HTTPS的问题，不过以前也确实没用过HTTPS的方式，又尝试了SSH的方式，修改如下，注意如果以前没有在GitHub上添加过SSH Keys的话需要添加下，参考链接：<a href="https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent">Generating a new SSH key and adding it to the ssh-agent</a></li>
<li>重新修改_config.yml如下</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/blog/image-20220117231656787.png"></p>
<ul>
<li>重新部署成功</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/blog/image-20220117231858319.png"></p>
<ul>
<li>将仓库地址复制到浏览器中打开，就可以正常打开个人博客</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/blog/image-20220117232211582.png"></p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Chap01_计算机网络和因特网</title>
    <url>/2022/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Chap01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220723232932841.png"></p>
<h1 id="什么是因特网"><a href="#什么是因特网" class="headerlink" title="什么是因特网"></a>什么是因特网</h1><h2 id="具体构成描述"><a href="#具体构成描述" class="headerlink" title="具体构成描述"></a>具体构成描述</h2><ul>
<li>所有传统的设备（桌面PC、Linux工作站以及所谓的服务器等），和非传统设备（便携机、智能手机、平板电脑等）都称主机（host）或端系统（end system）</li>
<li>端系统通过通信链路（communication link）和分组交换机（packet switch）连接在一起</li>
<li>当一台端系统要向另一台端系统发送数据时，发送端系统将数据分段，并为每段加上首部字节。由此形成的信息包用计算机网络的术语来说称为分组（packet）</li>
<li>分组交换机的两种最主要类型：路由器（router）和链路层交换机（link-layer switch），链路层交换机通常用于接入网中，而路由器常用于网络核心中</li>
<li>从发送端系统到接收端系统，一个分组所经历的一系列通信链路和分组交换机称为通过该网络的路径（route或path）</li>
</ul>
<h2 id="服务描述"><a href="#服务描述" class="headerlink" title="服务描述"></a>服务描述</h2><ul>
<li>与因特网相连的端系统提供了一个套接字接口（socket interface），该接口规定了运行在一个端系统上的程序请求因特网基础设施向运行在另一个端系统上的特定目的程序交付数据的方式</li>
</ul>
<h2 id="什么是协议"><a href="#什么是协议" class="headerlink" title="什么是协议"></a>什么是协议</h2><ul>
<li>协议（protocol）定义了在两个或多个通信实体之间交换的报文的格式和顺序，以及报文发送和/或接收一条报文或其他事件所采取的的动作</li>
<li>在两台物理连接的计算机中，硬件实现的协议控制了在两块网络接口卡的“线上”的比特流；在端系统中，拥塞控制协议控制了在发送方和接收方之间传输的分组发送的速率；路由器中的协议决定了分组从源到目的地的路径</li>
</ul>
<h1 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h1><h2 id="接入网"><a href="#接入网" class="headerlink" title="接入网"></a>接入网</h2><ul>
<li>接入网：指将端系统物理连接到其边缘路由器（edge router）的网络，边缘路由器是端系统到任何其它远程端系统的路径上的第一台路由器</li>
<li>家庭接入：DSL、电缆、FTTH、拨号和卫星</li>
<li>宽带住宅接入有两种最流行的类型：数字用户线（Digital Subscriber Line，DSL）和电缆。住户通常从提供本地电话接入的本地电话公司处获得DSL因特网接入。因此，当使用DSL时，用户的本地电话公司也是它的ISP。每个用户的DSL调制解调器使用现有的电话线与位于电话公司的本地中心局（CO）中的数字用户线接入复用器（DSLAM）交换数据</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220616232311968.png"></p>
<ul>
<li>DSL利用电话公司现有的本地电话基础设施，而电缆因特网接入（cable Internet access）利用了有线电视公司现有的有限电视基础设施。住宅从提供有线电视的公司获得了电缆因特网接入</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220616232627053.png"></p>
<ul>
<li>光纤到户（Fiber To The Home，FTTH），从本地中心局直接到家庭提供了一条光纤路径</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220616233020297.png"></p>
<ul>
<li>企业（和家庭）接入：以太网和WiFi</li>
<li>广域无线接入：3G和LTE</li>
</ul>
<h2 id="物理媒体"><a href="#物理媒体" class="headerlink" title="物理媒体"></a>物理媒体</h2><ul>
<li>对于每个发射器 - 接收器对，通过跨越一种物理媒体传播电磁波或光脉冲来发送比特数据</li>
<li>常见的物理媒体：双绞铜线、同轴电缆、光纤、陆地无线电信道、卫星无线电信道</li>
</ul>
<h1 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h1><h2 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h2><ul>
<li>在各种网络应用中，端系统彼此交换报文（message）。报文能够包含协议设计者需要的任何东西，可以执行一种控制功能，也可以包含数据。为了从源端系统向目的端系统发送一个报文，源将报文划分为较小的数据块，称之为分组（packet）。在源和目的地之间，每个分组都通过通信链路和分组交换机（packet switch）传送。（交换机主要有两类：路由器（router）和链路层交换机（link-layer switch）。）</li>
<li>存储转发传输：多数存储交换机在链路的输入端使用存储转发传输（store-and-forward transmission）机制。存储转发传输是指在交换机能够开始向输出链路传输该分组的第一个比特之前，必须收到整个分组</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220619211857314.png"></p>
<ul>
<li><p>排队时延和分组丢失：每台分组交换机有多条链路与之相连。对于每条相连的链路，该分组交换机具有一个输出缓存（output buffer，也称为输出队列（output queue）），它用于存储路由器准备发往那条链路的分组。该输出缓存在分组交换中起着重要的作用。如果到达的分组需要传输到某条链路，但发现该链路正忙于传输其他分组，该到达分组必须在输出缓存中等待。因此，除了存储转发时延以外，分组还要承受输出缓存的排队时延（queuing delay）。这些时延是变化的，变化的程度取决于网络的拥塞程度。因为缓存空间的大小是有限的，一个到达的分组可能发现该缓存已被其他等待传输的分组完全充满了。在此情况下，将出现分组丢失（丢包）（packet loss），到达的分组或已经排队的分组之一将被丢弃</p>
</li>
<li><p>转发表：在因特网中，每个端系统具有一个称为IP地址的地址。当源主机要向目的端系统发送一个分组时，源在该分组的首部包含了目的地的IP地址。如同邮政地址那样，该地址具有一种等级结构。当一个分组到达网络中的路由器时，路由器检查该分组的目的地址的一部分，并向一台相邻路由器转发该分组。更特别的是，每台路由器具有一个转发表（forwarding table），用于将目的地址（或目的地址的一部分）映射成为输出链路。当某分组到达一台路由器时，路由器检查该地址，并用这个目的地址搜索其转发表，以发现适当的出链路，路由器则将分组导向该出链路</p>
</li>
<li><p>路由选择协议（routing protocol），用于自动地设置这些转发表。一个路由选择协议可以决定从每台路由器到每个目的地址的最短路径，并使用这些最短路径来配置路由器中的转发表</p>
</li>
</ul>
<h2 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h2><ul>
<li>通过网络链路和交换机移动数据有两种基本方法：电路交换（circuit switching）和分组交换（packet switching）</li>
<li>在电路交换网络中，在端系统间通信会话期间，预留了端系统沿路径通信所需要的资源（缓存，链路传输速率）。在分组交换中，这些资源则不是预留的，会话的报文按需使用这些资源，其后果可能是不得不等待（即排队）接入通信链路</li>
<li>链路中的电路是通过频分复用或时分复用来实现</li>
</ul>
<h2 id="网络的网络"><a href="#网络的网络" class="headerlink" title="网络的网络"></a>网络的网络</h2><p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220712235442973.png"></p>
<h1 id="分组交换网络中的时延、丢包和吞吐量"><a href="#分组交换网络中的时延、丢包和吞吐量" class="headerlink" title="分组交换网络中的时延、丢包和吞吐量"></a>分组交换网络中的时延、丢包和吞吐量</h1><h2 id="分组交换网中的时延概述"><a href="#分组交换网中的时延概述" class="headerlink" title="分组交换网中的时延概述"></a>分组交换网中的时延概述</h2><ul>
<li>当一个分组从一个节点（主机或路由器）沿着这条路径到后继节点（主机或路由器），该分组在沿途的每个节点经受了几种不同的时延。这些时延最为重要的是节点处理时延、排队时延、传输时延和传播时延</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220723010027829.png"></p>
<ul>
<li>作为源和目的地之间的端到端路由的一部分，一个分组从上游节点通过路由器A向路由器B发送。我们的目标是在路由器A刻画出节点时延。值得注意的是，路由器A具有通往路由器B的出链路。该链路前面有一个队列（也称为缓存）。当分组从上游节点到达路由器A时，路由器A检查该分组的首部以决定它的适当出链路，并将该分组导向该链路。在这个例子传播中，对该分组的出链路是通向路由器B的那条链路。仅当在该链路没有其他分组正在传输并且没有其他分组排在该队列前面时，才能在这条链路上传输该分组；如果该链路当前正繁忙或有其他分组已经在该链路上排队，则新到达的分组将加入排队</li>
<li>处理时延：检查分组首部和决定将该分组导向何处所需要的时间是处理时延的一部分。处理时延也能够包括其他因素，如检查比特级别的差错所需要的时间，该差错出现在从上游节点向路由器A传输这些分组比特的过程中。高速路由器的处理时延通常是微秒或更低的数量级。在这种节点处理之后，路由器将该分组引向通往路由器B链路之前的队列</li>
<li>排队时延：在队列中，当分组在链路上等待传输时，它经受排队时延。一个特定分组的排队时延长度将取决于先期到达的正在排队等待向链路传输的分组数量。如果该队列是空的，并且当前没有其他分组正在传输，则该分组的排队时延为0。另一方面，如果流量很大，并且许多其他分组也在等待传输，该排队时延将很长。我们将很快看到，到达分组期待发现的分组数量是到达该队列的流量的强度和性质的函数。实际的排队时延可以是毫秒到微秒量级</li>
<li>传输时延：假定分组以先到先服务方式传输，这在分组交换网中是常见的方式，仅当所有已经到达的分组被传输后，才能传输刚到达的分组。用L比特表示该分组的长度，用R bps（即b/s）表示从路由器A到路由器B的链路传输速率。例如，对于一条10Mbps的以太网链路，速率R=10Mbps；对于100Mbps的以太网链路，速率R=100Mbps。传输时延是L/R。这是将所有分组的比特推向链路（即传输，或者说发射）所需要的时间。实际的传输时延通常在毫秒到微秒量级</li>
<li>传播时延：一且一个比特被推向链路，该比特需要向路由器B传播。从该链路的起点到路由器B传播所需要的时间是传播时延。该比特以该链路的传播速率传播。该传播速率取决于该链路的物理媒体（即光纤、双绞铜线等），其速率范围等于或略小于光速。该传播时延等于两台路由器之间的距离除以传播速率。即传播时延是d/s，其中d是路由器A和路由器B之间的距离，s是该链路的传播速率。一且该分组的最后一个比特传播到节点B，该比特及前面的所有比特被存储于路由器B。整个过程将随着路由器B执行转发而持续下去。在广域网中，传播时延为毫秒量级</li>
<li>传输时延和传播时延的比较：传输时延是路由器推出分组所需要的时间，它是分组长度和链路传输速率的函数，而与两台路由器之间的距离无关。另一方面，传播时延是一个比特从一台路由器传播到另一台路由器所需要的时间，它是两台路由器之间距离的函数，而与分组长度或链路传输速率无关</li>
</ul>
<h2 id="排队时延和丢包"><a href="#排队时延和丢包" class="headerlink" title="排队时延和丢包"></a>排队时延和丢包</h2><ul>
<li>排队时延很大程度取决于流量到达该队列的速率、链路的传输速率和到达流量的性质，即流量是周期性到达还是以突发性到达</li>
<li>设计系统时流量强度不能大于1，随着流量强度接近1，平均排队时延迅速增加</li>
<li>丢包：因为排队容量是有限的，随着流量强度接近1，排队时延并不真正趋于无穷大。相反，到达的分组将发现一个满的队列。由于没有地方存储这个分组，路由器将丢弃该分组</li>
</ul>
<h2 id="端到端时延"><a href="#端到端时延" class="headerlink" title="端到端时延"></a>端到端时延</h2><ul>
<li>Traceroute：能够在因特网主机上运行。当用户指定一个目的主机名字时，源主机中的该程序朝着目的地发送多个特殊的分组。当这些分组向着目的地传送时，它们通过一系列路由器。当路由器接收到这些特殊分组之一时，它向源端回送一个短报文，该报文包括路由器的名字和地址</li>
</ul>
<h2 id="计算机网络中的吞吐量"><a href="#计算机网络中的吞吐量" class="headerlink" title="计算机网络中的吞吐量"></a>计算机网络中的吞吐量</h2><ul>
<li>考虑从主机A到主机B跨越计算机网络传送一个大文件。在任何时间瞬间的瞬时吞吐量是主机B接收到该文件的速率（以bps计）</li>
<li>如果该文件由F比特组成，主机B接收到所有F比特用去T秒，则文件传送的平均吞吐量是F/T bps</li>
</ul>
<h1 id="协议层次及其服务模型"><a href="#协议层次及其服务模型" class="headerlink" title="协议层次及其服务模型"></a>协议层次及其服务模型</h1><h2 id="分层的体系结构"><a href="#分层的体系结构" class="headerlink" title="分层的体系结构"></a>分层的体系结构</h2><ul>
<li>网络设计者以分层（layer）的方式组织协议以及实现这些协议的网络硬件和软件，每层通过在该层执行某些动作或使用下层的服务来提供服务。例如，由第n层提供的服务可能包括报文从网络一边到另一边的可靠交付，这可能是通过使用第n-1层的边缘到边缘的不可靠报文传送服务，加上第n层的检测重传丢失报文的功能来实现的</li>
<li>各层的所有协议被称为协议栈（protocol stack），因特网的协议栈由5个层次组成：物理层、链路层、网络层、传输层和应用层</li>
<li>应用层：应用层是网络应用程序及它们的应用层协议存留的地方。应用层协议分布在多个端系统上，而一个端系统的应用程序使用协议与另一个端系统中的应用程序交换信息分组。我们把这种位于应用层信息分组称为报文（message）</li>
<li>运输层：因特网的运输层在应用程序端点之间传送应用层报文。在因特网中，有两种运输协议，即TCP和UDP，利用其中的任一个都能运输应用层报文。TCP向它的应用程序提供了面向连接的服务。这种服务包括了应用层报文向目的地的确保传递和流量控制（即发送方/接收方速率匹配）。TCP也将长报文划分为短报文，并提供拥塞控制机制，因此当网络拥塞时，源抑制其传输速率。UDP协议向它的应用程序提供无连接服务。这是一种不提供不必要服务的服务，没有可靠性，没有流量控制，也没有拥塞控制。我们把运输层的分组称为报文段（segment）</li>
<li>网络层：因特网的网络层负责将称为数据报（datagram）的网络层分组从一台主机移动到另一台主机。在一台源主机中的因特网运输层协议（TCP或UDP）向网络层递交运输层报文段和目的地址。因特网的网络层包括著名的网际协议IP，该协议定义了在数据报中的各个字段以及端系统和路由器如何作用于这些字段。IP仅有一个，所有具有网络层的因特网组件必须运行IP。因特网的网络层也包括决定路由的路由选择协议，它根据该路由将数据报从源传输到目的地</li>
<li>链路层：因特网的网络层通过源和目的地之间的一系列路由器路由数据报。为了将分组从一个节点（主机或路由器）移动到路径上的下一个节点，网络层必须依靠该链路层的服务。特别是在每个节点，网络层将数据报下传给链路层，链路层沿着路径将数据报传递给下一个节点。在该下一个节点，链路层将数据报上传给网络层。由链路层提供的服务取决于应用于该链路的特定链路层协议。例如，某些协议基于链路提供可靠传递，从传输节点跨越一条链路到接收节点。值得注意的是，这种可靠的传递服务不同于TCP的可靠传递服务，TCP提供从一个端系统到另一个端系统的可靠交付。链路层的例子包括以太网、WiFi和电缆接入网的DOCSIS协议。因为数据报从源到目的地传送通常需要经过几条链路，一个数据报可能被沿途不同链路上的不同链路层协议处理。例如，一个数据报可能被一段链路上的以太网和下一段链路上的PPP所处理。网络层将受到来自每个不同的链路层协议的不同服务。我们把链路层分组称为顿（frame）</li>
<li>物理层：虽然链路层的任务是将整个帧从一个网络元素移动到邻近的网络元素，而物理层的任务是将该帧中的一个个比特从一个节点移动到下一个节点</li>
</ul>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220723232932840.png"></p>
<ul>
<li>在发送主机端，一个应用层报文（application-layer message）被传送给运输层。在最简单的情况下，运输层收取到报文并附上附加信息（所谓运输层首部信息），该首部将被接收端的运输层使用。应用层报文和运输层首部信息一道构成了运输层报文段（transport-layer segment）。运输层报文段因此封装了应用层报文。附加的信息也许包括了下列信息：允许接收端运输层向上向适当的应用程序交付报文的信息；差错检测位信息，该信息让接收方能够判断报文中的比特是否在途中已被改变。运输层则向网络层传递该报文段，网络层增加了如源和目的端系统地址等网络层首部信息，生成了网络层数据报（network-layer datagram）。该数据报接下来被传递给链路层，链路层（自然而然地）增加它自己的链路层首部信息并生成链路层顿（link-layer frame）。在每一层，一个分组具有两种类型的字段：首部字段和有效载荷字段（payload field）。有效载荷通常是来自上一层的分组</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Chap02_应用层</title>
    <url>/2022/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Chap02_%E5%BA%94%E7%94%A8%E5%B1%82/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220805220509153.png"></p>
<h1 id="应用层协议原理"><a href="#应用层协议原理" class="headerlink" title="应用层协议原理"></a>应用层协议原理</h1><h2 id="网络应用程序体系结构"><a href="#网络应用程序体系结构" class="headerlink" title="网络应用程序体系结构"></a>网络应用程序体系结构</h2><ul>
<li>应用程序体系结构：客户服务器（CS）体系结构或对等（P2P）体系结构</li>
<li>在一个P2P体系结构（P2P architecture）中，对位于数据中心的专用服务器有最小的（或者没有）依赖。相反，应用程序在间断连接的主机对之间使用直接通信，这些主机对被称为对等方</li>
</ul>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><ul>
<li>进程与计算机网络之间的接口</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220804231238194.png"></p>
<ul>
<li>图2-3显示了两个经过因特网通信的进程之间的套接字通信（图2-3中假定由该进程使用的下面运输层协议是因特网的TCP协议）。如该图所示，套接字是同一台主机内应用层与运输层之间的接口。由于该套接字是建立网络应用程序的可编程接口，因此套接字也称为应用程序和网络之间的应用程序编程接口（Application Programming Interface，API）。应用程序开发者可以控制套接字在应用层端的一切，但是对该套接字的运输层端几乎没有控制权。应用程序开发者对于运输层的控制仅限于：选择运输层协议；也许能设定几个运输层参数，如最大缓存和最大报文段长度等。一旦应用程序开发者选择了一个运输层协议（如果可供选择的话），则应用程序就建立在由该协议提供的运输层服务之上</li>
<li>进程寻址：在一台主机上运行的进程为了向在另一台主机上运行的进程发送分组，接收进程需要有一个地址。为了标识该接收进程，需要定义两种信息：主机的地址和在目的主机中指定接收进程的标识符。在因特网中，主机由其IP地址（IP address）标识。除了知道报文发送目的地的主机地址外，发送进程还必须指定运行在接收主机上的接收进程（更具体地说，接收套接字）。因为一般而言一台主机能够运行许多网络应用，这些信息是需要的。目的地端口号（port number）用于这个目的</li>
</ul>
<h2 id="可供应用程序使用的运输服务"><a href="#可供应用程序使用的运输服务" class="headerlink" title="可供应用程序使用的运输服务"></a>可供应用程序使用的运输服务</h2><ul>
<li>大体从四个方面对应用程序服务要求进行分类：可靠数据传输、吞吐量、定时和安全性</li>
<li>可靠数据传输：分组在计算机网络中可能丢失。例如，分组能够使路由器中的缓存溢出，或者当分组中的某些比特损坏后可能被丢弃。像电子邮件、文件传输、远程主机访问、Web文档传输以及金融应用等这样的应用，数据丢失可能会造成灾难性的后果。因此，为了支持这些应用，必须做一些工作以确保由应用程序的一端发送的数据正确、完全地交付给该应用程序的另一端。如果一个协议提供了这样的确保数据交付服务，就认为提供了可靠数据传输（reliable data transfer）。运输层协议能够潜在地向应用程序提供的一个重要服务是进程到进程的可靠数据传输。当一个运输协议提供这种服务时，发送进程只要将其数据传递进套接字，就可以完全相信该数据将能无差错地到达接收进程。当一个运输层协议不提供可靠数据传输时，由发送进程发送的某些数据可能到达不了接收进程。这可能能被容忍丢失的应用（loss-tolerant application）所接受，最值得注意的是多媒体应用，如交谈式音频/视频，它们能够承受一定量的数据丢失</li>
<li>吞吐量：运输层协议能够以某种特定的速率提供确保的可用吞吐量。具有吞吐量要求的应用程序被称为带宽敏感应用，如因特网电话应用程序、多媒体应用。而弹性应用能够根据当时可用的带宽或多或少地利用可供使用的吞吐量</li>
<li>定时：运输层协议也能提供定时保证。例如，发送方注人进套接字中的每个比特到达接收方的套接字不迟于100ms</li>
<li>安全性：运输协议能够为应用程序提供一种或多种安全性服务。例如，在发送主机中，运输协议能够加密由发送进程传输的所有数据，在接收主机中，运输层协议能够在将数据交付给接收进程之前解密这些数据</li>
</ul>
<h2 id="因特网提供的运输服务"><a href="#因特网提供的运输服务" class="headerlink" title="因特网提供的运输服务"></a>因特网提供的运输服务</h2><ul>
<li>因特网为应用程序提供了两个运输层协议：即UDP和TCP。每个协议为调用它们的应用程序提供了不同的服务集合</li>
<li>TCP服务：包括面向连接服务和可靠数据传输服务</li>
<li>面向连接的服务：在应用层数据报文开始流动之前，TCP让客户和服务器互相交换运输层控制信息。这个所谓的握手过程提醒客户和服务器，让它们为大量分组的到来做好准备。在握手阶段后，一个TCP连接（TCP connection）就在两个进程的套接字之间建立了。这条连接是全双工的，即连接双方的进程可以在此连接上同时进行报文收发。当应用程序结束报文发送时，必须拆除该连接</li>
<li>可靠的数据传送服务：通信进程能够依靠TCP，无差错、按适当顺序交付所有发送的数据。当应用程序的一端将字节流传进套接字时，它能够依靠TCP将相同的字节流交付给接收方的套接字，而没有字节的丢失和冗余</li>
<li>TCP协议还具有拥塞控制机制，这种服务不一定能为通信进程带来直接好处，但能为因特网带来整体好处。当发送方和接收方之间的网络出现拥塞时，TCP的拥塞控制机制会抑制发送进程（客户或服务器）。TCP拥塞控制也试图限制每个TCP连接，使它们达到公平共享网络带宽的目的</li>
<li>无论TCP还是UDP都没有提供任何加密机制，这就是说发送进程传进其套接字的数据，与经网络传送到目的进程的数据相同。因此，举例来说如果某发送进程以明文方式（即没有加密）发送了一个口令进入它的套接字，该明文口令将经过发送方与接收方之间的所有链路传送，这就可能在任何中间链路被唤探和发现。所以因特网界已经研制了TCP的加强版本，称为安全套接字层（Secure Sockets Layer，SSL）。用SSL加强后的TCP不仅能够做传统的TCP所能做的一切，而且提供了关键的进程到进程的安全性服务，包括加密、数据完整性和端点鉴别。SSL不是与TCP和UDP在相同层次上的第三种因特网运输协议，而是一种对TCP的加强，这种强化是在应用层上实现的</li>
<li>UDP服务：UDP是一种不提供不必要服务的轻量级运输协议，它仅提供最小服务。UDP是无连接的，因此在两个进程通信前没有握手过程。UDP协议提供一种不可靠数据传送服务，也就是说，当进程将一个报文发送进UDP套接字时，UDP协议并不保证该报文将到达接收进程。不仅如此，到达接收进程的报文也可能是乱序到达的</li>
<li>UDP没有包括拥塞控制机制，所以UDP的发送端可以用它选定的任何速率向其下层（网络层）注入数据。然而，值得注意的是实际端到端吞吐量可能小于该速率，这可能是因为中间链路的带宽受限或因为拥塞而造成的</li>
</ul>
<h2 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h2><ul>
<li>应用层协议（application-layer protocol）定义了运行在不同端系统上的应用程序进程如何相互传递报文。应用层协议定义了：交换的报文类型，例如请求报文和响应报文。各种报文类型的语法，如报文中的各个字段及这些字段是如何描述的。字段的语义，即这些字段中的信息的含义。确定一个进程何时以及如何发送报文，对报文进行响应的规则</li>
</ul>
<h1 id="Web和HTTP"><a href="#Web和HTTP" class="headerlink" title="Web和HTTP"></a>Web和HTTP</h1><h2 id="HTTP概况"><a href="#HTTP概况" class="headerlink" title="HTTP概况"></a>HTTP概况</h2><ul>
<li>Web的应用层协议是超文本传输协议（HyperText Transfer Protocol，HTTP）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220805203503930.png"></p>
<ul>
<li>HTTP使用TCP作为它的支撑运输协议（而不是在UDP上运行）。HTTP客户首先发起一个与服务器的TCP连接。一旦连接建立，该浏览器和服务器进程就可以通过套接字接口访问TCP。客户向它的套接字接口发送HTTP请求报文并从它的套接字接口接收HTTP响应报文。类似地，服务器从它的套接字接口接收HTTP请求报文和向它的套接字接口发送HTTP响应报文。一且客户向它的套接字接口发送了一个请求报文，该报文就脱离了客户控制并进入TCP的控制。TCP为HTTP提供可靠数据传输服务。这意味着，一个客户进程发出的每个HTTP请求报文最终能完整地到达服务器；类似地，服务器进程发出的每个HTTP响应报文最终能完整地到达客户。即HTTP协议不用担心数据丢失，也不关注TCP从网络的数据丢失和乱序故障中恢复的细节。那是TCP以及协议栈较低层协议的工作</li>
<li>HTTP服务器并不保存关于客户的任何信息，HTTP是一个无状态协议（slateless protocol）</li>
</ul>
<h2 id="非持续连接和持续连接"><a href="#非持续连接和持续连接" class="headerlink" title="非持续连接和持续连接"></a>非持续连接和持续连接</h2><ul>
<li>在许多因特网应用程序中，客户和服务器在一个相当长的时间范围内通信，其中客户发出一系列请求并且服务器对每个请求进行响应。依据应用程序以及该应用程序的使用方式，这一系列请求可以以规则的间隔周期性地或者间断性地一个接一个发出。当这种客户－服务器的交互是经TCP进行的，应用程序的研制者就需要做一个重要决定，即每个请求/响应对是经一个单独的TCP连接发送，还是所有的请求及其响应经相同的TCP连接发送呢？采用前一种方法，该应用程序被称为使用非持续连接（non-persistent connection）；采用后一种方法，该应用程序被称为使用持续连接（persistent connection）</li>
<li>HTTP既能够使用非持续连接，也能够使用持续连接。尽管HTTP在其默认方式下使用持续连接，HTTP客户和服务器也能配置成使用非持续连接</li>
<li>采用非持续连接的HTTP</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220805204631299.png"></p>
<ul>
<li>非持续连接的使用，其中每个TCP连接在服务器发送一个对象后关闭，即该连接并不为其他的对象而持续下来。值得注意的是每个TCP连接只传输一个请求报文和一个响应报文。因此在本例中，当用户请求该Web页面时，要产生11个TCP连接</li>
<li>非持续连接有一些缺点：第一，必须为每一个请求的对象建立和维护一个全新的连接。对于每个这样的连接，在客户和服务器中都要分配TCP的缓冲区和保持TCP变量，这给Web服务器带来了严重的负担，因为一台Web服务器可能同时服务于数以百计不同的客户的请求。第二，每一个对象经受两倍RTT的交付时延，即一个RTT用于创建TCP，另一个RTT用于请求和接收一个对象</li>
<li>采用持续连接的HTTP：在采用HTTP1.1持续连接的情况下，服务器在发送响应后保持该TCP连接打开。在相同的客户与服务器之间，后续的请求和响应报文能够通过相同的连接进行传送。特别是，一个完整的Web页面（上例中的HTML基本文件加上10个图形）可以用单个持续TCP连接进行传送</li>
</ul>
<h2 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h2><ul>
<li>HTTP请求报文</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> /somedir/page.html HTTP/<span class="number">1.1</span></span><br><span class="line">Host: www.someschool.edu</span><br><span class="line"><span class="keyword">Connection</span>: <span class="keyword">close</span></span><br><span class="line"><span class="keyword">User</span>-agent：Mozilla/<span class="number">5.0</span></span><br><span class="line">Accept-<span class="keyword">language</span>： fr</span><br></pre></td></tr></table></figure>

<ul>
<li>HTTP请求报文的第一行叫作请求行（request line），其后继的行叫作首部行（header line）。请求行有3个字段：方法字段、URL字段和HTTP版本字段。方法字段可以取几种不同的值，包括GET、POST、HEAD、PUT和DELETE。绝大部分的HTTP请求报文使用GET方法</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220805205721367.png"></p>
<ul>
<li>HTTP响应报文</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">HTTP/1.1</span> <span class="number">200</span> <span class="string">OK</span></span><br><span class="line"><span class="attr">Connection:</span> <span class="string">close</span></span><br><span class="line"><span class="attr">Date:</span> <span class="string">Tue，</span> <span class="number">18</span> <span class="string">Aug</span> <span class="number">2015 15:44:04 </span><span class="string">GMT</span></span><br><span class="line"><span class="attr">Server:</span> <span class="string">Apache/2.2.3</span> <span class="string">（Centos）</span></span><br><span class="line"><span class="attr">Last-Modified:</span> <span class="string">Tuer</span> <span class="number">18</span> <span class="string">Aug</span> <span class="number">2015 15:11:03 </span><span class="string">GMT</span></span><br><span class="line"><span class="attr">Content-Length:</span> <span class="number">6821</span></span><br><span class="line"><span class="string">Content-Type：text/html</span></span><br><span class="line"><span class="string">(data</span> <span class="string">data</span> <span class="string">data</span> <span class="string">data</span> <span class="string">data</span> <span class="string">...)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>响应报文有三个部分：一个初始状态行（slatus line），6个首部行（header line），然后是实体体（entity body）。实体体部分是报文的主要部分，即它包含了所请求的对象本身（表示为data data data data data …）。状态行有3个字段：协议版本字段、状态码和相应状态信息。在这个例子中，状态行指示服务器正在使用HTTP/1.1，并且一切正常（即服务器已经找到并正在发送所请求的对象）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220805210302360.png"></p>
<h2 id="用户与服务器的交互：cookie"><a href="#用户与服务器的交互：cookie" class="headerlink" title="用户与服务器的交互：cookie"></a>用户与服务器的交互：cookie</h2><ul>
<li>一个Web站点通常希望能够识别用户，可能是因为服务器希望限制用户的访问，或者因为它希望把内容与用户身份联系起来。为此，HTTP使用了cookie，cookie允许站点对用户进行跟踪。目前大多数商务Web站点都使用了cookie</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220805210650673.png"></p>
<h2 id="Web缓存"><a href="#Web缓存" class="headerlink" title="Web缓存"></a>Web缓存</h2><ul>
<li>Web缓存器（Web cache）也叫代理服务器（proxy server），它是能够代表初始Web服务器来满足HTTP请求的网络实体。Web缓存器有自己的磁盘存储空间，并在存储空间中保存最近请求过的对象的副本</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220805210937881.png"></p>
<ul>
<li>在因特网上部署Web缓存器有两个原因。首先，Web缓存器可以大大减少对客户请求的响应时间，特别是当客户与初始服务器之间的瓶颈带宽远低于客户与Web缓存器之间的瓶颈带宽时更是如此。如果在客户与Web缓存器之间有一个高速连接（情况常常如此），并且如果用户所请求的对象在Web缓存器上，则Web缓存器可以迅速将该对象交付给用户。其次，如我们马上用例子说明的那样，Web缓存器能够大大减少一个机构的接入链路到因特网的通信量。通过减少通信量，该机构就不必急于增加带宽，因此降低了费用。此外，Web缓存器能从整体上大大减低因特网上的Web流量，从而改善了所有应用的性能</li>
</ul>
<h2 id="条件GET方法"><a href="#条件GET方法" class="headerlink" title="条件GET方法"></a>条件GET方法</h2><ul>
<li>尽管高速缓存能减少用户感受到的响应时间，但也引人了一个新的问题，即存放在缓存器中的对象副本可能是陈旧的。换句话说，保存在服务器中的对象自该副本缓存在客户上以后可能已经被修改了。幸运的是，HTTP协议有一种机制，允许缓存器证实它的对象是最新的。这种机制就是条件GET（conditional GET）方法。如果：请求报文使用GET方法；并且请求报文中包含一个”If-Modified-Since:”首部行。那么，这个HTTP请求报文就是一个条件GET请求报文</li>
</ul>
<h1 id="因特网中的电子邮件"><a href="#因特网中的电子邮件" class="headerlink" title="因特网中的电子邮件"></a>因特网中的电子邮件</h1><ul>
<li>因特网电子邮件系统总体情况，有3个主要组成部分：用户代理（user agent）、邮件服务器（mail server）和简单邮件传输协议（Simple Mail Transfer Protocol，SMTP）</li>
</ul>
<h2 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h2><ul>
<li>SMTP是因特网电子邮件的核心，用于从发送方的邮件服务器发送报文到接收方的邮件服务器</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220805212401421.png"></p>
<h2 id="与HTTP对比"><a href="#与HTTP对比" class="headerlink" title="与HTTP对比"></a>与HTTP对比</h2><ul>
<li>这两个协议都用于从一台主机向另一台主机传送文件：HTTP从Web服务器向Web客户（通常是一个浏览器）传送文件（也称为对象）；SMTP从一个邮件服务器向另一个邮件服务器传送文件（即电子邮件报文）。当进行文件传送时，持续的HTTP和SMTP都使用持续连接。</li>
<li>区别：HTTP主要是一个拉协议（pull protocol），即在方便的时候，某些人在Web服务器上装载信息，用户使用HTTP从该服务器拉取这些信息。另一方面，SMTP基本上是一个推协议（push protocol），即发送邮件服务器把文件推向接收邮件服务器</li>
</ul>
<h1 id="DNS：因特网的目的服务"><a href="#DNS：因特网的目的服务" class="headerlink" title="DNS：因特网的目的服务"></a>DNS：因特网的目的服务</h1><h2 id="DNS提供的服务"><a href="#DNS提供的服务" class="headerlink" title="DNS提供的服务"></a>DNS提供的服务</h2><ul>
<li>识别主机有两种方式，通过主机名或者IP地址。需要一种能进行主机名到IP地址转换的目录服务。这就是域名系统（Domain Name System，DNS）的主要任务</li>
<li>DNS：一个由分层的DNS服务器（DNS server）实现的分布式数据库；一个使得主机能够查询分布式数据库的应用层协议</li>
<li>DNS服务器通常是运行BIND（Berkeley Internet Name Domain）软件的UNIX机器。DNS协议运行在UDP之上，使用53号端口</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220805213943120.png"></p>
<h2 id="DNS工作原理概述"><a href="#DNS工作原理概述" class="headerlink" title="DNS工作原理概述"></a>DNS工作原理概述</h2><ul>
<li>运行在用户主机上的某些应用程序（如Web浏览器或邮件阅读器）需要将主机名转换为IP地址。这些应用程序将调用DNS的客户端，并指明需要被转换的主机名（在很多基于UNIX的机器上，应用程序为了执行这种转换需要调用函数gethostbyname()）。用户主机上的DNS接收到后，向网络中发送一个DNS查询报文。所有的DNS请求和回答报文使用UDP数据报经端口53发送。经过若干毫秒到若干秒的时延后，用户主机上的DNS接收到一个提供所希望映射的DNS回答报文。这个映射结果则被传递到调用DNS的应用程序。因此，从用户主机上调用应用程序的角度看，DNS是一个提供简单、直接的转换服务的黑盒子。但事实上，实现这个服务的黑盒子非常复杂，它由分布于全球的大量DNS服务器以及定义了DNS服务器与查询主机通信方式的应用层协议组成</li>
<li>分布式、层次数据库</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220805214241063.png"></p>
<h1 id="P2P文件分发"><a href="#P2P文件分发" class="headerlink" title="P2P文件分发"></a>P2P文件分发</h1><ul>
<li>从单一服务器向大量主机（称为对等方）分发一个大文件。在CS文件分发中，该服务器必须向每个对等方发送该文件的一个副本，即服务器承受了极大的负担，并且消耗了大量的服务器带宽。在P2P文件分发中，每个对等方能够向任何其他对等方重新分发它已经收到的该文件的任何部分，从而在分发过程中协助该服务器</li>
<li>BitTorrent是一种用于文件分发的流行P2P协议。用BitTorremt的术语来讲，参与一个特定文件分发的所有对等方的集合被称为一个洪流（torrent）。在一个洪流中的对等方彼此下载等长度的文件块（chunk），典型的块长度为256KB。当一个对等方首次加人一个洪流时，它没有块。随着时间的流逝，它累积了越来越多的块。当它下载块时，也为其他对等方上载了多个块。一旦某对等方获得了整个文件，它也许（自私地）离开洪流，或（大公无私地）留在该洪流中并继续向其他对等方上载块。同时，任何对等方可能在任何时候仅具有块的子集就离开该洪流，并在以后重新加入该洪流中</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220805214807153.png"></p>
<h1 id="视频流和内容分发网"><a href="#视频流和内容分发网" class="headerlink" title="视频流和内容分发网"></a>视频流和内容分发网</h1><ul>
<li>在HTTP流中，视频只是存储在HTTP服务器中作为一个普通的文件，每个文件有一个特定的URL。当用户要看该视频时，客户与服务器创建一个TCP连接并发送对该URI的HTTP GET请求。服务器则以底层网络协议和流量条件允许的尽可能快的速率，在一个HTTP响应报文中发送该视频文件。在客户一侧，字节被收集在客户应用缓存中。一且该缓存中的字节数量超过预先设定的门限，客户应用程序就开始播放，特别是，流式视频应用程序周期性地从客户应用程序缓存中抓取顿，对这些解压缩并且在用户屏幕上展现。因此，流式视频应用接收到视频就进行播放，同时缓存该视频后面部分的顿</li>
<li>HTTP流具有严重缺陷，即所有客户接收到相同编码的视频，尽管对不同的客户或者对于相同客户的不同时间而言，客户可用的带宽大小有很大不同。这导致了一种新型基于HTTP的流的研发，它常常被称为经HTTP的动态适应性流（Dynamic Adaptive Streaming over HTTP，DASH）。在DASH中，视频编码为几个不同的版本，其中每个版本具有不同的比特率，对应于不同的质量水平。客户动态地请求来自不同版本且长度为几秒的视频段数据块。当可用带宽量较高时，客户自然地选择来自高速率版本的块；当可用带宽量较低时，客户自然地选择来自低速率版本的块。客户用HTTP GET请求报文一次选择个不同的块</li>
<li>为了应对向分布于全世界的用户分发巨量视频数据的挑战，几乎所有主要的视频流公司都利用内容分发网（Content Distribution Network，CDN）。CDN管理分布在多个地理位置上的服务器，在它的服务器中存储视频（和其他类型的Web内容，包括文档、图片和音频）的副本，并且所有试图将每个用户请求定向到一个将提供最好的用户体验的CDN位置</li>
</ul>
<h1 id="套接字编程：生成网络应用"><a href="#套接字编程：生成网络应用" class="headerlink" title="套接字编程：生成网络应用"></a>套接字编程：生成网络应用</h1><h2 id="UDP套接字编程"><a href="#UDP套接字编程" class="headerlink" title="UDP套接字编程"></a>UDP套接字编程</h2><p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220805215845788.png"></p>
<h2 id="TCP套接字编程"><a href="#TCP套接字编程" class="headerlink" title="TCP套接字编程"></a>TCP套接字编程</h2><ul>
<li>与UDP不同，TCP是一个面向连接的协议。这意味着在客户和服务器能够开始互相发送数据之前，它们先要握手和创建一个TCP连接。TCP连接的一端与客户套接字相联系，另一端与服务器套接字相联系。当创建该TCP连接时，我们将其与客户套接字地址（IP地址和端口号）和服务器套接字地址（IP地址和端口号）关联起来。使用创建的TCP连接，当一侧要向另一侧发送数据时，它只需经过其套接字将数据丢进TCP连接。这与UDP不同，UDP服务器在将分组丢进套接字之前必须为其附上一个目的地地址</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220805220403472.png"></p>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220805220509152.png"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Chap03_运输层</title>
    <url>/2022/04/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Chap03_%E8%BF%90%E8%BE%93%E5%B1%82/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220813221439355.png"></p>
<h1 id="概述和运输层服务"><a href="#概述和运输层服务" class="headerlink" title="概述和运输层服务"></a>概述和运输层服务</h1><ul>
<li>运输层协议是在端系统中而不是在路由器中实现的。在发送端，运输层将从发送应用程序进程接收到的报文转换成运输层分组，用因特网术语来讲该分组称为运输层报文段（segmemt）。实现的方法（可能）是将应用报文划分为较小的块，并为每块加上一个运输层首部以生成运输层报文段。然后，在发送端系统中，运输层将这些报文段传递给网络层，网路层将其封装成网络层分组（即数据报）并向目的地发送</li>
<li>网络路由器仅作用于该数据报的网络层字段，即它们不检查封装在该数据报的运输层报文段的字段。在接收端，网络层从数据报中提取运输层报文段，并将该报文段向上交给运输层。运输层则处理接收到的报文段，使该报文段中的数据为接收应用进程使用</li>
</ul>
<h2 id="运输层和网络层关系"><a href="#运输层和网络层关系" class="headerlink" title="运输层和网络层关系"></a>运输层和网络层关系</h2><ul>
<li>在协议栈中，运输层刚好位于网络层之上。网络层提供了主机之间的逻辑通信，而运输层为运行在不同主机上的进程之间提供了逻辑通信</li>
<li>运输层协议只工作在端系统中。在端系统中，运输层协议将来自应用进程的报文移动到网络边缘（即网络层），反过来也是一样，但对有关这些报文在网络核心如何移动并不作任何规定，中间路由器既不处理也不识别运输层加在应用层报文的任何信息</li>
<li>运输协议能够提供的服务常常受制于底层网络层协议的服务模型。如果网络层协议无法为主机之间发送的运输层报文段提供时延或带宽保证的话，运输层协议也就无法为进程之间发送的应用程序报文提供时延或带宽保证</li>
</ul>
<h2 id="因特网运输层概述"><a href="#因特网运输层概述" class="headerlink" title="因特网运输层概述"></a>因特网运输层概述</h2><ul>
<li>UDP（用户数据报协议），为调用它的应用程序提供了一种不可靠、无连接的服务</li>
<li>TCP（传输控制协议），为调用它的应用程序提供了一种可靠的、面向连接的服务</li>
<li>术语：将运输层分组称为报文段（segment）。然而，因特网文献（如RFC文档）也将TCP的运输层分组称为报文段，而常将UDP的分组称为数据报（datagram）。而这类因特网文献也将网络层分组称为数据报。为不引起混淆，此文将TCP和UDP的分组统称为报文段，而将数据报名称保留给网络层分组</li>
<li>因特网网络层协议有一个名字叫IP，即网际协议。IP为主机之间提供了逻辑通信。IP的服务模型是尽力而为交付服务（best-effort delivery service）。这意味着IP尽它“最大的努力”在通信的主机之间交付报文段，但它并不做任何确保。特别是，它不确保报文段的交付，不保证报文段的按序交付，不保证报文段中数据的完整性。由于这些原因，IP被称为不可靠服务（unreliable service）</li>
<li>UDP和TCP最基本的责任是，将两个端系统间IP的交付服务扩展为运行在端系统上的两个进程之间的交付服务。将主机间交付扩展到进程间交付被称为运输层的多路复用（transport-layer multiplexing）与多路分解（demultiplexing）</li>
<li>UDP和TCP还可以通过在其报文段首部中包括差错检查字段而提供完整性检查。进程到进程的数据交付和差错检查是两种最低限度的运输层服务，也是UDP所能提供的仅有的两种服务。特别是，与IP一样，UDP也是一种不可靠的服务，即不能保证一个进程所发送的数据能够完整无缺地（或全部）到达目的进程</li>
<li>另一方面，TCP为应用程序提供了几种附加服务。首先，它提供可靠数据传输（reliable data transfer）。通过使用流量控制、序号、确认和定时器，TCP确保正确地、按序地将数据从发送进程交付给接收进程。这样，TCP就将两个端系统间的不可靠IP服务转换成了一种进程间的可靠数据传输服务</li>
<li>TCP还提供拥塞控制（congestion contol）。拥塞控制与其说是一种提供给调用它的应用程序的服务，不如说是一种提供给整个因特网的服务，这是一种带来通用好处的服务。不太严格地说，TCP拥塞控制防止任何一条TCP连接用过多流量来淹没通信主机之间的链路和交换设备。TCP力求为每个通过一条拥塞网络链路的连接平等地共享网络链路带宽。这可以通过调节TCP连接的发送端发送进网络的流量速率来做到。在另一方面，UDP流量是不可调节的。使用UDP传输的应用程序可以根据其需要以其愿意的任何速率发送数据</li>
</ul>
<h1 id="多路复用和多路分解"><a href="#多路复用和多路分解" class="headerlink" title="多路复用和多路分解"></a>多路复用和多路分解</h1><ul>
<li>一个进程（作为网络应用的一部分）有一个或多个套接字（socket），它相当于从网络向进程传递数据和从进程向网络传递数据的门户。因此，在接收主机中的运输层实际上并没有直接将数据交付给进程，而是将数据交给了一个中间的套接字。由于在任一时刻，在接收主机上可能有不止一个套接字，所以每个套接字都有唯一的标识符</li>
<li>考虑接收主机怎样将一个到达的运输层报文段定向到适当的套接字。每个运输层报文段中具有几个字段，在接收端，运输层检查这些字段，标识出接收套接字，进而将报文段定向到该套接字。将运输层报文段中的数据交付到正确的套接字的工作称为多路分解（demultiplexing）。在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息（这将在以后用于分解）从而生成报文段，然后将报文段传递到网络层，所有这些工作称为多路复用（multiplexing）。图3-2中的中间那台主机的运输层必须将从其下的网络层收到的报文段分解后交给其上的P1或P2进程，这一过程是通过将到达的报文段数据定向到对应进程的套接字来完成的</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220810225838522.png"></p>
<ul>
<li>运输层多路复用要求：套接字有唯一标识符；每个报文段有特殊字段来指示该报文段所要交付到的套接字。这些特殊字段是源端口号字段（source port number field）和目的端口号字段（destination port number field）。端口号是一个16比特的数，其大小在0 ~ 65535之间。0~1023范围的端口号称为周知端口号（well-known port number），是受限制的，这是指它们保留给诸如HTTP（它使用端口号80）和FTP（它使用端口号21）之类的周知应用层协议来使用。当我们开发一个新的应用程序时必须为其分配一个端口号</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220810230829512.png"></p>
<ul>
<li>一个UDP套接字是由一个二元组全面标识的，该二元组包含一个目的IP地址和一个目的端口号</li>
<li>TCP套接字和UDP套接字之间的一个细微差别是，TCP套接字是由一个四元组（源IP地址，源端口号，目的IP地址，目的端口号）来标识的。因此，当一个TCP报文段从网络到达一台主机时，该主机使用全部4个值来将报文段定向（分解）到相应的套接字。特别与UDP不同的是，两个具有不同源IP地址或源端口号的到达TCP报文段将被定向到两个不同的套接字</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220810231729335.png"></p>
<h1 id="无连接运输：UDP"><a href="#无连接运输：UDP" class="headerlink" title="无连接运输：UDP"></a>无连接运输：UDP</h1><ul>
<li>运输层最低限度必须提供一种复用/分解服务，以便在网络层与正确的应用级进程之间传递数据</li>
<li>UDP只是做了运输协议能够做的最少工作。除了复用/分解功能及少量的差错检测外，它几乎没有对IP增加别的东西。实际上，如果应用程序开发人员选择UDP而不是TCP，则该应用程序差不多就是直接与IP打交道。UDP从应用进程得到数据，附加上用于多路复用/分解服务的源和目的端口号字段，以及两个其他的小字段，然后将形成的报文段交给网络层。网络层将该运输层报文段封装到一个IP数据报中，然后尽力而为地尝试将此报文段交付给接收主机。如果该报文段到达接收主机，UDP使用目的端口号将报文段中的数据交付给正确的应用进程</li>
<li>使用UDP时，在发送报文段之前，发送方和接收方的运输层实体之间没有握手。正因为如此，UDP被称为是无连接的</li>
<li>许多应用更适合UDP的原因</li>
</ul>
<blockquote>
<p>关于发送什么数据以及何时发送的应用层控制更为精细。采用UDP时，只要应用进程将数据传递给UDP，UDP就会将此数据打包进UDP报文段并立即将其传递给网络层。在另一方面，TCP有一个拥塞控制机制，以便当源和目的主机间的一条或多条链路变得极度拥塞时来遏制运输层TCP发送方。TCP仍将继续重新发送数据报文段直到目的主机收到此报文并加以确认，而不管可靠交付需要用多长时间。因为实时应用通常要求最小的发送速率，不希望过分地延迟报文段的传送，且能容忍一些数据丢失，TCP服务模型并不是特别适合这些应用的需要。这些应用可以使用UDP，并作为应用的一部分来实现所需的、超出UDP的不提供不必要的报文段交付服务之外的额外功能</p>
<p>无须连接建立。TCP在开始数据传输之前要经过三次握手。UDP却不需要任何准备即可进行数据传输。因此UDP不会引入建立连接的时延。这可能是DNS运行在UDP之上而不是运行在TCP之上的主要原因（如果运行在TCP上，则DNS会慢得多）。HTTP使用TCP而不是UDP，因为对于具有文本数据的Web网页来说，可靠性是至关重要的。但是，HTTP中的TCP连接建立时延对于与下载Web文档相关的时延来说是一个重要因素。用于谷歌的Chrome浏览器中的QUIC协议（快速UDP因特网连接将UDP作为其支撑运输协议并在UDP之上的应用层协议中实现可靠性</p>
<p>无连接状态。TCP需要在端系统中维护连接状态。此连接状态包括接收和发送缓存、拥塞控制参数以及序号与确认号的参数。要实现TCP的可靠数据传输服务并提供拥塞控制，这些状态信息是必要的。另一方面，UDP不维护连接状态，也不跟踪这些参数。因此，某些专门用于某种特定应用的服务器当应用程序运行在UDP之上而不是运行在TCP上时，一般都能支持更多的活跃客户</p>
<p>分组首部开销小。每个TCP报文段都有20字节的首部开销，而UDP仅有8字节的开销</p>
</blockquote>
<ul>
<li>UDP没有拥塞控制。但是，需要拥塞控制来预防网络进人一种拥塞状态，在拥塞状态中可做的有用工作非常少。如果每个人都启动流式高比特率视频而不使用任何拥塞控制的话，就会使路由器中有大量的分组溢出，以至于非常少的UDP分组能成功地通过源到目的的路径传输。况且，由无控制的UDP发送方引入的高丢包率将引起TCP发送方（TCP遇到拥塞将减小它们的发送速率）大大地减小它们的速率。因此，UDP中缺乏拥塞控制能够导致UDP发送方和接收方之间的高丢包率，并挤跨了TCP会话，这是一个潜在的严重问题</li>
</ul>
<h2 id="UDP报文段结构"><a href="#UDP报文段结构" class="headerlink" title="UDP报文段结构"></a>UDP报文段结构</h2><ul>
<li>UDP报文段结构，首部8字节</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220810234323338.png"></p>
<ul>
<li>UDP首部只有4个字段，每个字段由两个字节组成。通过端口号可以使目的主机将应用数据交给运行在目的端系统中的相应进程（即执行分解功能）。长度字段指示了在UDP报文段中的字节数（首部加数据）。因为数据字段的长度在一个UDP段中不同于在另一个段中，故需要一个明确的长度。接收方使用检验和来检查在该报文段中是否出现了差错</li>
</ul>
<h2 id="UDP校验和"><a href="#UDP校验和" class="headerlink" title="UDP校验和"></a>UDP校验和</h2><ul>
<li>UDP检验和提供了差错检测功能。用于确定当UDP报文段从源到达目的地移动时，其中的比特是否发生了改变（例如，由于链路中的噪声干扰或者存储在路由器中时引人问题）</li>
<li>为什么UDP首先提供了检验和，就像许多链路层协议（包括流行的以太网协议）也提供了差错检测那样。其原因是不能保证源和目的之间的所有链路都提供差错检测；这就是说，也许这些链路中的一条可能使用没有差错检测的协议。此外，即使报文段经链路正确地传输，当报文段存储在某台路由器的内存中时，也可能引入比特差错。在既无法确保逐链路的可靠性，又无法确保内存中的差错检测的情况下，如果端到端数据传输服务要提供差错检测，UDP就必须在端到端基础上在运输层提供差错检测</li>
<li>虽然UDP提供差错检测，但它对差错恢复无能为力。UDP的某种实现只是丢弃受损的报文段；其他实现是将受损的报文段交给应用程序并给出警告</li>
</ul>
<h1 id="可靠数据传输原理"><a href="#可靠数据传输原理" class="headerlink" title="可靠数据传输原理"></a>可靠数据传输原理</h1><ul>
<li>可靠数据传输框架，为上层实体提供的服务抽象是：数据可以通过一条可靠的信道进行传输。借助于可靠信道，传输数据比特就不会受到损坏（由0变为1，或者相反）或丢失，而且所有数据都是按照其发送顺序进行交付，这恰好就是TCP向调用它的因特网应用所提供的服务模型</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220812215048946.png"></p>
<ul>
<li>实现这种服务抽象是可靠数据传输协议（reliable data transfer protocol）的责任</li>
</ul>
<h2 id="构造可靠数据传输协议"><a href="#构造可靠数据传输协议" class="headerlink" title="构造可靠数据传输协议"></a>构造可靠数据传输协议</h2><h3 id="经完全可靠信道的可靠数据传输：rdt1-0"><a href="#经完全可靠信道的可靠数据传输：rdt1-0" class="headerlink" title="经完全可靠信道的可靠数据传输：rdt1.0"></a>经完全可靠信道的可靠数据传输：rdt1.0</h3><p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220812215928866.png"></p>
<ul>
<li>rdt的发送端只通过rdt_send(data)事件接受来自较高层的数据，产生一个包含该数据的分组（经由make_pkt(data)动作），并将分组发送到信道中。实际上，rdt_send(data)事件是由较高层应用的过程调用产生的（例如，rdt_send()）</li>
<li>在接收端，rdt通过rdt_rev(packet)事件从底层信道接收一个分组，从分组中取出数据（经由extract(packet, data)动作），并将数据上传给较高层（通过deliver_data(data)动作）。实际上，rdt_rcv(packet)事件是由较低层协议的过程调用产生的（例如，rdt_rcv()）</li>
<li>在这个简单的协议中，一个单元数据与一个分组没差别。而且，所有分组是从发送方流向接收方；有了完全可靠的信道，接收端就不需要提供任何反馈信息给发送方，因为不必担心出现差错！注意到我们也已经假定了接收方接收数据的速率能够与发送方发送数据的速率一样快。因此，接收方没有必要请求发送方慢一点</li>
</ul>
<h3 id="经具有比特差错信道的可靠数据传输：rdt2-0"><a href="#经具有比特差错信道的可靠数据传输：rdt2-0" class="headerlink" title="经具有比特差错信道的可靠数据传输：rdt2.0"></a>经具有比特差错信道的可靠数据传输：rdt2.0</h3><ul>
<li><p>底层信道更为实际的模型是分组中的比特可能受损的模型。在分组的传输、传播或缓存的过程中，这种比特差错通常会出现在网络的物理部件中。眼下还将继续假定所有发送的分组（虽然有些比特可能受损）将按其发送的顺序被接收</p>
</li>
<li><p>在通常情况下，报文接收者在听到、理解并记下每句话后可能会说“OK”。如果报文接收者听到一句含糊不清的话时，他可能要求你重复那句容易误解的话。这种口述报文协议使用了肯定确认（positive acknowledgment）（“OK”）与否定确认（negative acknowledgment）（“请重复一遍”）。这些控制报文使得接收方可以让发送方知道哪些内容被正确接收，哪些内容接收有误并因此需要重复。在计算机网络环境中，基于这样重传机制的可靠数据传输协议称为自动重传请求（Automatic Repeat reQuest，ARQ）协议</p>
</li>
<li><p>重要的是，ARQ协议中还需要另外三种协议功能来处理存在比特差错的情况</p>
</li>
</ul>
<blockquote>
<p>差错检测。首先，需要一种机制以使接收方检测到何时出现了比特差错。前一节讲到，UDP使用因特网检验和字段正是为了这个目的。差错检测和纠错技术使接收方可以检测并可能纠正分组中的比特差错。此刻，我们只需知道这些技术要求有额外的比特（除了待发送的初始数据比特之外的比特）从发送方发送到接收方；这些比特将被汇集在rd2.0数据分组的分组检验和字段中</p>
<p>接收方反馈。因为发送方和接收方通常在不同端系统上执行，可能相隔数千英里，发送方要了解接收方情况（此时为分组是否被正确接收）的唯一途径就是让接收方提供明确的反馈信息给发送方。在口述报文情况下回答的“肯定确认”（ACK）和“否定确认”（NAK）就是这种反馈的例子。类似地，rdt2.0协议将从接收方向发送方回送ACK与NAK分组。理论上，这些分组只需要一个比特长；如用0表示NAK，用1表示ACK</p>
<p>重传。接收方收到有差错的分组时，发送方将重传该分组</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220812223009864.png"></p>
<ul>
<li>rdt2.0的发送端有两个状态。在最左边的状态中，发送端协议正等待来自上层传下来的数据。当rdt_send(data)事件出现时，发送方将产生一个包含待发送数据的分组（sndpkt），带有检验和，然后经由udt_send(sndpkt)操作发送该分组。在最右边的状态中，发送方协议等待来自接收方的ACK或NAK分组。如果收到一个ACK分组（图3-10中符号rdt_rcv(rcvpkt) &amp;&amp; isACK(rcvpkt)对应该事件），则发送方知道最近发送的分组已被正确接收，因此协议返回到等待来自上层的数据的状态。如果收到一个NAK分组，该协议重传上一个分组并等待接收方为响应重传分组而回送的ACK和NAK。注意到下列事实很重要：当发送方处于等待ACK或NAK的状态时，它不能从上层获得更多的数据；这就是说，rdt_send()事件不可能出现；仅当接收到ACK并离开该状态时才能发生这样的事件。因此，发送方将不会发送一块新数据，除非发送方确信接收方已正确接收当前分组。由于这种行为，rdt2.0这样的协议被称为停等（stop-and-wait）协议</li>
<li>rdt2.0接收方的FSM仍然只有单一状态。当分组到达时，接收方要么回答一个ACK，要么回答一个NAK，这取决于收到的分组是否受损。在图3-10中，符号rdt_rcv(rcvpkt) &amp;&amp; corrupt(rcvpkt)对应于收到一个分组并发现有错的事件</li>
<li>rdt2.0协议看起来似乎可以运行了，但它存在一个致命的缺陷。尤其是我们没有考虑到ACK或NAK分组受损的可能性！遗撼的是，我们细小的疏忽并非像它看起来那么无关紧要。至少，我们需要在ACK/NAK分组中添加检验和比特以检测这样的差错。更难的问题是协议应该怎样纠正ACK或NAK分组中的差错。这里的难点在于，如果一个ACK或NAK分组受损，发送方无法知道接收方是否正确接收了上一块发送的数据</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220812224325441.png"></p>
<ul>
<li>解决这个新问题的一个简单方法（几乎所有现有的数据传输协议中，包括TCP，都采用了这种方法）是在数据分组中添加一新字段，让发送方对其数据分组编号，即将发送数据分组的序号（sequence number）放在该字段。于是，接收方只需要检查序号即可确定收到的分组是否一次重传。对于停等协议这种简单情况，1比特序号就足够了，因为它可让接收方知道发送方是否正在重传前一个发送分组（接收到的分组序号与最近收到的分组序号相同），或是一个新分组（序号变化了，用模2运算“前向”移动）。因为目前我们假定信道不丢分组，ACK和NAK分组本身不需要指明它们要确认的分组序号。发送方知道所接收到的ACK和NAK分组（无论是否是含糊不清的）是为响应其最近发送的数据分组而生成的</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220812225236778.png"></p>
<ul>
<li>协议rdt2.1使用了从接收方到发送方的肯定确认和否定确认。当接收到失序的分组时，接收方对所接收的分组发送一个肯定确认。如果收到受损的分组，则接收方将发送一个否定确认。如果不发送NAK，而是对上次正确接收的分组发送一个ACK，我们也能实现与NAK一样的效果。发送方接收到对同一个分组的两个ACK（即接收冗余ACK（duplicate ACK））后，就知道接收方没有正确接收到跟在被确认两次的分组后面的分组。rdt2.2是在有比特差错信道上实现的一个无NAK的可靠数据传输协议</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220812225955530.png"></p>
<h3 id="经具有比特差错的丢包信道的可靠数据传输：rdt3-0"><a href="#经具有比特差错的丢包信道的可靠数据传输：rdt3-0" class="headerlink" title="经具有比特差错的丢包信道的可靠数据传输：rdt3.0"></a>经具有比特差错的丢包信道的可靠数据传输：rdt3.0</h3><ul>
<li>现在假定除了比特受损外，底层信道还会丢包，协议现在必须处理另外两个关注的问题：怎样检测丢包以及发生丢包后该做些什么</li>
<li>让发送方负责检测和恢复丢包工作。假定发送方传输一个数据分组，该分组或者接收方对该分组的ACK发生了丢失。在这两种情况下，发送方都收不到应当到来的接收方的响应。如果发送方愿意等待足够长的时间以便确定分组已丢失，则它只需重传该数据分组即可</li>
<li>发送方至少需要等待这样长的时间：即发送方与接收方之间的一个往返时延（可能会包括在中间路由器的缓冲时延）加上接收方处理一个分组所需的时间。在很多网络中，最坏情况下的最大时延是很难估算的，确定的因素非常少。此外，理想的协议应尽可能快地从丢包中恢复出来；等待一个最坏情况的时延可能意味着要等待一段较长的时间，直到启动差错恢复为止。因此实践中采取的方法是发送方明智地选择一个时间值，以判定可能发生了丢包（尽管不能确保）。如果在这个时间内没有收到ACK，则重传该分组。注意到如果一个分组经历了一个特别大的时延，发送方可能会重传该分组，即使该数据分组及其ACK都没有丢失。这就在发送方到接收方的信道中引人了冗余数据分组（duplicate data packet）的可能性。rdt2.2协议已经有足够的功能（即序号）来处理冗余分组情况</li>
<li>从发送方的观点来看，重传是一种万能灵药。发送方不知道是一个数据分组丢失，还是一个ACK丢失，或者只是该分组或ACK过度延时。在所有这些情况下，动作是同样的：重传。为了实现基于时间的重传机制，需要一个倒计数定时器（countdown timer），在一个给定的时间量过期后，可中断发送方。因此，发送方需要能做到：每次发送一个分组（包括第一次分组和重传分组）时，便启动一个定时器。响应定时器中断（采取适当的动作）。终止定时器</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220812230834878.png"></p>
<ul>
<li>因为分组序号在0和1之间交替，因此rdt3.0有时被称为比特交替协议（alternating-bit protocol）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220812231109177.png"></p>
<ul>
<li>在检验和、序号、定时器、肯定和否定确认分组这些技术中，每种机制都在协议的运行中起到了必不可少的作用。至此，我们得到了一个可靠数据传输协议</li>
</ul>
<h2 id="流水线可靠数据传输协议"><a href="#流水线可靠数据传输协议" class="headerlink" title="流水线可靠数据传输协议"></a>流水线可靠数据传输协议</h2><ul>
<li>rdt3.0是一个功能正确的协议，但rdt3.0性能问题的核心在于它是一个停等协议</li>
<li>这种特殊的性能问题的一个简单解决方法是：不以停等方式运行，允许发送方发送多个分组而无须等待确认，如果发送方可以在等诗确认之前发送3个报文，其利用率也基本上提高3倍。因为许多从发送方向接收方输送的分组可以被看成是填充到一条流水线中，故这种技术被称为流水线（pipelining）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220812231623110.png"></p>
<ul>
<li>必须增加序号范围，因为每个输送中的分组（不计算重传的）必须有一个唯一的序号，而且也许有多个在输送中的未确认报文</li>
<li>协议的发送方和接收方两端也许不得不缓存多个分组。发送方最低限度应当能缓冲那些已发送但没有确认的分组。接收方或许也需要缓存那些已正确接收的分组。</li>
<li>所需序号范围和对缓冲的要求取决于数据传输协议如何处理丢失、损坏及延时过大的分组。解决流水线的差错恢复有两种基本方法是：回退N步（Go-Back-N，GBN）和选择重传（Selective Repeat，SR）</li>
</ul>
<h2 id="回退N步"><a href="#回退N步" class="headerlink" title="回退N步"></a>回退N步</h2><ul>
<li>在回退N步（GBN）协议中，允许发送方发送多个分组（当有多个分组可用时）而不需等待确认，但它也受限于在流水线中未确认的分组数不能超过某个最大允许数N</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220812232101476.png"></p>
<ul>
<li>如图3-19，那些已被发送但还未被确认的分组的许可序号范围可以被看成是一个在序号范围内长度为N的窗口。随着协议的运行，该窗口在序号空间向前滑动。因此，N常被称为窗口长度（window size），GBN协议也常被称为滑动窗口协议（sliding-window protocol）</li>
<li>为什么先要限制这些被发送的、未被确认的分组的数目为N呢？为什么不允许这些分组为无限制的数目呢？将在3.5节看到，流量控制是对发送方施加限制的原因之一。将在3.7节学习TCP拥塞控制时分析另一个原因</li>
<li>GBN发送方必须响应三种类型的事件</li>
</ul>
<blockquote>
<p>上层的调用。当上层调用rdt_send()时，发送方首先检查发送窗口是否已满，即是否有N个已发送但未被确认的分组。如果窗口未满，则产生一个分组并将其发送，并相应地更新变量。如果窗口已满，发送方只需将数据返回给上层，隐式地指示上层该窗口已满。然后上层可能会过一会儿再试。在实际实现中，发送方更可能缓存（并不立刻发送）这些数据，或者使用同步机制（如一个信号量或标志）允许上层在仅当窗口不满时才调用rdt_send()</p>
<p>收到一个ACK。在GBN协议中，对序号为n的分组的确认采取累积确认（cumulative acknowledgment）的方式，表明接收方已正确接收到序号为n的以前且包括n在内的所有分组</p>
<p>超时事件。协议的名字“回退N步”来源于出现丢失和时延过长分组时发送方的行为。就像在停等协议中那样，定时器将再次用于恢复数据或确认分组的丢失。如果出现超时，发送方重传所有已发送但还未被确认过的分组。发送方仅使用一个定时器，它可被当作是最早的已发送但未被确认的分组所使用的定时器。如果收到一个ACK，但仍有已发送但未被确认的分组，则定时器被重新启动。如果没有已发送但未被确认的分组，停止该定时器</p>
</blockquote>
<ul>
<li>在GBN中，接收方的动作也很简单。如果一个序号为n的分组被正确接收到，并且按序（即上次交付给上层的数据是序号为n-1的分组），则接收方为分组n发送一个ACK，并将该分组中的数据部分交付到上层。在所有其他情况下，接收方丢弃该分组，并为最近按序接收的分组重新发送ACK。注意到因为一次交付给上层一个分组，如果分组k已接收并交付，则所有序号比k小的分组也已经交付。因此，使用累积确认是CBN一个自然的选择</li>
<li>在GBN协议中，接收方丢弃所有失序分组。尽管丢弃一个正确接收（但失序）的分组有点浪费，但这样做是有理由的。前面讲过，接收方必须按序将数据交付给上层。假定现在期望接收分组n，而分组n+1却到了。因为数据必须按序交付，接收方可能缓存（保存）分组n+1，然后，在它收到并交付分组n后，再将该分组交付到上层。然而，如果分组n丢失，则该分组及分组n+1最终将在发送方根据GBN重传规则而被重传。因此，接收方只需丢弃分组n+1即可。这种方法的优点是接收缓存简单，即接收方不需要缓存任何失序分组。因此，虽然发送方必须维护窗口的上下边界及nextseqnum在该窗口中的位置，但是接收方需要维护的唯一信息就是下一个按序接收的分组的序号。当然，丢弃一个正确接收的分组的缺点是随后对该分组的重传也许会丢失或出错，因此甚至需要更多的重传</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220812235849135.png"></p>
<h2 id="选择重传"><a href="#选择重传" class="headerlink" title="选择重传"></a>选择重传</h2><ul>
<li>GBN协议潜在地允许发送方用多个分组“填充流水线”，因此避免了停等协议中所提到的信道利用率问题。然而，GBN本身也有一些情况存在着性能问题。尤其是当窗口长度和带宽时延积都很大时，在流水线中会有很多分组更是如此。单个分组的差错就能够引起GBN重传大量分组，许多分组根本没有必要重传。随着信道差错率的增加，流水线可能会被这些不必要重传的分组所充斤</li>
<li>选择重传（SR）协议通过让发送方仅重传那些它怀疑在接收方出错（即丢失或受损）的分组而避免了不必要的重传。这种个别的、按需的重传要求接收方逐个地确认正确接收的分组。再次用窗口长度N来限制流水线中未完成、未被确认的分组数。然而，与GBN不同的是，发送方已经收到了对窗口中某些分组的ACK</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220813000333949.png"></p>
<ul>
<li>SR接收方将确认一个正确接收的分组而不管其是否按序。失序的分组将被缓存直到所有丢失分组（即序号更小的分组）皆被收到为止，这时才可以将一批分组按序交付给上层</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220813000619889.png"></p>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220813000706947.png"></p>
<ul>
<li>图3-25中的第二步很重要，接收方重新确认（而不是忽略）已收到过的那些序号小于当前窗口基序号的分组。例如，给定在图3-23中所示的发送方和接收方的序号空间，如果分组send_base的ACK没有从接收方传播回发送方，则发送方最终将重传分组send_base，即使显然（对我们而不是对发送方来说！）接收方已经收到了该分组。如果接收方不确认该分组，则发送方窗口将永远不能向前滑动</li>
<li>可靠数据传输机制及其用途总结</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220813001100265.png"></p>
<h1 id="面向连接的运输：TCP"><a href="#面向连接的运输：TCP" class="headerlink" title="面向连接的运输：TCP"></a>面向连接的运输：TCP</h1><ul>
<li>TCP是因特网运输层的面向连接的可靠的运输协议。为了提供可靠数据传输，TCP依赖于许多基本原理，其中包括差错检测、重传、累积确认、定时器以及用于序号和确认号的首部字段</li>
</ul>
<h2 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h2><ul>
<li>TCP被称为是面向连接的（connection-oriented），在一个应用进程可以开始向另一个应用进程发送数据之前，这两个进程必须先相互“握手”，即它们必须相互发送某些预备报文段，以建立确保数据传输的参数。作为TCP连接建立的一部分，连接的双方都将初始化与TCP连接相关的许多TCP状态变量</li>
<li>TCP“连接”不是一条像在电路交换网络中的端到端TDM或FDM电路。相反该“连接”是一条逻辑连接，其共同状态仅保留在两个通信端系统的TCP程序中。由于TCP协议只在端系统中运行，而不在中间的网络元素（路由器和链路层交换机）中运行，所以中间的网络元素不会维持TCP连接状态。事实上，中间路由器对TCP连接完全视而不见，它们看到的是数据报，而不是连接</li>
<li>TCP连接也总是点对点（point-to-point）的，即在单个发送方与单个接收方之间的连接。所谓“多播”，即在一次发送操作中，从一个发送方将数据传送给多个接收方，这种情况对TCP来说是不可能的</li>
<li>三次握手：客户首先发送一个特殊的TCP报文段，服务器用另一个特殊的TCP报文段来响应，最后，客户再用第三个特殊报文段作为响应。前两个报文段不承载“有效载荷”，也就是不包含应用层数据；而第三个报文段可以承载有效载荷</li>
<li>客户进程通过套接字（该进程之门）传递数据流。数据一旦通过该门，它就由客户中运行的TCP控制了。TCP将这些数据引导到该连接的发送缓存（send buffer）里，发送缓存是发起三次握手期间设置的缓存之一。接下来TCP就会不时从发送缓存里取出一块数据，并将数据传递到网络层。在TCP规范中却没提及TCP应何时实际发送缓存里的数据，只是描述为“TCP应该在它方便的时候以报文段的形式发送数据”</li>
<li>TCP可从缓存中取出并放入报文段中的数据数量受限于最大报文段长度（Maximum Segment Size，MSS）。MSS通常根据最初确定的由本地发送主机发送的最大链路层帧长度（即所谓的最大传输单元（Maximum Transmission Unit，MTU））来设置。设置该MSS要保证一个TCP报文段（当封装在一个IP数据报中）加上TCP/IP首部长度（通常40字节）将适合单个链路层帧</li>
<li>以太网和PPP链路层协议都具有1500字节的MTU，因此MSS的典型值为1460字节。注意到MSS是指在报文段里应用层数据的最大长度，而不是指包括首部的TCP报文段的最大长度</li>
<li>TCP为每块客户数据配上一个TCP首部，从而形成多个TCP报文段（TCP segment）。这些报文段被下传给网络层，网络层将其分别封装在网络层IP数据报中。然后这些IP数据报被发送到网络中。当TCP在另一端接收到一个报文段后，该报文段的数据就被放人该TCP连接的接收缓存中，应用程序从此缓存中读取数据流</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220813195037582.png"></p>
<h2 id="TCP报文段结构"><a href="#TCP报文段结构" class="headerlink" title="TCP报文段结构"></a>TCP报文段结构</h2><ul>
<li>TCP报文段由首部字段和一个数据字段组成。数据字段包含一块应用数据。MSS限制了报文段数据字段的最大长度。当TCP发送一个大文件，例如某Web页面上的一个图像时，TCP通常是将该文件划分成长度为MSS的若干块（最后一块除外，它通常小于MSS）</li>
<li>TCP报文段结构，注意UDP报文段结构中包含UDP报文段长度，而TCP只有一个首部长度，并不包含数据长度，只有通过序号来表示数据在字节流中的位置，因此UDP接收的是一个完整的报文段，TCP接收的是字节流</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220813195406226.png"></p>
<ul>
<li>首部包括源端口号和目的端口号，它被用于多路复用/分解来自或送到上层应用的数据。另外，同UDP一样，TCP首部也包括检验和字段（checksum field）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220813195512991.png"></p>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220813195609742.png"></p>
<ul>
<li>序号和确认号：TCP把数据看成一个无结构的、有序的字节流。从TCP对序号的使用上可以看出这一点，因为序号是建立在传送的字节流之上，而不是建立在传送的报文段的序列之上。一个报文段的序号（sequence number for a segment）因此是该报文段首字节的字节流编号。举例来说，假设主机A上的一个进程想通过一条TCP连接向主机B上的一个进程发送一个数据流。主机A中的TCP将隐式地对数据流中的每一个字节编号。假定数据流由一个包含500000字节的文件组成，其MSS为1000字节，数据流的首字节编号是0。如图3-30所示，该TCP将为该数据流构建500个报文段。给第一个报文段分配序号0，第二个报文段分配序号1000，第三个报文段分配序号2000，以此类推。每一个序号被填人到相应TCP报文段首部的序号字段中</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220813200008491.png"></p>
<ul>
<li>确认号，TCP是全双工的，因此主机A在向主机B发送数据的同时，也许也接收来自主机B的数据（都是同一条TCP连接的一部分）。从主机B到达的每个报文段中都有一个序号用于从B流向A的数据。主机A填充进报文段的确认号是主机A期望从主机B收到的下一字节的序号</li>
<li>假设主机A已收到一个来自主机B的包含字节0<del>535的报文段，以及另一个包含字节900</del>1000的报文段。由于某种原因，主机A还没有收到字节536~899的报文段。主机A为了重新构建主机B的数据流，仍在等待字节536（和其后的字节）。因此，A到B的下一个报文段将在确认号字段中包含536。因为TCP只确认该流中至第一个丢失字节为止的字节，所以TCP被称为提供累积确认（cumulative acknowledgment）</li>
<li>主机A在收到第二个报文段（字节536<del>899）之前收到第三个报文段（字节900</del>1000）。因此，第三个报文段失序到达。该微妙的问题是：当主机在一条TCP连接中收到失序报文段时该怎么办？TCP RFC并没有为此明确规定任何规则，而是把这一问题留给实现TCP的编程人员去处理。他们有两个基本的选择：1）接收方立即丢弃失序报文段（如前所述，这可以简化接收方的设计）；2）接收方保留失序的字节，并等待缺少的字节以填补该间隔。显然，后一种选择对网络带宽而言更为有效，是实践中采用的方法</li>
<li>事实上，一条TCP连接的双方均可随机地选择初始序号。这样做可以减少将那些仍在网络中存在的来自两台主机之间先前已终止的连接的报文段，误认为是后来这两台主机之间新建连接所产生的有效报文段的可能性（它碰巧与旧连接使用了相同的端口号）</li>
<li>Telnet：序号和确认号的一个学习案例</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220813201402927.png"></p>
<ul>
<li>对客户到服务器的数据的确认被装载在一个承载服务器到客户的数据的报文段中，这种确认被称为是被捐带（piggybacked）在服务器到客户的数据报文段中</li>
</ul>
<h2 id="往返时间的估计与超时"><a href="#往返时间的估计与超时" class="headerlink" title="往返时间的估计与超时"></a>往返时间的估计与超时</h2><ul>
<li>报文段的样本RTT（表示为SampleRTT）就是从某报文段被发出（即交给IP）到对该报文段的确认被收到之间的时间量。大多数TCP的实现仅在某个时刻做一次SampleRTT测量，而不是为每个发送的报文段测量一个SampleRTT</li>
<li>超时间隔应该大于等于EstimatedRTT，否则，将造成不必要的重传。但是超时间隔也不应该比EstimatedRTT大太多，否则当报文段丢失时，TCP不能很快地重传该报文段，导致数据传输时延大</li>
</ul>
<h2 id="可靠教据传输"><a href="#可靠教据传输" class="headerlink" title="可靠教据传输"></a>可靠教据传输</h2><ul>
<li>因特网的网络层服务（IP服务）是不可靠的。IP不保证数据报的交付，不保证数据报的按序交付，也不保证数据报中数据的完整性。对于IP服务，数据报能够溢出路由器缓存而永远不能到达目的地，数据报也可能是乱序到达，而且数据报中的比特可能损坏（由0变为1或者相反）。由于运输层报文段是被IP数据报携带着在网络中传输的，所以运输层的报文段也会遇到这些问题</li>
<li>TCP在IP不可靠的尽力而为服务之上创建了一种可靠数据传输服务（reliable datatransfer service）。TCP的可靠数据传输服务确保一个进程从其接收缓存中读出的数据流是无损坏、无间隙、非冗余和按序的数据流；即该字节流与连接的另一方端系统发送出的字节流是完全相同</li>
<li>超时触发重传存在的问题之一是超时周期可能相对较长。当一个报文段丢失时，这种长超时周期道使发送方延退重传丢失的分组，因而增加了端到端时延。幸运的是，发送方通常可在超时事件发生之前通过注意所谓冗余ACK来较好地检测到丢包情况。冗余ACK（duplicate ACK）就是再次确认某个报文段的ACK，而发送方先前已经收到对该报文段的确认</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220813202847685.png"></p>
<ul>
<li>发送方经常一个接一个地发送大量的报文段，如果一个报文段丢失，就很可能引起许多一个接一个的冗余ACK。如果TCP发送方接收到对相同数据的3个冗余ACK，它把这当作一种指示，说明跟在这个已被确认过3次的报文段之后的报文段已经丢失。一且收到3个冗余ACK，TCP就执行快速重传（fast retransmit），即在该报文段的定时器过期之前重传丢失的报文段</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220813203210184.png"></p>
<ul>
<li>选择确认（selective acknowledgment），允许TCP接收方有选择地确认失序报文段，而不是累积地确认最后一个正确接收的有序报文段。当将该机制与选择重传机制结合起来使用时（即跳过重传那些已被接收方选择性地确认过的报文段），TCP看起来就很像我们通常的SR协议。因此，TCP的差错恢复机制也许最好被分类为GBN协议与SR协议的混合体</li>
</ul>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><ul>
<li>一条TCP连接的每一侧主机都为该连接设置了接收缓存。当该TCP连接收到正确、按序的字节后，它就将数据放人接收缓存。相关联的应用进程会从该缓存中读取数据，但不必是数据刚一到达就立即读取。事实上，接收方应用也许正忙于其他任务，甚至要过很长时间后才去读取该数据。如果某应用程序读取数据时相对缓慢，而发送方发送得太多、太快，发送的数据就会很容易地使该连接的接收缓存溢出</li>
<li>TCP为它的应用程序提供了流量控制服务（flow-control service）以消除发送方使接收方缓存溢出的可能性。流量控制因此是一个速度匹配服务，即发送方的发送速率与接收方应用程序的读取速率相匹配</li>
<li>TCP发送方也可能因为IP网络的拥塞而被遇制，这种形式的发送方的控制被称为拥塞控制（congestion control），即使流量控制和拥塞控制采取的动作非常相似（对发送方的退制），但是它们显然是针对完全不同的原因而采取的措施</li>
<li>TCP通过让发送方维护一个称为接收窗口（receive window）的变量来提供流量控制。通俗地说，接收窗口用于给发送方一个指示，该接收方还有多少可用的缓存空间。因为TCP是全双工通信，在连接两端的发送方都各自维护一个接收窗口</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220813204011717.png"></p>
<ul>
<li>UDP并不提供流量控制，报文段由于缓存溢出可能在接收方丢失。例如，考虑一下从主机A上的一个进程向主机B上的一个进程发送一系列UDP报文段的情形。对于一个典型的UDP实现，UDP将在一个有限大小的缓存中加上报文段，该缓存在相应套接字（进程的门户）“之前”。进程每次从缓存中读取一个完整的报文段。如果进程从缓存中读取报文段的速度不够快，那么缓存将会溢出，并且将丢失报文段</li>
</ul>
<h2 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h2><ul>
<li>三次握手步骤</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220813211014328.png"></p>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220813211314904.png"></p>
<ul>
<li>参与一条TCP连接的两个进程中的任何一个都能终止该连接。当连接结束后，主机中的“资源”（即缓存和变量）将被释放。假设某客户打算关闭连接，如图3-40所示。客户应用进程发出一个关闭连接命令。这会引起客户TCP向服务器进程发送一个特殊的TCP报文段。这个特殊的报文段让其首部中的一个标志位即FIN比特被设置为1。当服务器接收到该报文段后，就向发送方回送一个确认报文段。然后，服务器发送它自己的终止报文段，其FIN比特被置为1。最后，该客户对这个服务器的终止报文段进行确认。此时，在两台主机上用于该连接的所有资源都被释放了</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220813211728003.png"></p>
<ul>
<li>客户端经历的TCP状态序列</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220813213120677.png"></p>
<ul>
<li>服务器经历的TCP状态序列</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220813213212677.png"></p>
<ul>
<li>当一台主机接收到一个TCP报文段，其端口号或源IP地址与该主机上进行中的套接字都不匹配。例如，假如一台主机接收了具有目的端口80的一个TCP SYN分组，但该主机在端口80不接受连接（即它不在端口80上运行Web服务器）。则该主机将向源发送一个特殊重置报文段。该TCP报文段将RST标志位置为1。因此，当主机发送一个重置报文段时，它告诉该源“我没有那个报文段的套接字。请不要再发送该报文段了”。当一台主机接收一个UDP分组，它的目的端口与进行中的UDP套接字不匹配，该主机发送一个特殊的ICMP数据报</li>
<li>nmap端口扫描工具工作原理，为了探索目标主机上的一个特定的TCP端口，如端口6789，nmap将对那台主机的目的端口6789发送一个特殊的TCP SYN报文段。有3种可能的输出：</li>
</ul>
<blockquote>
<p>源主机从目标主机接收到一个TCP SYN ACK报文段。因为这意味着在目标主机上一个应用程序使用TCP端口6789运行，nmap返回“打开”</p>
<p>源主机从目标主机接收到一个TCP RST报文段。这意味着该SYN报文段到达了目标主机，但目标主机没有运行一个使用TCP端口6789的应用程序。但攻击者至少知道发向该主机端口6789的报文段没有被源和目标主机之间的任何防火墙所阻挡</p>
<p>源什么也没有收到。这很可能表明该SYN报文段被中间的防火墙所阻挡，无法到达目标主机</p>
</blockquote>
<h1 id="拥塞控制原理"><a href="#拥塞控制原理" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h1><h2 id="拥塞原因与代价"><a href="#拥塞原因与代价" class="headerlink" title="拥塞原因与代价"></a>拥塞原因与代价</h2><ul>
<li>情况1：两个发送方和一台具有无穷大缓存的路由器，在这种（极端）理想化的情况中，拥塞网络的一种代价，即当分组的到达速率接近链路容量时，分组经历巨大的排队时延</li>
<li>情况2：两个发送方和一台具有有限缓存的路由器，另一种网络拥塞的代价，即发送方必须执行重传以补偿因为缓存溢出而丢弃（丢失）的分组。而且，发送方在遇到大时延时所进行的不必要重传会引起路由器利用其链路带宽来转发不必要的分组副本</li>
<li>情况3：4个发送方和具有有限缓存的多台路由器及多跳路径，拥塞而丢弄分组的另一种代价，即当一个分组沿一条路径被丢弃时，每个上游路由器用于转发该分组到丢弃该分组而使用的传输容量最终被浪费掉了</li>
</ul>
<h2 id="拥塞控制方法"><a href="#拥塞控制方法" class="headerlink" title="拥塞控制方法"></a>拥塞控制方法</h2><ul>
<li>可根据网络层是否为运输层拥塞控制提供了显式帮助，来区分拥塞控制方法</li>
<li>端到端拥塞控制。在端到端拥塞控制方法中，网络层没有为运输层拥塞控制提供显式支持。即使网络中存在拥塞，端系统也必须通过对网络行为的观察（如分组丢失与时延）来推断之。TCP采用端到端的方法解决拥塞控制，因为IP层不会向端系统提供有关网络拥塞的反馈信息。TCP报文段的丢失（通过超时或3次冗余确认而得知）被认为是网络拥塞的一个迹象，TCP会相应地减小其窗口长度。关于TCP拥塞控制的一些最新建议，即使用增加的往返时延值作为网络拥塞程度增加的指示</li>
<li>网络辅助的拥塞控制。在网络辅助的拥塞控制中，路由器向发送方提供关于网络中拥塞状态的显式反馈信息。这种反馈可以简单地用一个比特来指示链路中的拥塞情况。例如，在ATM可用比特率（Available BiteRate，ABR）拥塞控制中，路由器显式地通知发送方它（路由器）能在输出链路上支持的最大主机发送速率</li>
</ul>
<h1 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h1><ul>
<li>TCP所采用的方法是让每一个发送方根据所感知到的网络拥塞程度来限制其能向连接发送流量的速率。如果一个TCP发送方感知从它到目的地之间的路径上没什么拥塞，则TCP发送方增加其发送速率；如果发送方感知沿着该路径有拥塞，则发送方就会降低其发送速率</li>
<li>TCP发送方是如何限制向其连接发送流量的。TCP连接的每一端都是由一个接收缓存、一个发送缓存和几个变量（LastByteRead、rwnd等）组成。运行在发送方的TCP拥塞控制机制跟踪一个额外的变量，即拥赛窗口（congestion window）。拥塞窗口表示为cwnd，它对一个TCP发送方能向网络中发送流量的速率进行了限制。特别是，在一个发送方中未被确认的数据量不会超过cwnd与rwnd中的最小值</li>
<li>TCP发送方是如何感知在它与日的地之间的路径上出现了拥塞的。将一个TCP发送方的“丢包事件”定义为：要么出现超时，要么收到来自接收方的3个冗余ACK。当出现过度的拥塞时，在沿着这条路径上的一台（或多台）路由器的缓存会溢出，引起一个数据报（包含一个TCP报文段）被丢弃。丢弃的数据报接着会引起发送方的丢包事件（要么超时或收到3个冗余ACK），发送方就认为在发送方到接收方的路径上出现了拥塞的指示</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220813215808572.png"></p>
<ul>
<li>TCP拥塞控制算法：慢启动、拥塞避免、快速恢复</li>
<li>慢启动</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220813220017963.png"></p>
<ul>
<li>拥塞避免：一且进人拥塞避免状态，cwnd的值大约是上次遇到拥塞时的值的一半，即距离拥塞可能并不遥远！因此，TCP无法每过一个RTT再将cwnd的值翻番，而是采用了一种较为保守的方法，每个RTT只将cwnd的值增加一个MSS</li>
<li>快速恢复：在快速恢复中，对于引起TCP进人快速恢复状态的缺失报文段，对收到的每个冗余的ACK，cwnd的值增加一个MSS。最终，当对丢失报文段的一个ACK到达时，TCP在降低cwnd后进人拥塞避免状态。如果出现超时事件，快速恢复在执行如同在慢启动和拥塞避免中相同的动作后，迁移到慢启动状态：当丢包事件出现时，cwnd的值被设置为1个MSS，并且ssthresh的值设置为cwnd值的一半</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220813220322352.png"></p>
<ul>
<li>忽略一条连接开始时初始的慢启动阶段，假定丢包由3个冗余的ACK而不是超时指示，TCP的拥塞控制是：每个RTT内cwnd线性（加性）增加1MSS，然后出现3个冗余ACK事件时cwnd减半（乘性减）。因此，TCP拥塞控制常常被称为加性增、乘性减（Additive-Increase，Multiplicative-Decrease AIMD）拥塞控制方式</li>
</ul>
<h2 id="公平性"><a href="#公平性" class="headerlink" title="公平性"></a>公平性</h2><ul>
<li>考虑K条TCP连接，每条都有不同的端到端路径，但是都经过一段传输速率为Rbps的瓶颈链路。（所谓瓶频链路，是指对于每条连接，沿着该连接路径上的所有其他段链路都不拥塞，而且与该瓶颈链路的传输容量相比，它们都有充足的传输容量。）假设每条连接都在传输一个大文件，而且无UDP流量通过该段瓶颈链路。如果每条连接的平均传输速率接近R/K，即每条连接都得到相同份额的链路带宽，则认为该拥塞控制机制是公平的</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220813220833181.png"></p>
<ul>
<li>公平性和UDP：TCP拥塞控制是通过拥塞窗口机制来调节一个应用程序的传输速率的。许多多媒体应用如因特网电话和视频会议，经常就因为这种特定原因而不在TCP上运行，因为它们不想其传输速率被拒制，即使在网络非常拥塞的情况下。相反，这些应用宁可在UDP上运行，UDP是没有内置的拥塞控制的。当运行在UDP上时，这些应用能够以恒定的速率将其音频和视频数据注入网络之中并且偶尔会丢失分组，而不愿在拥塞时将其发送速率降至“公平”级别并且不丢失任何分组。从TCP的观点来看，运行在UDP上的多媒体应用是不公平的，因为它们不与其他连接合作，也不适时地调整其传输速率。因为TCP拥塞控制在面临拥塞增加（丢包）时，将降低其传输速率，而UDP源则不必这样做，UDP源有可能压制TCP流量</li>
<li>公平性和并行TCP连接：即使能够追使UDP流量具有公平的行为，但公平性问题仍然没有完全解决。这是因为没有什么办法阻止基于TCP的应用使用多个并行连接。例如，Web浏览器通常使用多个并行TCP连接来传送一个Web页中的多个对象。（多条连接的确切数目可以在多数浏览器中进行配置。）当一个应用使用多条并行连接时，它占用了一条拥塞链路中较大比例的带宽。举例来说，考虑一段速率为R且支持9个在线客户－服务器应用的链路，每个应用使用一条TCP连接。如果一个新的应用加入进来，也使用一条TCP连接，则每个应用得到差不多相同的传输速率R/10。但是如果这个新的应用这次使用了11个并行TCP连接，则这个新应用就不公平地分到超过R/2的带宽</li>
</ul>
<h2 id="明确拥塞通告：网络辅助拥塞控制"><a href="#明确拥塞通告：网络辅助拥塞控制" class="headerlink" title="明确拥塞通告：网络辅助拥塞控制"></a>明确拥塞通告：网络辅助拥塞控制</h2><ul>
<li>对于IP和TCP的扩展方案，该方案允许网络明确向TCP发送方和接收方发出拥塞信号。这种形式的网络辅助拥塞控制称为明确拥塞通告（Explicit Congestion Notification，ECN）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220813221439354.png"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Chap04_网络层_数据平面</title>
    <url>/2022/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Chap04_%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220817233335268.png"></p>
<h1 id="网络层概述"><a href="#网络层概述" class="headerlink" title="网络层概述"></a>网络层概述</h1><ul>
<li>网络层能够被分解为两个相互作用的部分，即数据平面和控制平面</li>
<li>网络层的数据平面功能，即网络层中每台路由器的功能，该数据平面功能决定到达路由器输人链路之一的数据报（即网络层的分组）如何转发到该路由器的输出链路之一。涉及传统的IP转发（其中转发基于数据报的目的地址）和通用的转发（其中可以使用数据报首部中的几个不同域的值执行转发和其他功能）</li>
<li>网络层的控制平面功能，即网络范围的逻辑，该控制平面功能控制数据报沿着从源主机到目的主机的端到端路径中路由器之间的路由方式</li>
</ul>
<h2 id="转发和路由选择：数据平面和控制平面"><a href="#转发和路由选择：数据平面和控制平面" class="headerlink" title="转发和路由选择：数据平面和控制平面"></a>转发和路由选择：数据平面和控制平面</h2><ul>
<li>网络层的作用从表面上看极为简单，即将分组从一台发送主机移动到一台接收主机。为此，需要使用两种重要的网络层功能：</li>
</ul>
<blockquote>
<p>转发。当一个分组到达某路由器的一条输入链路时，该路由器必须将该分组移动到适当的输出链路</p>
<p>路由选择。当分组从发送方流向接收方时，网络层必须决定这些分组所采用的路由或路径。计算这些路径的算法被称为路由选择算法（routing algorithm）。路由选择在网络层的控制平面中实现</p>
</blockquote>
<ul>
<li>转发表：每台网络路由器中有一个关键元素是它的转发表（forwarding table）。路由器检查到达分组首部的一个或多个字段值，进而使用这些首部值在其转发表中索引，通过这种方法来转发分组。这些值对应存储在转发表项中的值，指出了该分组将被转发的路由器的输出链路接口。例如在图4-2中，一个首部字段值为0111的分组到达路由器。该路由器在它的转发表中索引，并确定该分组的输出链路接口是接口2。该路由器则在内部将该分组转发到接口2。转发是由网络层的数据平面执行的主要功能</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220817214048823.png"></p>
<ul>
<li>控制平面，传统的方法：路由选择算法运行在每台路由器中，并且在每台路由器中都包含转发和路由选择两种功能</li>
<li>控制平面，SDN方法：图4-3显示了从路由器物理上分离的另一种方法，远程控制器计算和分发转发表以供每台路由器所使用。注意到图4-2和图4-3的数据平面组件是相同的。而在图4-3中，控制平面路由选择功能与物理的路由器是分离的，即路由选择设备仅执行转发，而远程控制器计算并分发转发表。远程控制器可能实现在具有高可靠性和元余的远程数据中心中，并可能由ISP或某些第三方管理</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220817214543891.png"></p>
<h2 id="网络服务模型"><a href="#网络服务模型" class="headerlink" title="网络服务模型"></a>网络服务模型</h2><ul>
<li>网络服务模型（network service model）定义了分组在发送与接收端系统之间的端到端运输特性。这些服务可能包括：</li>
</ul>
<blockquote>
<p>确保交付。该服务确保分组将最终到达目的地</p>
<p>具有时延上界的确保交付。该服务不仅确保分组的交付，而且在特定的主机到主机时延上界内（例如在100ms内）交付</p>
<p>有序分组交付。该服务确保分组以它们发送的顺序到达目的地</p>
<p>确保最小带宽。这种网络层服务模仿在发送和接收主机之间一条特定比特率（例如1Mbps）的传输链路的行为。只要发送主机以低于特定比特率的速率传输比特（作为分组的组成部分），则所有分组最终会交付到目的主机</p>
<p>安全性。网络层能够在源加密所有数据报并在目的地解密这些分组，从而对所有运输层报文段提供机密性</p>
</blockquote>
<ul>
<li>因特网的网络层提供了单一的服务，称为尽力而为服务（best-effort service）。使用尽力而为服务，传送的分组既不能保证以它们发送的顺序被接收，也不能保证它们最终交付；既不能保证端到端时延，也不能保证有最小的带宽。尽力而为服务看起来是根本无服务的一种委婉说法，即一个没有向目的地交付分组的网络也符合尽力而为交付服务的定义</li>
<li>分组交换机：是指一台通用分组交换设备，它根据分组首部字段中的值，从输人链路接口到输出链路接口转移分组。某些分组交换机称为链路层交换机（link-layer switch），基于链路层帧中的字段值做出转发决定，这些交换机因此被称为链路层（第2层）设备。其他分组交换机称为路由器（router），基于网络层数据报中的首部字段值做出转发决定。路由器因此是网络层（第3层）设备</li>
</ul>
<h1 id="路由器工作原理"><a href="#路由器工作原理" class="headerlink" title="路由器工作原理"></a>路由器工作原理</h1><ul>
<li>通用路由器体系结构</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220817215451148.png"></p>
<h2 id="输入端口处理和基于目的转发"><a href="#输入端口处理和基于目的转发" class="headerlink" title="输入端口处理和基于目的转发"></a>输入端口处理和基于目的转发</h2><ul>
<li>输人端口的线路端接功能与链路层处理实现了用于各个输入链路的物理层和链路层。在输入端口中执行的查找对于路由器运行是至关重要的。正是在这个地方，路由器使用转发表来查找输出端口，使得到达的分组能经过交换结构转发到该输出端口。转发表是由路由选择处理器计算和更新的（使用路由选择协议与其他网络路由器中的路由选择处理器进行交互），或者转发表接收来自远程SDN控制器的内容。转发决策能在每个输入端口本地做出，无须基于每个分组调用集中式路由选择处理器，因此避免了集中式处理的瓶颈</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220817215943732.png"></p>
<ul>
<li>路由器用分组目的地址的前缀（prefix）与该表中的表项进行匹配；如果存在一个匹配项，则路由器向与该匹配项相关联的链路转发分组</li>
<li>当有多个匹配时，该路由器使用最长前缀匹配规则（longest prefx matchig rule）；即在该表中寻找最长的匹配项，并向与最长前级匹配相关联的链路接口转发分组</li>
<li>一旦通过查找确定了某分组的输出端口，则该分组就能够发送进入交换结构。在某些设计中，如果来自其他输入端口的分组当前正在使用该交换结构，一个分组可能会在进入交换结构时被暂时阻塞。因此，一个被阻塞的分组必须要在输入端口处排队，并等待稍后被及时调度以通过交换结构</li>
<li>分组（位于输入端口与输出端口中）的阻塞、排队与调度。尽管“查找”在输入端口处理中可认为是最为重要的动作，但必须采取许多其他动作：必须出现物理层和链路层处理；必须检查分组的版本号、检验和以及寿命字段，并且重写后两个字段；必须更新用于网络管理的计数器（如接收到的IP数据报的数目）</li>
</ul>
<h2 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h2><ul>
<li>交换结构位于一台路由器的核心部位，因为正是通过这种交换结构，分组才能实际地从一个输入端口交换（即转发）到一个输出端口中。交换可以用许多方式完成</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220817220911395.png"></p>
<h2 id="输出端口处理"><a href="#输出端口处理" class="headerlink" title="输出端口处理"></a>输出端口处理</h2><ul>
<li>输出端口处理取出已经存放在输出端口内存中的分组并将其发送到输出链路上。这包括选择和取出排队的分组进行传输，执行所需的链路层和物理层传输功能</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220817221105954.png"></p>
<h2 id="何处出现排队"><a href="#何处出现排队" class="headerlink" title="何处出现排队"></a>何处出现排队</h2><ul>
<li>在输入端口和输出端口处都可以形成分组队列，排队的位置和程度（或者在输入端口排队，或者在输出端口排队）将取决于流量负载、交换结构的相对速率和线路速率。因为随着这些队列的增长，路由器的缓存空间最终将会耗尽，并且当无内存可用于存储到达的分组时将会出现丢包（packet loss）。分组“在网络中丢失”或“被路由器丢弃”。正是在一台路由器的这些队列中，这些分组被实际丢弃或丢失</li>
</ul>
<h2 id="分组调度"><a href="#分组调度" class="headerlink" title="分组调度"></a>分组调度</h2><ul>
<li>先进先出</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220817221419817.png"></p>
<ul>
<li>优先权排队</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220817221533352.png"></p>
<ul>
<li>循环和加权公平排队</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220817221802656.png"></p>
<h1 id="网际协议：IPv4、寻址、IPv6及其他"><a href="#网际协议：IPv4、寻址、IPv6及其他" class="headerlink" title="网际协议：IPv4、寻址、IPv6及其他"></a>网际协议：IPv4、寻址、IPv6及其他</h1><h2 id="IPv4数据报格式"><a href="#IPv4数据报格式" class="headerlink" title="IPv4数据报格式"></a>IPv4数据报格式</h2><ul>
<li>网络层分组被称为数据报</li>
<li>IPv4数据报格式</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220817222601972.png"></p>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220817222724112.png"></p>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220817222806433.png"></p>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220817223027242.png"></p>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220817223118882.png"></p>
<ul>
<li>IP数据报有总长为20字节的首部（假设无选项）。如果数据报承载一个TCP报文段，则每个（无分片的）数据报共承载了总长40字节的首部（20字节的IP首部加上20字节的TCP首部）以及应用层报文</li>
</ul>
<h2 id="IPv4数据报分片"><a href="#IPv4数据报分片" class="headerlink" title="IPv4数据报分片"></a>IPv4数据报分片</h2><ul>
<li>并不是所有链路层协议都能承载相同长度的网络层分组。有的协议能承载大数据报，而有的协议只能承载小分组。例如，以太网帧能够承载不超过1500字节的数据，而某些广域网链路的帧可承载不超过576字节的数据。一个链路层帧能承载的最大数据量叫作最大传送单元（Maximum Transmission Unit，MTU）</li>
<li>因为每个IP数据报封装在链路层帧中从一台路由器传输到下一台路由器，故链路层协议的MTU严格地限制着IP数据报的长度。对IP数据报长度具有严格限制并不是主要问题。问题在于在发送方与目的地路径上的每段链路可能使用不同的链路层协议，且每种协议可能具有不同的MTU</li>
<li>想象一台互联几条链路的路由器，且每条链路运行具有不同MTU的链路层协议。假定从某条链路收到一个IP数据报，通过检查转发表确定出链路，并且该条出链路的MTU比该IP数据报的长度要小。如何将这个过大的IP分组挤进链路层帧的有效载荷字段呢？解决该问题的方法是将IP数据报中的数据分片成两个或更多个较小的IP数据报，用单独的链路层顿封装这些较小的IP数据报，然后通过输出链路发送这些帧。每个这些较小的数据报都称为片（fragment）</li>
<li>片在其到达目的地运输层以前需要重新组装。TCP与UDP的确都希望从网络层收到完整的、未分片的报文。IPv4的设计者感到在路由器中重新组装数据报会给协议带来相当大的复杂性并且影响路由器的性能。为坚持网络内核保持简单的原则，IPv4的设计者决定将数据报的重新组装工作放到端系统中，而不是放到网络路由器中</li>
<li>当一台目的主机从相同源收到一系列数据报时，它需要确定这些数据报中的某些是否是一些原来较大的数据报的片。如果某些数据报是这些片的话，则它必须进一步确定何时收到了最后一片，并且如何将这些接收到的片拼接到一起以形成初始的数据报。为了让目的主机执行这些重新组装任务，IPv4的设计者将标识、标志和片偏移字段放在IP数据报首部中。当生成一个数据报时，发送主机在为该数据报设置源和目的地址的同时贴上标识号。发送主机通常将它发送的每个数据报的标识号加1。当某路由器需要对一个数据报分片时，形成的每个数据报（即片）具有初始数据报的源地址、目的地址与标识号。当目的地从同一发送主机收到一系列数据报时，它能够检查数据报的标识号以确定哪些数据报实际上是同一较大数据报的片。由于IP是一种不可靠的服务，一个或多个片可能永远到达不了自的地。因为这种原因，为了让目的主机绝对地相信它已收到了初始数据报的最后一个片，最后一个片的标志比特被设为0，而所有其他片的标志比特被设为1。另外，为了让目的主机确定是否丢失了一个片（且能按正确的顺序重新组装片），使用偏移字段指定该片应放在初始IP数据报的哪个位置</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220817224120029.png"></p>
<h2 id="IPv4编址"><a href="#IPv4编址" class="headerlink" title="IPv4编址"></a>IPv4编址</h2><ul>
<li>主机与物理链路之间的边界叫作接口（interface）。考虑一台路由器及其接口。因为路由器的任务是从链路上接收数据报并从某些其他链路转发出去，路由器必须拥有两条或更多条链路与它连接。路由器与它的任意一条链路之间的边界也叫作接口</li>
<li>一台路由器因此有多个接口，每个接口有其链路。因为每台主机与路由器都能发送和接收IP数据报，IP要求每台主机和路由器接口拥有自己的IP地址。因此，从技术上讲，一个IP地址与一个接口相关联，而不是与包括该接口的主机或路由器相关联</li>
<li>每个IP地址长度为32比特（等价为4字节），因此总共有2^32个（或大约40亿个）可能的IP地址</li>
<li>在全球因特网中的每台主机和路由器上的每个接口，都必须有一个全球唯一的IP地址（在NAT后面的接口除外）。然而，这些地址不能随意地自由选择。一个接口的IP地址的一部分需要由其连接的子网来决定</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220817225022177.png"></p>
<ul>
<li>用IP的术语来说，互联这3个主机接口与1个路由器接口的网络形成一个子网</li>
<li>一个子网的IP定义并不局限于连接多台主机到一个路由器接口的以太网段</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220817225415572.png"></p>
<ul>
<li>因特网的地址分配策略被称为无类别域间路由选择（Classless Interdomain Routing，CIDR）。CIDR将子网寻址的概念一般化了。当使用子网寻址时，32比特的IP地址被划分为两部分，并且也具有点分十进制数形式a.b.c.d/x，其中x指示了地址的第一部分中的比特数</li>
<li>形式为a.b.c.d/x的地址的x最高比特构成了IP地址的网络部分，并且经常被称为该地址的前缀（prefix）（或网络前缀）。一个组织通常被分配一块连续的地址，即具有相同前级的一段地址。在这种情况下，该组织内部的设备的IP地址将共享共同的前缀</li>
<li>在CIDR被采用之前，IP地址的网络部分被限制为长度为8、16或24比特，这是一种称为分类编址（classful addressing）的编址方案，这是因为具有8、16和24比特子网地址的子网分别被称为A、B和C类网络</li>
<li>IP广播地址255.255.255.255，当一台主机发出一个目的地址为255.255.255.255的数据报时，该报文会交付给同一个网络中的所有主机。路由器也会有选择地向邻近的子网转发该报文（虽然它们通常不这样做）</li>
<li>获取一块子网地址</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220817230600047.png"></p>
<ul>
<li>获取主机地址：动态主机配置协议，DHCP允许主机自动获取（被分配）一个IP地址。网络管理员能够配置DHCP，以使某给定主机每次与网络连接时能得到一个相同的IP地址，或者某主机将被分配一个临时的IP地址（temporary IP address），每次与网络连接时该地址也许是不同的。除了主机IP地址分配外，DHCP还允许一台主机得知其他信息，例如它的子网掩码、它的第一跳路由器地址（常称为默认网关）与它的本地DNS服务器的地址</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220817230923497.png"></p>
<ul>
<li>DHCP协议4个步骤</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220817231028010.png"></p>
<h2 id="网络地址转换"><a href="#网络地址转换" class="headerlink" title="网络地址转换"></a>网络地址转换</h2><ul>
<li>具有专用地址的地域是指其地址仅对该网络中的设备有意义的网络。考虑有数十万家庭网络这样的事实，许多使用了相同的地址空间10.0.0.0/24。在一个给定家庭网络中的设备能够使用10.0.0.0/24编址彼此发送分组。然而，转发到家庭网络之外进入更大的全球因特网的分组显然不能使用这些地址（或作为源地址，或作为目的地址），因为有数十万的网络使用着这块地址。这就是说，10.0.0.0/24地址仅在给定的网络中才有意义</li>
<li>NAT使能路由器对于外部世界来说甚至不像一台路由器。相反NAT路由器对外界的行为就如同一个具有单一IP地址的单一设备。图4-25中，所有离开家庭路由器流向更大因特网的报文都拥有一个源IP地址138.76.29.7，且所有进入家庭的报文都拥有同一个目的IP地址138.76.29.7。从本质上讲，NAT使能路由器对外界隐藏了家庭网络的细节。（家庭网络计算机是从哪儿得到其地址，路由器又是从哪儿得到它的单一IP地址的。在通常的情况下，答案是相同的，即DHCP！路由器从ISP的DHCP服务器得到它的地址，并且路由器运行一个DHCP服务器，为位于NAT-DHCP路由器控制的家庭网络地址空间中的计算机提供地址。）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220817231856490.png"></p>
<h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><ul>
<li>IPv6数据报格式</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220817232318037.png"></p>
<ul>
<li>扩大的地址容量。IPv6将IP地址长度从32比特增加到128比特，16字节</li>
<li>分片/重新组装。IPv6不允许在中间路由器上进行分片与重新组装。这种操作只能在源与目的地执行。如果路由器收到的IP6数据报因太大而不能转发到出链路上的话，则路由器只需丢掉该数据报，并向发送方发回一个“分组太大”的ICMP差错报文即可。于是发送方能够使用较小长度的IP数据报重发数据。分片与重新组装是一个耗时的操作，将该功能从路由器中删除并放到端系统中，大大加快了网络中的IP转发速度</li>
<li>首部检验和。因为因特网层中的运输层（如TCP与UDP）和数据链路层（如以太网）协议执行了检验操作，IP设计者大概觉得在网络层中具有该项功能实属多余，所以将其去除。再次强调的是，快速处理IP分组是关注的重点</li>
<li>广泛采用的IPV4到IPV6迁移的方法包括建隧道（tunneling）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220817233045709.png"></p>
<h1 id="通用转发和SDN"><a href="#通用转发和SDN" class="headerlink" title="通用转发和SDN"></a>通用转发和SDN</h1><ul>
<li>第二层交换机和第三层路由器等中间盒的剧增，而且每种都有自己特殊的硬件、软件和管理界面，无疑给许多网络操作员带来了十分头疼的大麻烦</li>
<li>基于目的地转发的特征总结为两个步骤：查找目的IP地址（“匹配”），然后将分组发送到有特定输出端口的交换结构（“动作”）。考虑一种更有意义的通用“匹配加动作”范式，其中能够对协议栈的多个首部字段进行“匹配”，这些首部字段是与不同层次的不同协议相关联的。“动作”能够包括：将分组转发到一个或多个输出端口（就像在基于目的地转发中一样），跨越多个通向服务的离开接口进行负载均衡分组（就像在负载均衡中一样），重写首部值（就像在NAT中一样），有意识地阻挡/丢弃某个分组（就像在防火墙中一样），为进一步处理和动作而向某个特定的服务器发送一个分组（就像在DPI一样），等等</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220817233335267.png"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Chap05_网络层_控制平面</title>
    <url>/2022/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Chap05_%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220822230335210.png"></p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li>控制平面作为一种网络范围的逻辑，不仅控制沿着从源主机到目的主机的端到端路径间的路由器如何转发数据报，而且控制网络层组件和服务如何配置和管理</li>
<li>转发表（在基于目的地转发的场景中）和流表（在通用转发的场景中）是链接网络层的数据平面和控制平面的首要元素。在通用转发的场景下，所采取的动作不仅包括转发一个分组到达路由器的每个输出端口，而且能够丢弃一个分组、复制一个分组和/或重写第2、3或4层分组首部字段</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220822230316731.png"></p>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220822230335209.png"></p>
<h1 id="路由选择算法"><a href="#路由选择算法" class="headerlink" title="路由选择算法"></a>路由选择算法</h1><ul>
<li>一般而言，路由选择算法的一种分类方式是根据该算法是集中式还是分散式来划分</li>
<li>集中式路由选择算法（centralized routing algorithm）用完整的、全局性的网络知识计算出从源到目的地之间的最低开销路径。也就是说，该算法以所有节点之间的连通性及所有链路的开销为输入。这就要求该算法在真正开始计算以前，要以某种方式获得这些信息。计算本身可在某个场点进行，或在每台路由器的路由选择组件中重复进行。然而，这里的主要区别在于，集中式算法具有关于连通性和链路开销方面的完整信息。具有全局状态信息的算法常被称作链路状态（Link State，LS）算法，因为该算法必须知道网络中每条链路的开销</li>
<li>分散式路由选择算法（decentralized routing algorithm）中，路由器以送代、分布式的方式计算出最低开销路径。没有节点拥有关于所有网络链路开销的完整信息。相反，每个节点仅有与其直接相连链路的开销知识即可开始工作。然后，通过迭代计算过程以及与相邻节点的信息交换，一个节点逐渐计算出到达某目的节点或一组目的节点的最低开销路径。比如距离向量（Distance-Vector，DV）算法的分散式路由选择算法。之所以叫作DV算法，是因为每个节点维护到网络中所有其他节点的开销（距离）估计的向量。这种分散式算法，通过相邻路由器之间的交互式报文交换，也许更为天然地适合那些路由器直接交互的控制平面</li>
<li>路由选择算法的第二种广义分类方式是根据算法是静态的还是动态的进行分类。在静态路由选择算法（static routing algorithm）中，路由随时间的变化非常缓慢，通常是人工进行调整（如人为手工编辑一条链路开销）。动态路由选择算法（dynamic routing algorithm）随着网络流量负载或拓扑发生变化而改变路由选择路径。一个动态算法可周期性地运行或直接响应拓扑或链路开销的变化而运行。虽然动态算法易于对网络的变化做出反应，但也更容易受诸如路由选择循环、路由振荡之类问题的影响</li>
</ul>
<h1 id="因特网中自洽系统内部的路由选择：OSPF"><a href="#因特网中自洽系统内部的路由选择：OSPF" class="headerlink" title="因特网中自洽系统内部的路由选择：OSPF"></a>因特网中自洽系统内部的路由选择：OSPF</h1><ul>
<li>我们将网络只看作一个互联路由器的集合。从所有路由器执行相同的路由选择算法以计算穿越整个网络的路由选择路径的意义上来说，一台路由器很难同另一台路由器区别开来。在实践中，该模型和这种一组执行同样路由选择算法的同质路由器集合的观点有一点简单化，有以下两个重要原因：</li>
</ul>
<blockquote>
<p>规模。随着路由器数目变得很大，涉及路由选择信息的通信、计算和存储的开销将高得不可实现。当今的因特网由数亿台主机组成。在这些主机中存储的路由选择信息显然需要巨大容量的内存。在所有路由器之间广播连通性和链路开销更新所要求的负担将是巨大的！在如此大量的路由器中选代的距离向量算法将肯定永远无法收敛！显然，必须采取一些措施以减少像因特网这种大型网络中的路由计算的复杂性</p>
<p>管理自治。因特网是ISP的网络，其中每个ISP都有它自已的路由器网络。ISP通常希望按自己的意愿运行路由器（如在自己的网络中运行它所选择的某种路由选择算法），或对外部隐藏其网络的内部组织面貌。在理想情况下，一个组织应当能够按自己的愿望运行和管理其网络，还要能将其网络与其他外部网络连接起来</p>
</blockquote>
<ul>
<li>这两个问题都可以通过将路由器组织进自治系统（Autonomous System，AS）来解决，其中每个AS由一组通常处在相同管理控制下的路由器组成。通常在一个ISP中的路由器以及互联它们的链路构成一个AS。然而，某些ISP将它们的网络划分为多个AS。特别是，某些一级ISP在其整个网络中使用一个庞大的AS，而其他ISP则将它们的ISP拆分为数十个互联的AS。一个自治系统由其全局唯一的AS号（ASN）所标识。就像IP地址那样，AS号由ICANN区域注册机构所分配</li>
<li>开放最短路优先（OSPF）：OSPF是一种链路状态协议，它使用洪泛链路状态信息和Dijkstra最低开销路径算法。使用OSPF，一台路由器构建了一幅关于整个自治系统的完整拓扑图（即一幅图）。于是，每台路由器在本地运行Dijkstra的最短路径算法，以确定一个以自身为根节点到所有子网的最短路径树</li>
</ul>
<h1 id="ISP之间的路由选择：BGP"><a href="#ISP之间的路由选择：BGP" class="headerlink" title="ISP之间的路由选择：BGP"></a>ISP之间的路由选择：BGP</h1><ul>
<li>OSPF是一个AS内部路由选择协议。当在相同AS内的源和目的地之间进行分组选路时，分组遵循的路径完全由AS内路由选择协议所决定。然而，当分组跨越多个AS进行路由时，需要一个自治系统间路由选择协议（inter-autonomous system routing protocol）。因为AS间路由选择协议涉及多个AS之间的协调，所以AS通信必须运行相同的AS间路由选择协议。在因特网中，所有的AS运行相同的AS间路由选择协议，称为边界网关协议（BroderGatewayProtocol，BGP）</li>
<li>BGP协议将因特网中数以千计的ISP黏合起来</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Chap06_链路层和局域网</title>
    <url>/2022/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Chap06_%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220824230011981.png"></p>
<h1 id="链路层概述"><a href="#链路层概述" class="headerlink" title="链路层概述"></a>链路层概述</h1><h2 id="链路层提供的服务"><a href="#链路层提供的服务" class="headerlink" title="链路层提供的服务"></a>链路层提供的服务</h2><ul>
<li>任一链路层的基本服务都是将数据报通过单一通信链路从一个节点移动到相邻节点，但所提供的服务细节能够随着链路层协议的不同而变化。链路层协议能够提供的可能服务包括：</li>
</ul>
<blockquote>
<p>成帧（framing）。在每个网络层数据报经链路传送之前，几乎所有的链路层协议都要将其用链路层帧封装起来。一个帧由一个数据字段和若干首部字段组成，其中网络层数据报就插在数据字段中。帧的结构由链路层协议规定</p>
<p>链路接入。媒体访问控制（Medium Access Control，MAC）协议规定了帧在链路上传输的规则。对于在链路的一端仅有一个发送方、链路的另一端仅有一个接收方的点对点链路，MAC协议比较简单（或者不存在），即无论何时链路空闲，发送方都能够发送帧。当多个节点共享单个广播链路时，即所谓多路访问问题。MAC协议用于协调多个节点的帧传输</p>
<p>可靠交付。当链路层协议提供可靠交付服务时，它保证无差错地经链路层移动每个网络层数据报。某些运输层协议（例如TCP）也提供可靠交付服务。与运输层可靠交付服务类似，链路层的可靠交付服务通常是通过确认和重传取得的。链路层可靠交付服务通常用于易于产生高差错率的链路，例如无线链路，其目的是本地（也就是在差错发生的链路上）纠正一个差错，而不是通过运输层或应用层协议迫使进行端到端的数据重传。然而，对于低比特差错的链路，包括光纤、同轴电缆和许多双绞铜线链路，链路层可靠交付可能会被认为是一种不必要的开销。由于这个原因，许多有线的链路层协议不提供可靠交付服务</p>
<p>差错检测和纠正。当帧中的一个比特作为1传输时，接收方节点中的链路层硬件可能不正确地将其判断为0，反之亦然。这种比特差错是由信号衰减和电磁噪声导致的。因为没有必要转发一个有差错的数据报，所以许多链路层协议提供一种机制来检测这样的比特差错。通过让发送节点在帧中包括差错检测比特，让接收节点进行差错检查，以此来完成这项工作。差错纠正类似于差错检测，区别在于接收方不仅能检测帧中出现的比特差错，而且能够准确地确定帧中的差错出现的位置（并因此纠正这些差错）</p>
</blockquote>
<h2 id="链路层在何处实现"><a href="#链路层在何处实现" class="headerlink" title="链路层在何处实现"></a>链路层在何处实现</h2><ul>
<li>链路层的主体部分是在网络适配器（network adapter）中实现的，网络适配器有时也称为网络接口卡（Network Interface Card，NIC）。位于网络适配器核心的是链路层控制器，该控制器通常是一个实现了许多链路层服务（成帧、链路接入、差错检测等）的专用芯片。因此，链路层控制器的许多功能是用硬件实现的</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220824212959705.png"></p>
<h1 id="差错检测和纠正技术"><a href="#差错检测和纠正技术" class="headerlink" title="差错检测和纠正技术"></a>差错检测和纠正技术</h1><ul>
<li>比特级差错检测和纠正，即对从一个节点发送到另一个物理上连接的邻近节点的链路层中的比特损伤进行检测和纠正，它们通常是链路层提供的两种服务</li>
<li>传输数据中检测差错的3种技术：奇偶校验（它用来描述差错检测和纠正背后隐含的基本思想）、检验和方法（它通常更多地应用于运输层）和循环冗余检测（它通常更多地应用在适配器中的链路层）</li>
</ul>
<h1 id="多路访问链路和协议"><a href="#多路访问链路和协议" class="headerlink" title="多路访问链路和协议"></a>多路访问链路和协议</h1><ul>
<li>有两种类型的网络链路：点对点链路和广播链路</li>
<li>点对点链路（point-to-point link）由链路一端的单个发送方和链路另一端的单个接收方组成。许多链路层协议都是为点对点链路设计的，如点对点协议（point-to-point protocol，PPP）和高级数据链路控制（high-level data link control，HDLC）就是两种这样的协议</li>
<li>广播链路（broadcast link），它能够让多个发送和接收节点都连接到相同的、单一的、共享的广播信道上。这里使用术语“广播”是因为当任何一个节点传输一个帧时，信道广播该帧，每个其他节点都收到一个副本。以太网和无线局域网是广播链路层技术的例子</li>
<li>一个对链路层很重要的问题：如何协调多个发送和接收节点对一个共享广播信道的访问，这就是多路访问问题（multiple access problem）。广播信道通常用于局域网中，局域网是一个地理上集中在一座建筑物中（或者在一个公司，或者在大学校园）的网络</li>
<li>多路访问协议（multiple access protocol），即节点通过这些协议来规范它们在共享的广播信道上的传输行为。能够将任何多路访问协议划分为3种类型之一：信道划分协议（channel partitioning protocol），随机接入协议（random access protocol）和轮流协议（taking-turns protocol）</li>
</ul>
<h1 id="交换局域网"><a href="#交换局域网" class="headerlink" title="交换局域网"></a>交换局域网</h1><h2 id="链路层寻址和ARP"><a href="#链路层寻址和ARP" class="headerlink" title="链路层寻址和ARP"></a>链路层寻址和ARP</h2><ul>
<li>MAC地址</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220824214449094.png"></p>
<ul>
<li>适配器的MAC地址具有扁平结构（这与层次结构相反），而且不论适配器到哪里用都不会变化。与之形成对照的是，IP地址具有层次结构（即一个网络部分和一个主机部分），而且当主机移动时，主机的IP地址需要改变，即改变它所连接到的网络</li>
<li>当某适配器要向某些目的适配器发送一个帧时，发送适配器将目的适配器的MAC地址插人到该帧中，并将该帧发送到局域网上。一台交换机偶尔将一个入帧广播到它的所有接口，因此一块适配器可以接收一个并非向它寻址的帧。这样，当适配器接收到一个帧时，将检查该帧中的目的MAC地址是否与它自己的MAC地址匹配。如果匹配，该适配器提取出封装的数据报，并将该数据报沿协议栈向上传递。如果不匹配，该适配器丢弃该帧，而不会向上传递该网络层数据报。所以，仅当收到该帧时，才会中断目的地</li>
<li>有时某发送适配器的确要让局域网上所有其他适配器来接收并处理它打算发送的帧。在这种情况下，发送适配器在该帧的目的地址字段中插入一个特殊的MAC广播地址。对于使用6字节地址的局域网（例如以太网和802.11）来说，广播地址是48个连续的1组成的字符串（即以十六进制表示法表示的FF-FF-FF-FF-FF-FF）</li>
<li>地址解析协议：因为存在网络层地址（例如，因特网的IP地址）和链路层地址（即MAC地址），所以需要在它们之间进行转换。对于因特网而言，这是地址解析协议（Address Resolution Protocol，ARP）的任务</li>
<li>ARP将一个IP地址解析为一个MAC地址。在很多方面它和DNS类似，DNS将主机名解析为IP地址。然而，这两种解析器之间的一个重要区别是，DNS为在因特网中任何地方的主机解析主机名，而ARP只为在同一个子网上的主机和路由器接口解析IP地址</li>
<li>每台主机或路由器在其内存中具有一个ARP表（ARP table），这张表包含IP地址到MAC地址的映射关系。该ARP表也包含一个寿命（TTL）值，它指示了从表中删除每个映射的时间。注意到这张表不必为该子网上的每台主机和路由器都包含一个表项；某些可能从来没有进入到该表中，某些可能已经过期。从一个表项放置到某ARP表中开始，一个表项通常的过期时间是20分钟</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220824215556006.png"></p>
<ul>
<li>发送数据报到子网以外</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220824215950274.png"></p>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220824220102831.png"></p>
<h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><ul>
<li>初始的以太局域网使用同轴电缆总线来互联节点。使用总线拓扑的以太网是一种广播局域网，即所有传输的帧传送到与该总线连接的所有适配器并被其处理</li>
<li>20世纪90年代后期，使用一种基于集线器的星形拓扑以太网安装替代了它们的局域网。在这种安装中，主机（和路由器）直接用双绞对铜线与一台集线器相连。集线器（hub）是一种物理层设备，它作用于各个比特而不是作用于帧。当表示一个0或一个1的比特到达一个接口时，集线器只是重新生成这个比特，将其能量强度放大，并将该比特向其他所有接口传输出去。因此，采用基于集线器的星形拓扑的以太网也是一个广播局域网，即无论何时集线器从它的一个接口接收到一个比特，它向其所有其他接口发送该比特的副本。特别是，如果某集线器同时从两个不同的接口接收到帧，将出现一次碰撞，生成该帧的节点必须重新传输该帧</li>
<li>在21世纪初，以太网又经历了一次重要的革命性变化。以太网安装继续使用星形拓扑，但是位于中心的集线器被交换机（switch）所替代</li>
<li>以太网帧结构</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220824220736648.png"></p>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220824220827810.png"></p>
<ul>
<li>所有的以太网技术都向网络层提供无连接服务。这就是说，当适配器A要向适配器B发送一个数据报时，适配器A在一个以太网帧中封装该数据报，并且把该帧发送到局域网上，没有先与适配器B握手。这种第二层的无连接服务类似于IP的第三层数据报服务和UDP的第四层无连接服务</li>
<li>以太网技术都向网络层提供不可靠服务。特别是，当适配器B收到一个来自适配器A的帧，它对该帧执行CRC校验，但是当该帧通过CRC校验时它既不发送确认帧；而当该帧没有通过CRC校验时它也不发送否定确认帧。当某帧没有通过CRC校验，适配器B只是丢弃该帧。因此，适配器A根本不知道它传输的帧是否到达了B并通过了CRC校验</li>
</ul>
<h2 id="链路层交换机"><a href="#链路层交换机" class="headerlink" title="链路层交换机"></a>链路层交换机</h2><ul>
<li>交换机的任务是接收入链路层帧并将它们转发到出链路。交换机自身对子网中的主机和路由器是透明的；这就是说，某主机/路由器向另一个主机/路由器寻址一个帧（而不是向交换机寻址该帧），顺利地将该帧发送进局域网，并不知道某交换机将会接收该帧并将它转发到另一个节点。这些帧到达该交换机的任何输出接口之一的速率可能暂时会超过该接口的链路容量。为了解决这个问题，交换机输出接口设有缓存，这非常类似于路由器接口为数据报设有缓存</li>
<li>交换机转发和过滤：过滤（fltering）是决定一个帧应该转发到某个接口还是应当将其丢弃的交换机功能。转发（forwarding）是决定一个帧应该被导向哪个接口，并把该帧移动到那些接口的交换机功能。交换机的过滤和转发借助于交换机表（switch table）完成。该交换机表包含某局域网上某些主机和路由器的但不必是全部的表项。交换机表中的一个表项包含：一个MAC地址；通向该MAC地址的交换机接口；表项放置在表中的时间</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220824224623862.png"></p>
<ul>
<li>自学习：表是自动、动态和自治地建立的，即没有来自网络管理员或来自配置协议的任何干预</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220824224825099.png"></p>
<ul>
<li>交换机和路由器的比较：路由器是使用网络层地址转发分组的存储转发分组交换机。尽管交换机也是一个存储转发分组交换机，但它和路由器是根本不同的，因为它用MAC地址转发分组。交换机是第二层的分组交换机，而路由器是第三层的分组交换机</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220824225204246.png"></p>
<h2 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h2><ul>
<li>现代机构的局域网常常是配置为等级结构的，每个工作组（部门）有自己的交换局域网，经过一个交换机等级结构与其他工作组的交换局域网互联，有3个缺点</li>
</ul>
<blockquote>
<p>缺乏流量隔离。尽管该等级结构把组流量局域化到一个单一交换机中，但广播流量（例如携带ARP和DHCP报文或那些目的地还没有被自学习交换机学习到的帧）仍然必须跨越整个机构网络。限制这些广播流量的范围将改善局域网的性能。也许更为重要的是，为了安全/隐私的目的也可能希望限制局域网广播流量。例如，如果一个组包括公司的行政管理团队，另一个组包括运行着Wireshark分组嘎探器的心怀不满的雇员，网络管理员也许非常希望行政流量无法到达该雇员的主机</p>
<p>交换机的无效使用。如果该机构不止有3个组，而是有10个组，则将要求有10个第一级交换机。如果每个组都较小，比如说少于10个人，则单台96端口的交换机将足以容纳每个人，但这台单一的交换机将不能提供流量隔离</p>
<p>管理用户。如果一个雇员在不同组间移动，必须改变物理布线</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220824225929171.png"></p>
<p><img src="https://raw.githubusercontent.com/hankong91/image_01/master/computer_networking/image-20220824230011980.png"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11新增的几个常见关键字</title>
    <url>/2022/03/25/C++/C++11%E6%96%B0%E5%A2%9E%E7%9A%84%E5%87%A0%E4%B8%AA%E5%B8%B8%E8%A7%81%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h1 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h1><ul>
<li>自动类型推导auto</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> au_a = a;</span><br><span class="line">cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(au_a).<span class="built_in">name</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果初始化表达式是引用或者const，则去除引用或者const语义</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// auto不管&amp;和const</span></span><br><span class="line"><span class="keyword">int</span> a&#123;<span class="number">10</span>&#125;; <span class="keyword">int</span> &amp;b = a;</span><br><span class="line"><span class="keyword">auto</span> c = b; <span class="comment">// c的类型为int而非int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> d&#123;<span class="number">10</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> e = d;	<span class="comment">// e的类型为int而非const int</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果auto关键字带上&amp;，则不去除引用或者const语义</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a&#123;<span class="number">10</span>&#125;; <span class="keyword">int</span> &amp;b = a;</span><br><span class="line"><span class="keyword">auto</span>&amp; c = b; <span class="comment">// c的类型为int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> d&#123;<span class="number">10</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span>&amp; e = d;	<span class="comment">// e的类型const int&amp;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>C++14：auto可以作为函数的返回值类型和参数类型</li>
</ul>
<h1 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h1><ul>
<li>自动类型推导decltype</li>
<li>在编译时期推导一个表达式类型，而不用初始化</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func1</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">10</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func2</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;a&#x27;</span>; &#125;    <span class="comment">// C++14</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">decltype</span>(<span class="built_in">func1</span>()) x;</span><br><span class="line">    <span class="keyword">decltype</span>(<span class="built_in">func2</span>()) y = <span class="built_in">func2</span>();</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(x).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(y).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;Hello World&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">decltype</span>(s.<span class="built_in">size</span>()) index = <span class="number">0</span>; index != s.<span class="built_in">size</span>(); ++index) &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>decltype主要用于泛型编程</li>
</ul>
<h1 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h1><ul>
<li>常量表达式是编译期可以计算值的一个表达式</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++数组的大小要求是编译期的一个常量</span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">array&lt;<span class="keyword">int</span>, n&gt; a1;   <span class="comment">// error: n is not a constant expression</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cn = <span class="number">2</span>;</span><br><span class="line">array&lt;<span class="keyword">int</span>, cn&gt; a2;  <span class="comment">// Ok: cn is a constant expression</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const修饰的对象未必是编译期常量</span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">array&lt;<span class="keyword">int</span>, n&gt; a1;   <span class="comment">// error: n is not a constant expression</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cn = <span class="number">2</span>;</span><br><span class="line">array&lt;<span class="keyword">int</span>, cn&gt; a2;  <span class="comment">// Ok: cn is a constant expression</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> rcn = n;  <span class="comment">// rcn is runtime constant, compiler does</span></span><br><span class="line">                    <span class="comment">// not know its value at compile-time</span></span><br><span class="line">rcn++;              <span class="comment">// error: rcn is read-only</span></span><br><span class="line">array&lt;<span class="keyword">int</span>, rcn&gt; a3; <span class="comment">// error: rcn is not know at compile-time</span></span><br></pre></td></tr></table></figure>

<ul>
<li>constexpr说明符声明可在编译时计算函数或者变量的值</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b) ? a : b;     <span class="comment">// C++14, 才允许constexpr函数中有分支循环等</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> rcm = m++;    <span class="comment">// rcm是运行期常量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> cm = <span class="number">3</span>;       <span class="comment">// rcn是编译期常量, 等价于: constexpr int cm = 4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a1[<span class="built_in">max</span>(m, rcm)];            <span class="comment">// error: m &amp; rcm 不是编译期常量</span></span><br><span class="line">    array&lt;<span class="keyword">char</span>, max(cm, 5)&gt; a2;     <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>const vs constexpr</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">const</span>: 告知程序员, <span class="keyword">const</span>修饰的内容是不会被修改的, 主要目的是帮助程序员避免bug</span><br><span class="line"><span class="number">2.</span> <span class="keyword">constexpr</span>: 用在所有被要求使用<span class="string">&quot;constant expression&quot;</span>的地方, 就是<span class="keyword">constexpr</span>修饰的东西能够在编译期计算得到值, 主要目的是让编译器能够优化代码提升性能</span><br></pre></td></tr></table></figure>

<h1 id="typeid"><a href="#typeid" class="headerlink" title="typeid"></a>typeid</h1><ul>
<li>运行时查询类型的信息</li>
<li>用于获取对象所属类的信息</li>
<li>返回一个type_info对象的引用</li>
<li>typeid(AType).name()返回实现定义的，各个编译器自己定义</li>
</ul>
<h1 id="原始字面量R"><a href="#原始字面量R" class="headerlink" title="原始字面量R"></a>原始字面量R</h1><ul>
<li>定义原始字符串的字面量，定义方式为：R”xxx(原始字符串)xxx”，其中（）两边的字符串可以省略</li>
<li>原始字面量R可以直接表示字符串的实际含义，而不需要额外对字符串做转译或连接等操作</li>
<li>编程过程中，使用的字符串中常带有一些特殊字符，对于这些字符往往要做专门的处理，使用了原始字面量就可以轻松的解决这个问题，比如打印路径或者需要换行的场景</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string str1&#123; <span class="string">&quot;D:\hello\world\test.txt&quot;</span> &#125;;</span><br><span class="line">    string str2&#123; <span class="string">&quot;D:\\hello\\world\\test.txt&quot;</span> &#125;;</span><br><span class="line">    string str3&#123; <span class="string">R&quot;(D:\hello\world\test.txt)&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; str1 &lt;&lt; endl;   <span class="comment">// D:helloworld    est.txt</span></span><br><span class="line">    cout &lt;&lt; str2 &lt;&lt; endl;   <span class="comment">// D:\hello\world\test.txt</span></span><br><span class="line">    cout &lt;&lt; str3 &lt;&lt; endl;   <span class="comment">// D:\hello\world\test.txt</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在R”xxx(raw string)xxx”中，原始字符串必须用括号（）括起来，括号的前后可以加其他字符串，所加的字符串会被忽略，并且加的字符串必须在括号两边同时出现</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++11</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的array</title>
    <url>/2022/03/31/C++/C++%E4%B8%AD%E7%9A%84array/</url>
    <content><![CDATA[<h1 id="C-中的array"><a href="#C-中的array" class="headerlink" title="C++中的array"></a>C++中的array</h1><ul>
<li>C Style Array（C++ raw array, 也叫做C++原生数组）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">int</span> arr[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="number">2.</span> arr可能会退化为指针: <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123; cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(a) / <span class="built_in"><span class="keyword">sizeof</span></span>(a[<span class="number">0</span>]); &#125;</span><br><span class="line"><span class="number">3.</span> arr不知道自己的大小: <span class="built_in"><span class="keyword">sizeof</span></span>(arr) / <span class="built_in"><span class="keyword">sizeof</span></span>(arr[<span class="number">0</span>])</span><br><span class="line"><span class="number">4.</span> 两个数组之间无法直接赋值: arr1 = arr2</span><br><span class="line"><span class="number">5.</span> 不能自动推导类型: <span class="keyword">auto</span> a[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>C++ style Array</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 是一个容器类, 所以有迭代器</span><br><span class="line"><span class="number">2.</span> 可直接赋值</span><br><span class="line"><span class="number">3.</span> 知道自己的大小: <span class="built_in">sie</span>()</span><br><span class="line"><span class="number">4.</span> 能和另一个数组交换内容: <span class="built_in">swap</span>()</span><br><span class="line"><span class="number">5.</span> 能以指定值填充自己: <span class="built_in">fill</span>()</span><br><span class="line"><span class="number">6.</span> 取某个位置的元素(做越界检查): <span class="built_in">at</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li>C++17：引入了一种新特性，对类模板的参数进行推导</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::array a1&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;         <span class="comment">// 推导出 std::array&lt;int, 3&gt;</span></span><br><span class="line">std::array a2&#123; <span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span> &#125;;   <span class="comment">// 推导出 std::array&lt;char, 3&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>C++11：标准库函数begin和end，数组不是类类型，这两个函数不是成员函数，只是将数组作为它们的参数，与vec.begin()区别</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用C++原生数组初始化vector对象</span></span><br><span class="line"><span class="keyword">int</span> int_arr[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ivec</span><span class="params">(begin(int_arr), end(int_arr))</span></span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>const</title>
    <url>/2022/02/06/C++/const/</url>
    <content><![CDATA[<h1 id="const对象的多文件访问"><a href="#const对象的多文件访问" class="headerlink" title="const对象的多文件访问"></a>const对象的多文件访问</h1><ul>
<li>若需要多个文件访问const对象，则对于const变量不管是声明还是定义都添加extern关键字</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file.cpp定义并初始化一个常量, 改常量能被其他文件访问</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufsize = <span class="number">1024</span>;</span><br><span class="line"><span class="comment">// file.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufsize;</span><br></pre></td></tr></table></figure>

<ul>
<li>若无const，则定义时没有限制要加上extern</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file.cpp</span></span><br><span class="line"><span class="keyword">int</span> bufsize = <span class="number">1024</span>;</span><br><span class="line"><span class="comment">// file.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> bufsize;</span><br></pre></td></tr></table></figure>

<h1 id="顶层const-amp-底层const"><a href="#顶层const-amp-底层const" class="headerlink" title="顶层const &amp; 底层const"></a>顶层const &amp; 底层const</h1><ul>
<li>顶层const：指针本身是一个常量，一般也可表示任意的对象是常量</li>
<li>底层const：指针所指向的对象是一个常量</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p1 = &amp;i;       <span class="comment">// 不能改变p1的值, 这是一个顶层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">1</span>;         <span class="comment">// 不能改变ci的值, 这是一个顶层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p2 = &amp;ci;      <span class="comment">// 允许改变p2的值, 这是一个底层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p3 = p2; <span class="comment">// 右侧const是顶层const, 左侧const是底层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *r = i;         <span class="comment">// 用于声明引用的const都是底层const</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>const</tag>
      </tags>
  </entry>
  <entry>
    <title>final</title>
    <url>/2022/03/22/C++/final/</url>
    <content><![CDATA[<h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><ul>
<li>C++11：防止继承的发生，在类名后面增加final关键字</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoDerived</span> <span class="keyword">final</span> &#123;</span> &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>C++11：指定派生类不能覆写虚函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> :</span> Base &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">final</span></span>;   <span class="comment">// A::foo 被覆写且是最终覆写</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> <span class="keyword">final</span></span>;   <span class="comment">// 错误: 非虚函数不能被覆写或是final</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> <span class="keyword">final</span> :</span> A &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">override</span></span>;    <span class="comment">// 错误: foo不能被覆写</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>final</tag>
      </tags>
  </entry>
  <entry>
    <title>lambda表达式</title>
    <url>/2022/03/31/C++/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h1><ul>
<li>C++11：一个lambda表达式表示一个可调用的代码单元，可理解为一个未命名的内联函数。但与函数不同，lambda可能定义在函数内部</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [capture list](parameter list) -&gt; return type &#123; function body &#125;</span></span><br><span class="line"><span class="keyword">auto</span> f = [] &#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;;</span><br><span class="line"><span class="comment">// 等价于auto f = []() -&gt; int &#123; return 42; &#125;;</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">f</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体</li>
<li>向lambda传递参数，通常实参和形参的类型必须匹配，而且lambda不能有默认参数</li>
<li>当定义一个lambda时，编译器生成一个与lambda对应的新的（未命名）类类型。当向一个函数传递一个lambda时，同时定义了一个新类型和该类型的一个对象</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span>(*p)() = [] &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(p).<span class="built_in">name</span>() &lt;&lt; endl;  <span class="comment">// void (__cdecl*)(void)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> f = [] &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(f).<span class="built_in">name</span>() &lt;&lt; endl;  <span class="comment">// class &lt;lambda_682ee71b6214d955ff79d311d300cf75&gt;</span></span><br><span class="line"></span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt; func = [] &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(func).<span class="built_in">name</span>() &lt;&lt; endl;    <span class="comment">// class std::function&lt;void __cdecl(void)&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">p</span>();</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="number">31</span>:     <span class="built_in">p</span>();</span><br><span class="line"> call        dword ptr [p]  </span><br><span class="line"> cmp         esi,esp  </span><br><span class="line"> call        __RTC_CheckEsp (<span class="number">0</span>C81217h)  </span><br><span class="line">    <span class="number">32</span>:     <span class="built_in">f</span>();</span><br><span class="line"> lea         ecx,[f]  </span><br><span class="line"> call        &lt;lambda_fcb7316eaff70820ffe7d710fae3140e&gt;::<span class="built_in"><span class="keyword">operator</span></span>() (<span class="number">0</span>C83E30h)  </span><br><span class="line">    <span class="number">33</span>:     <span class="built_in">func</span>();</span><br><span class="line"> lea         ecx,[func]  </span><br><span class="line"> call        std::_Func_class&lt;<span class="keyword">void</span>&gt;::<span class="built_in"><span class="keyword">operator</span></span>() (<span class="number">0</span>C8169Ah)  </span><br></pre></td></tr></table></figure>

<ul>
<li>对于全局变量，存在于全局区，变量不需要捕获，并且可以直接修改</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>lambda</tag>
      </tags>
  </entry>
  <entry>
    <title>this指针</title>
    <url>/2022/03/24/C++/this%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h1><ul>
<li>类中的函数编译后存放在代码段中，不存放在类对象实例的存储空间</li>
<li>为了使对象调用函数时访问对应对象的成员，必须知道该对象的地址，会隐式传入this指针，表明当前对象地址</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> _m = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        _m = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    A a;</span><br><span class="line">    a.<span class="built_in">foo</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数调用</span></span><br><span class="line">    <span class="number">17</span>:     <span class="built_in">func</span>();</span><br><span class="line"> call        <span class="number">00361375</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员函数调用</span></span><br><span class="line">    <span class="number">20</span>:     a.<span class="built_in">foo</span>();</span><br><span class="line"> lea         ecx,[ebp<span class="number">-0</span>Ch]  <span class="comment">// ebp-0Ch为a的地址, 先赋值给ecx寄存器</span></span><br><span class="line"> call        <span class="number">00361370</span>  </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     <span class="number">8</span>:     <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> mov         dword ptr [ebp<span class="number">-8</span>],ecx  <span class="comment">// ebp-8保存了this指针的地址, 即将a的地址赋值给了this指针</span></span><br><span class="line">     <span class="number">9</span>:         _m = <span class="number">3</span>;</span><br><span class="line"> mov         eax,dword ptr [ebp<span class="number">-8</span>]  <span class="comment">// eax存放了a的地址</span></span><br><span class="line"> mov         dword ptr [eax],<span class="number">3</span>      <span class="comment">// eax的地址存放了a中_m成员变量的地址, 即完成了对调用对象赋值</span></span><br><span class="line">    <span class="number">10</span>:     &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title>move和完美转发</title>
    <url>/2022/02/24/C++/move%E5%92%8C%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/</url>
    <content><![CDATA[<h1 id="move"><a href="#move" class="headerlink" title="move"></a>move</h1><ul>
<li>在<a href="https://hankong91.github.io/2022/02/17/%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/">左值和右值</a>一文中提到了移动语义，通过移动构造函数解决了临时变量拷贝产生的性能损失问题，且移动语义是通过右值引用来匹配临时值</li>
<li>普通的左值是否也能通过移动语义来优化性能，C++11为了解决这个问题，提供了std::move方法将左值转换为右值，从而方便应用移动语义</li>
<li>move是将对象资源的所有权从一个对象转移到另一个对象，只是转移，没有内存的拷贝</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string str1&#123; <span class="string">&quot;Hello World&quot;</span> &#125;;</span><br><span class="line">string str2 = str1;             <span class="comment">// Copy</span></span><br><span class="line">string str3 = std::<span class="built_in">move</span>(str1);  <span class="comment">// Move</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; str1 &lt;&lt; endl;   <span class="comment">// null</span></span><br><span class="line">cout &lt;&lt; str2 &lt;&lt; endl;   <span class="comment">// Hello World</span></span><br><span class="line">cout &lt;&lt; str3 &lt;&lt; endl;   <span class="comment">// Hello World</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v1&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v2 = v1;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v3 = std::<span class="built_in">move</span>(v1);     <span class="comment">// v1.size() = 0</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果不用std::move，拷贝的代价很大，性能较低。使用move几乎没有任何代价，只是转换了资源的所有权。它实际上将左值变成右值引用，然后应用移动语义，调用移动构造函数，就避免了拷贝，提高了程序性能。如果一个对象内部有较大的对内存或者动态数组时，很有必要写move语义的拷贝构造函数和赋值函数，避免无谓的深拷贝，以提高性能。事实上，C++11中所有的容器都实现了移动语义，方便我们做性能优化</li>
<li>move实际上并不能移动任何东西，它唯一的功能是将一个左值强制转换为一个右值引用。如果是一些基本类型比如int和char[10]定长数组等类型，使用move的话仍然会发生拷贝（因为没有对应的移动构造函数）。所以，move对于含资源（堆内存或句柄）的对象来说更有意义</li>
<li>std::move是一个非常有迷惑性的函数，不理解左右值概念的话往往以为它能把一个变量里的内容移动到另一个变量，但事实上std::move移动不了什么，唯一的功能是把左值强制转化为右值，让右值引用可以指向左值。其实现等同于一个类型转换：static_cast&lt;T&amp;&amp;&gt;(lvalue)。所以，单纯的std::move(xxx)不会有性能提升</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; ref_a_left = a;                <span class="comment">// 左值引用指向左值</span></span><br><span class="line"><span class="keyword">int</span>&amp;&amp; ref_a_right = std::<span class="built_in">move</span>(a);   <span class="comment">// 通过std::move将左值转化为右值, 可以被右值引用指向</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;                  <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<ul>
<li>被声明出来的左、右值引用都是左值。因为被声明出的左、右值引用是有地址的，也位于等号左边</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>&amp;&amp; right_value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    right_value = <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span>&amp; ref_a_left = a;</span><br><span class="line">    <span class="keyword">int</span>&amp;&amp; ref_a_right = std::<span class="built_in">move</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">//     func(a);            // 编译报错: an lvalue to an rvalue reference</span></span><br><span class="line"><span class="comment">//     func(ref_a_left);   // 编译报错: an lvalue to an rvalue reference</span></span><br><span class="line"><span class="comment">//     func(ref_a_right);  // 编译报错: an lvalue to an rvalue reference</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>(std::<span class="built_in">move</span>(a));</span><br><span class="line">    <span class="built_in">func</span>(std::<span class="built_in">move</span>(ref_a_left));</span><br><span class="line">    <span class="built_in">func</span>(std::<span class="built_in">move</span>(ref_a_right));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印三个左值的地址都一样</span></span><br><span class="line">    cout &lt;&lt; &amp;a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &amp;ref_a_left &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ref_a_left &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &amp;ref_a_right &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ref_a_right &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>右值引用既可以是左值也可以是右值，如果有名称则为左值，否则是右值。或者说：作为函数返回值的&amp;&amp;是右值，直接声明出来的&amp;&amp;是左值。其实引用和普通变量是一样的，int &amp;&amp;ref = std::move(a)和int a = 5没有什么区别，等号左边就是左值，右边就是右值</li>
<li>vector::push_back使用std::move提高性能</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::string str1&#123; <span class="string">&quot;Hello World&quot;</span> &#125;;</span><br><span class="line">std::vector&lt;std::string&gt; vec;</span><br><span class="line"></span><br><span class="line">vec.<span class="built_in">push_back</span>(str1);                <span class="comment">// Copy</span></span><br><span class="line">vec.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(str1));     <span class="comment">// 调用移动语义的push_bak方法, 避免拷贝, str1会失去原有值, 变成空字符串</span></span><br><span class="line">vec.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(str1));  <span class="comment">// emplace_back效果相同, str1会失去原有值</span></span><br><span class="line">vec.<span class="built_in">emplace_back</span>(<span class="string">&quot;abcd&quot;</span>);           <span class="comment">// 直接接右值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// vector方法定义</span></span><br><span class="line"><span class="comment">// void push_back (const value_type&amp; val);</span></span><br><span class="line"><span class="comment">// void push_back(value_type&amp;&amp; val);</span></span><br><span class="line"><span class="comment">// void emplace_back (Args&amp;&amp;... args);</span></span><br></pre></td></tr></table></figure>

<h1 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h1><ul>
<li>这里继续转载博文<a href="https://www.cnblogs.com/qicosmos/p/4283455.html">从4行代码看右值引用</a>中的第四行代码</li>
</ul>
<h2 id="第四行代码"><a href="#第四行代码" class="headerlink" title="第四行代码"></a>第四行代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; val)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(std::forward&lt;T&gt;(val));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>C++11之前调用模板函数时，存在一个比较头疼的问题，如何正确的传递参数。比如</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forwardValue</span><span class="params">(T&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">processValue</span>(val);  <span class="comment">// 右值参数会变成左值 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forwardValue</span><span class="params">(<span class="keyword">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">processValue</span>(val);  <span class="comment">// 参数都变成常量左值引用了 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不能安装本来的参数类型进行转发</li>
<li>C++11引入了完美转发：在函数模板中，完全依照模板的参数的类型（即保持参数的左值、右值特征），将参数传递给函数模板中调用的另外一个函数。C++11中的std::forward正是做这个事情的，他会按照参数的实际类型进行转发</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processValue</span><span class="params">(<span class="keyword">int</span>&amp; a)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;lvalue&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processValue</span><span class="params">(<span class="keyword">int</span>&amp;&amp; a)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;rvalue&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forwardValue</span><span class="params">(T&amp;&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">processValue</span>(std::forward&lt;T&gt;(val)); <span class="comment">// 按照参数本来的类型进行转发</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    forwardValue(i);    <span class="comment">// 传入左值</span></span><br><span class="line">    forwardValue(<span class="number">0</span>);    <span class="comment">// 传入右值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// lvalue</span></span><br><span class="line"><span class="comment">// rvalue</span></span><br></pre></td></tr></table></figure>

<ul>
<li>右值引用T&amp;&amp;是一个universal references，可以接受左值或者右值，正是这个特性让他适合作为一个参数的路由，然后再通过std::forward按照参数的实际类型去匹配对应的重载函数，最终实现完美转发</li>
</ul>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul>
<li>C++11正是通过引入右值引用来优化性能，具体来说是通过移动语义来避免无谓拷贝的问题，通过move语义来将临时生成的左值中的资源无代价的转移到另外一个对象中去，通过完美转发来解决不能按照参数实际类型来转发的问题（同时，完美转发获得的一个好处是可以实现移动语义）</li>
<li>从性能上讲，左右值引用没有区别，传参使用左右值引用都可以避免拷贝</li>
<li>右值引用可以直接指向右值，也可以通过std::move指向左值；而左值引用只能指向左值（const左值引用也能指向右值）</li>
<li>作为函数形参时，右值引用更灵活。虽然const左值引用也可以做到左右值都接受，但它无法修改，有一定局限性</li>
<li>可移动对象在需要拷贝且被拷贝者之后不再被需要的场景，建议使用std::move触发移动语义，提升性能</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.cnblogs.com/qicosmos/p/4283455.html">从4行代码看右值引用</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/335994370">一文读懂C++右值引用和std::move</a></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>右值引用</tag>
        <tag>move</tag>
        <tag>完美转发,forward</tag>
      </tags>
  </entry>
  <entry>
    <title>关于extern &quot;C&quot;</title>
    <url>/2022/03/01/C++/%E5%85%B3%E4%BA%8Eextern%20C/</url>
    <content><![CDATA[<h1 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h1><ul>
<li>被extern “C”修饰的代码会按照C语言的方式去编译，C语言不支持函数name mangling</li>
<li>extern “C”的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern “C”后，会指示编译器这部分代码按C语言（而不是C++）的方式进行编译。由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func(int)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者用大括号</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func(int)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译报错</span></span><br><span class="line">error C2733: <span class="string">&#x27;func&#x27;</span>: second C linkage of overloaded function <span class="keyword">not</span> allowed</span><br></pre></td></tr></table></figure>

<ul>
<li>如果函数同时有声明和实现，要让函数声明被extern “C”修饰，函数实现可以不修饰</li>
<li>在C/C++混合编程过程中，第三方框架/库可能是用C语言写的开源库，在C++中调用过程中，由于C++对函数有name mangling，若在库函数声明中未标注extern “C”，则会对库函数进行name mangling，而库函数的实现又是以C的方式进行编译，不会进行name mangling，从而链接失败</li>
<li>C语言中不支持extern “C”声明，在.c文件中包含了extern “C”时会出现编译时错误</li>
<li>与extern对应的关键字是static，被它修饰的全局变量和函数只能在本模块中使用。因此，一个函数或变量只可能被本模块使用时，其不可能被extern “C”修饰</li>
</ul>
<h1 id="C和C-互相调用"><a href="#C和C-互相调用" class="headerlink" title="C和C++互相调用"></a>C和C++互相调用</h1><h2 id="C-中调用C代码"><a href="#C-中调用C代码" class="headerlink" title="C++中调用C代码"></a>C++中调用C代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TestC.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TEST_C_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST_C_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TestC.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TestC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = a + b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, c);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TestC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// gcc -c TestC.c</span></span><br><span class="line"><span class="comment">// ar -r libTestC.a TestC.o</span></span><br><span class="line"><span class="comment">// g++ -o TestCpp TestCpp.cpp -L. -lTestC</span></span><br></pre></td></tr></table></figure>

<h2 id="C中调用C-代码"><a href="#C中调用C-代码" class="headerlink" title="C中调用C++代码"></a>C中调用C++代码</h2><ul>
<li>C语言没法直接调用C++的函数，但可以使用包裹函数来实现。C++文件.cpp中可以调用C和C++的函数，但是C代码.c只能调用C的函数，所以可以用包裹函数去包裹C++函数，然后把这个包裹函数以C的规则进行编译，这样C就可以调用这个包裹函数了</li>
<li>调用普通函数例子</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TestCpp.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TEST_CPP_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST_CPP_H_</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TestCpp.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TestCpp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = a + b;</span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TestWrapper.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TEST_CPP_WRAPPER_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST_CPP_WRAPPER_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">funcWrapper</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TestWrapper.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TestCppWrapper.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TestCpp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">funcWrapper</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">func</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TestCppWrapper.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">funcWrapper</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// g++ -c TestCpp.cpp</span></span><br><span class="line"><span class="comment">// ar -r libTestCpp.a TestCpp.o</span></span><br><span class="line"><span class="comment">// g++ -c TestCppWrapper.cpp</span></span><br><span class="line"><span class="comment">// ar -r libTestCppWrapper.a TestCppWrapper.o</span></span><br><span class="line"><span class="comment">// gcc -o TestC TestC.c -L. -lTestCppWrapper -lTestCpp -lstdc++</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注意链接顺序，必须要先链接TestCppWrapper，再链接TestCpp，如果使用C++库，还需外额外添加</li>
<li>调用类成员函数例子</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TestCpp.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TEST_CPP_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST_CPP_H_</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestCpp</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TestCpp.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TestCpp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TestCpp::func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = a + b;</span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TestCppWrapper.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TEST_CPP_WRAPPER_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST_CPP_WRAPPER_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">getHandle</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">funcWrapper</span><span class="params">(<span class="keyword">void</span>* handle, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TestCppWrapper.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TestCppWrapper.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TestCpp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">getHandle</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> TestCpp c;</span><br><span class="line">    <span class="keyword">return</span> &amp;c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">funcWrapper</span><span class="params">(<span class="keyword">void</span>* handle, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TestCpp* p = <span class="keyword">static_cast</span>&lt;TestCpp*&gt;(handle);</span><br><span class="line">    <span class="keyword">return</span> p-&gt;<span class="built_in">func</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TestCppWrapper.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* handle = <span class="built_in">getHandle</span>();</span><br><span class="line">    <span class="built_in">funcWrapper</span>(handle, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// g++ -c TestCpp.cpp TestCppWrapper.cpp</span></span><br><span class="line"><span class="comment">// ar -r libTestCpp.a TestCpp.o TestCppWrapper.o</span></span><br><span class="line"><span class="comment">// gcc -o TestC TestC.c -L. -lTestCpp -lstdc++</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>内联函数</title>
    <url>/2022/03/07/C++/%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h1><ul>
<li>使用inline修饰函数的声明或者实现，可以使其变成内联函数，建议声明和实现都增加inline修饰</li>
<li>编译器会将函数调用直接展开为函数体代码，可以减少函数调用开销，但会增大代码体积</li>
<li>尽量不要内联超过10行代码的函数，有些函数即使声明为inline，也不一定会被编译器内联，比如递归函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v1 + v2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="built_in">sum</span>(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 未使用inline, 反汇编会看到调用call sum</span></span><br><span class="line">    <span class="number">10</span>:     <span class="keyword">int</span> c = <span class="built_in">sum</span>(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"><span class="number">00031014</span> <span class="number">6</span>A <span class="number">14</span>                push        <span class="number">14</span>h  </span><br><span class="line"><span class="number">00031016</span> <span class="number">6</span>A <span class="number">0</span>A                push        <span class="number">0</span>Ah  </span><br><span class="line"><span class="number">00031018</span> <span class="function">E8 E3 FF FF FF       call        <span class="title">sum</span> <span class="params">(<span class="number">031000</span>h)</span>  </span></span><br><span class="line"><span class="function">0003101D 83 C4 08             add         esp,8  </span></span><br><span class="line"><span class="function">00031020 89 45 FC             mov         dword ptr [c],eax  </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 使用inline, 反汇编会看到内联展开</span></span></span><br><span class="line"><span class="function"><span class="comment">// VS需要在Release模式下, 并且关闭编译器优化, 同时使能内联展开</span></span></span><br><span class="line"><span class="function">    10:     int c =</span> <span class="built_in">sum</span>(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"><span class="number">00481004</span> B8 <span class="number">0</span>A <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       mov         eax,<span class="number">0</span>Ah  </span><br><span class="line"><span class="number">00481009</span> <span class="number">83</span> C0 <span class="number">14</span>             add         eax,<span class="number">14</span>h  </span><br><span class="line"><span class="number">0048100</span>C <span class="number">89</span> <span class="number">45</span> FC             mov         dword ptr [c],eax  </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>函数重载</title>
    <url>/2022/02/06/C++/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<h1 id="重载和const形参"><a href="#重载和const形参" class="headerlink" title="重载和const形参"></a>重载和const形参</h1><ul>
<li>顶层const不影响传入函数的对象，因此一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Phone)</span></span>;   <span class="comment">// 重复声明了Record lookup(Phone);</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone *)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone * <span class="keyword">const</span>)</span></span>; <span class="comment">// 重复声明了Record lookup(Phone *);</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时const是底层的，因为const不能转换成其他类型，只能把const对象传递给const形参，但当传递一个非常量对象或者非常量对象的指针时，编译器会优先选择非常量的版本</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于接受引用或指针的函数来说, 对象是常量还是非常量对应的形参不同</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone &amp;)</span></span>;         <span class="comment">// 函数作用于Phone的引用</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Phone &amp;)</span></span>;   <span class="comment">// 新函数, 作用于常量引用</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone *)</span></span>;         <span class="comment">// 新函数, 作用于指向Phone的指针</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Phone *)</span></span>;   <span class="comment">// 新函数, 作用与指向常量的指针</span></span><br></pre></td></tr></table></figure>

<h1 id="函数重载的本质"><a href="#函数重载的本质" class="headerlink" title="函数重载的本质"></a>函数重载的本质</h1><ul>
<li>采用了name mangling或者叫name decoration技术，C++编译器默认会对符号名（比如函数名）进行改编、修饰，重载时会生成多个不同的函数名，不同编译器有不同的生成规则，通过逆向工程IDA打开可以看到不同函数名，反汇编后也可以看到跳转到了不同的函数地址</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func(int)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> a)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func(double)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line"><span class="number">00B</span>31<span class="function">E8E E8 A5 F5 FF FF       call        <span class="title">func</span> <span class="params">(<span class="number">0B</span>31438h)</span>  </span></span><br><span class="line"><span class="function">    <span class="title">func</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="number">00B</span>31E93 <span class="number">6</span>A <span class="number">01</span>                push        <span class="number">1</span>  </span><br><span class="line"><span class="number">00B</span>31<span class="function">E95 E8 C1 F5 FF FF       call        <span class="title">func</span> <span class="params">(<span class="number">0B</span>3145Bh)</span>  </span></span><br><span class="line"><span class="function">00B31E9A 83 C4 04             add         esp,4  </span></span><br><span class="line"><span class="function">    <span class="title">func</span><span class="params">(<span class="number">1.0</span>)</span></span>;</span><br><span class="line"><span class="number">00B</span>31E9D <span class="number">83</span> EC <span class="number">08</span>             sub         esp,<span class="number">8</span>  </span><br><span class="line"><span class="number">00B</span>31EA0 F2 <span class="number">0F</span> <span class="number">10</span> <span class="number">05</span> <span class="number">48</span> <span class="number">8B</span> B3 <span class="number">00</span> movsd       xmm0,mmword ptr [__real@<span class="number">3f</span>f0000000000000 (<span class="number">0B</span>38B48h)]  </span><br><span class="line"><span class="number">00B</span>31EA8 F2 <span class="number">0F</span> <span class="number">11</span> <span class="number">04</span> <span class="number">24</span>       movsd       mmword ptr [esp],xmm0  </span><br><span class="line"><span class="number">00B</span>31<span class="function">EAD E8 B3 F5 FF FF       call        <span class="title">func</span> <span class="params">(<span class="number">0B</span>31465h)</span>  </span></span><br><span class="line"><span class="function">00B31EB2 83 C4 08             add         esp,8  </span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>函数重载</tag>
      </tags>
  </entry>
  <entry>
    <title>匿名对象</title>
    <url>/2022/03/07/C++/%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h1><ul>
<li>一个只用一次的对象，这种不命名的对象叫匿名对象</li>
<li>匿名对象没有变量名，没有被指针指向，用完后马上调用析构函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>() &#123;</span><br><span class="line">        radius = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Circle</span>(<span class="keyword">double</span> r) &#123;</span><br><span class="line">        radius = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span> * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> radius;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Circle c1 = Circle&#123; <span class="number">1.1</span> &#125;;</span><br><span class="line">    <span class="keyword">auto</span> c2 = Circle&#123; <span class="number">2.2</span> &#125;;    <span class="comment">// 用匿名对象做拷贝列表初始化</span></span><br><span class="line"></span><br><span class="line">    Circle c3&#123;&#125;;</span><br><span class="line">    c3 = Circle&#123; <span class="number">3.3</span> &#125;;         <span class="comment">// 用匿名对象赋值</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; Circle&#123; <span class="number">4.2</span> &#125;.<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">Circle</span>().<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">Circle</span>(<span class="number">5</span>).<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cin.<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>多态和虚函数</title>
    <url>/2022/03/22/C++/%E5%A4%9A%E6%80%81%E5%92%8C%E8%99%9A%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><ul>
<li>广义的多态：不同类型的实体/对象对同一消息有不同的响应</li>
<li>多态有两种形式：重载多态和子类型多态</li>
<li>子类型多态：通过虚函数实现</li>
</ul>
<h1 id="虚函数实现原理"><a href="#虚函数实现原理" class="headerlink" title="虚函数实现原理"></a>虚函数实现原理</h1><ul>
<li>虚函数的实现原理是虚表，这个虚表里面存储着最终需要调用的虚函数的地址，这个虚表也叫虚函数表</li>
<li>当类中包含虚函数时，类的大小增加一个指针的大小，用于保存虚表的地址，且该指针存在于最前面的地址，当调用虚函数时会通过该指针查找对应虚函数的地址，实现多态调用</li>
<li>只要有虚函数，所有相同对象实例共享同一张虚表，即所有相同对象实例的虚表指针地址指向同一张虚表，注意，不同对象实例虚表指针不同，即使是基类和子类其虚表指针也是不同的</li>
<li>若子类没有重写父类的虚函数，则虚函数表中该虚函数的地址为父类虚函数的地址</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B::func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B::vfunc()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span> :</span> B &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;D::func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">vfunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;D::vfunc()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    B* p = <span class="keyword">new</span> <span class="built_in">D</span>();</span><br><span class="line">    p-&gt;<span class="built_in">func</span>();</span><br><span class="line">    p-&gt;<span class="built_in">vfunc</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="number">26</span>:     p-&gt;<span class="built_in">func</span>();</span><br><span class="line"> mov         ecx,dword ptr [ebp<span class="number">-8</span>]  <span class="comment">// ebp-8是指针p的地址</span></span><br><span class="line"> call        <span class="number">00F</span>81109  	            <span class="comment">// 非虚函数直接调用B::func()</span></span><br><span class="line">    <span class="number">27</span>:     p-&gt;<span class="built_in">vfunc</span>();</span><br><span class="line"> mov         eax,dword ptr [ebp<span class="number">-8</span>]  <span class="comment">// eax是对象D的地址</span></span><br><span class="line"> mov         edx,dword ptr [eax]    <span class="comment">// 取出对象D最前面的4个地址值给edx, 即取出虚函数表的地址</span></span><br><span class="line"> mov         esi,esp  </span><br><span class="line"> mov         ecx,dword ptr [ebp<span class="number">-8</span>]  </span><br><span class="line"> mov         eax,dword ptr [edx]    <span class="comment">// 取出虚函数表的最前面4个地址给eax, 即取出D::vfunc()函数地址</span></span><br><span class="line"> call        eax                    <span class="comment">// 间接调用D::vfunc()</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>多态</tag>
        <tag>虚函数</tag>
      </tags>
  </entry>
  <entry>
    <title>左值和右值</title>
    <url>/2022/02/17/C++/%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/</url>
    <content><![CDATA[<h1 id="概念和语法"><a href="#概念和语法" class="headerlink" title="概念和语法"></a>概念和语法</h1><ul>
<li>C++98/03中的左值引用是这样的：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; ri = i;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里int&amp;是对左值进行绑定，但是int&amp;不能绑定右值，相应的，对右值进行绑定的引用就是右值引用，其语法是A&amp;&amp;，表示绑定类型为A的右值，比如</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp;&amp; ri = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>右值引用是C++11中新增的特性，主要用来解决C++98/03中遇到的两个问题，第一个问题就是临时对象非必要的昂贵拷贝操作，第二个问题是在模板函数中如何按照参数的实际类型进行转发。通过引入右值引用，很好的解决了这两个问题，改进了程序性能</li>
<li>当一个对象被用作右值的的时候，用的是对象的值（内容）</li>
<li>当对象被用作左值的时候，用的是对象的身份（在内存中的位置）</li>
<li>左值：定义了一个函数或者对象，它是一个可以取地址的表达式</li>
<li>纯右值：是不和对象相关联的值（字面量）或其求值结果是字面量或者一个匿名的临时对象</li>
<li>将亡值：将亡值也指定了一个对象，是一个将纯右值转换为右值引用的表达式</li>
</ul>
<h1 id="理解右值"><a href="#理解右值" class="headerlink" title="理解右值"></a>理解右值</h1><ul>
<li>这里主要转载博文<a href="https://www.cnblogs.com/qicosmos/p/4283455.html">从4行代码看右值引用</a></li>
</ul>
<h2 id="第一行代码"><a href="#第一行代码" class="headerlink" title="第一行代码"></a>第一行代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="built_in">getVar</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>这行代码会产生两种类型的值，一种为左值i，一种是函数getVar()返回的临时值，这个临时值在表达式结束后就销毁了，而左值i在表达式结束后仍然存在，这个临时值就是右值，具体来说就是纯右值，右值是不具名的</li>
<li>区分左值和右值的一个简单办法是：看能不能对表达式取地址，如果能，则为左值，否则为右值</li>
<li>所有的具名变量或对象都是左值，而匿名变量则是右值，比如，简单的赋值语句</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>在这条语句中，i是左值，0是字面量，就是右值。在上面的代码中，i可以被引用，0就不可以了。具体来说上面的表达式中等号右边的0是纯右值（prvalue），在C++11中所有的值必属于左值、将亡值、纯右值三者之一</li>
<li>比如，非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和lambda表达式等都是纯右值。而将亡值是C++11新增的、与右值引用相关的表达式，比如，将要被移动的对象、T&amp;&amp;函数返回值、std::move返回值和转换为T&amp;&amp;的类型的转换函数的返回值等</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> j = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [] &#123; <span class="keyword">return</span> <span class="number">5</span>; &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面代码中，5是一个原始字面量，[] { return 5; }是一个lambda表达式，都是属于纯右值，特点是在表达式结束之后就销毁了</li>
</ul>
<h2 id="第二行代码"><a href="#第二行代码" class="headerlink" title="第二行代码"></a>第二行代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp;&amp; k = <span class="built_in">getVar</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>第二行代码和第一行代码很像，只是相比第一行代码多了“&amp;&amp;”，它就是右值引用，我们知道左值引用是对左值的引用，那么对应的，对右值的引用就是右值引用，而且右值是匿名变量，我们也只能通过引用的方式来获取右值。虽然第二行代码和第一行代码看起来差别不大，但是实际上语义的差别很大，这里，getVar()产生的临时值不会像第一行代码那样，在表达式结束之后就销毁了，而是会被“续命”，他的生命周期将会通过右值引用得以延续，和变量k的声明周期一样长</li>
<li>右值引用的第一个特点：通过右值引用，右值由“重获新生”，其生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值临时量将会一直存活下去。如下例子观察生命周期</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g_ctorCnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> g_cpyCtorCnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> g_dtorCnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="built_in">A</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Ctor() - this: &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;, cnt: &quot;</span> &lt;&lt; ++g_ctorCnt &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">const</span> A&amp; a) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Copy Ctor() - this: &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;, cnt: &quot;</span> &lt;&lt; ++g_cpyCtorCnt &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Dtor() - this: &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;, cnt: &quot;</span> &lt;&lt; ++g_dtorCnt &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">getA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">A</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a = <span class="built_in">getA</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>为清楚观察临时值，在编译时设置编译选项-fno-elide-constructors用来关闭返回值优化效果，输出结果为</li>
</ul>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Ctor</span>() - this: <span class="number">0</span>x<span class="number">61</span>fdbf, cnt : <span class="number">1</span>            // getA()内部构造对象<span class="number">1</span></span><br><span class="line"><span class="attribute">Copy</span> Ctor() - this : <span class="number">0</span>x<span class="number">61</span>fe<span class="number">0</span>f, cnt : <span class="number">1</span>      // 对象<span class="number">1</span>拷贝构造临时对象<span class="number">2</span></span><br><span class="line"><span class="attribute">Dtor</span>() - this : <span class="number">0</span>x<span class="number">61</span>fdbf, cnt : <span class="number">1</span>           // 对象<span class="number">1</span>销毁</span><br><span class="line"><span class="attribute">Copy</span> Ctor() - this : <span class="number">0</span>x<span class="number">61</span>fe<span class="number">0</span>e, cnt : <span class="number">2</span>      // 临时对象<span class="number">2</span>拷贝构造对象<span class="number">3</span>(a)</span><br><span class="line"><span class="attribute">Dtor</span>() - this : <span class="number">0</span>x<span class="number">61</span>fe<span class="number">0</span>f, cnt : <span class="number">2</span>           // 临时对象<span class="number">2</span>销毁</span><br><span class="line"><span class="attribute">Dtor</span>() - this : <span class="number">0</span>x<span class="number">61</span>fe<span class="number">0</span>e, cnt : <span class="number">3</span>           // 对象<span class="number">3</span>销毁</span><br></pre></td></tr></table></figure>

<ul>
<li>从上面的例子中可以看到，在没有返回值优化的情况下，拷贝构造函数调用了两次，一次是getA()函数内部创建的对象返回出来构造一个临时对象产生的，另一次是在main函数中构造a对象产生的。第二次的Dtor是因为临时对象在构造a对象之后就销毁了。如果开启返回值优化的话，输出结果将是</li>
</ul>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Ctor</span>() - this: <span class="number">0</span>x<span class="number">61</span>fe<span class="number">0</span>f, cnt: <span class="number">1</span></span><br><span class="line"><span class="attribute">Dtor</span>() - this: <span class="number">0</span>x<span class="number">61</span>fe<span class="number">0</span>f, cnt: <span class="number">1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可以看到返回值优化将会把临时对象优化掉，但这不是c++标准，是各编译器的优化规则</li>
<li>在回到之前提到的可以通过右值引用来延长临时右值的生命周期，如果上面的代码中我们通过右值引用来绑定函数返回值的话，输出结果如下（设置-fno-elide-constructors）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A&amp;&amp; a = <span class="built_in">getA</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Ctor</span>() - this: <span class="number">0</span>x<span class="number">61</span>fdbf, cnt: <span class="number">1</span></span><br><span class="line"><span class="attribute">Copy</span> Ctor() - this: <span class="number">0</span>x<span class="number">61</span>fe<span class="number">07</span>, cnt: <span class="number">1</span></span><br><span class="line"><span class="attribute">Dtor</span>() - this: <span class="number">0</span>x<span class="number">61</span>fdbf, cnt: <span class="number">1</span></span><br><span class="line"><span class="attribute">Dtor</span>() - this: <span class="number">0</span>x<span class="number">61</span>fe<span class="number">07</span>, cnt: <span class="number">2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>通过右值引用，比之前少了一次拷贝构造和一次析构，原因在于右值引用绑定了右值，让临时右值的生命周期延长了。可以利用这个特点做一些性能优化，即避免临时对象的拷贝构造和析构</li>
<li>事实上，在c++98/03中，通过常量左值引用也经常用来做性能优化。上面的代码改成</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> A&amp; = <span class="built_in">getA</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>输出结果和右值一样。因为常量左值引用是一个“万能”的引用类型，可以接受左值、右值、常量左值和常量右值。需要注意的是普通的左值引用不能接受右值，比如这样的写法是不对的，编译报错，原因是非常量左值引用只能接受左值</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">A&amp; = <span class="built_in">getA</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>右值引用的第二个特点：右值引用独立于左值和右值。意思是右值引用类型的变量可能是左值也可能是右值，比如</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp;&amp; ri = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>ri类型为右值引用，但ri本身是左值，因为具名变量都是左值</li>
<li>T&amp;&amp;是什么，一定是右值吗？如下例子</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">10</span>);      <span class="comment">// t是右值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">f</span>(x);       <span class="comment">// t是左值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>右值引用的第三个特点：T&amp;&amp; t在发生自动类型推断的时候，它是未定的引用类型（universal references），如果被一个左值初始化，它就是一个左值；如果它被一个右值初始化，它就是一个右值，它是左值还是右值取决于它的初始化</li>
<li>对于函数template &lt;typename T&gt; void f(T&amp;&amp; t)，当参数为右值10的时候，根据universal references的特点，t被一个右值初始化，那么t就是右值；当参数为左值x时，t被一个左值引用初始化，那么t就是一个左值</li>
<li>需要注意的是，仅仅是当发生自动类型推导（如函数模板的类型自动推导，或auto关键字）的时候，T&amp;&amp;才是universal references。再看看下面的例子</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">    <span class="built_in">Test</span>(Test&amp;&amp; rhs);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面的例子中，param是universal reference，rhs是Test&amp;&amp;右值引用，因为模版函数f发生了类型推断，而Test&amp;&amp;并没有发生类型推导，因为Test&amp;&amp;是确定的类型了</li>
<li>正是因为右值引用可能是左值也可能是右值，依赖于初始化，并不是一下子就确定的特点，我们可以利用这一点做很多文章，比如移动语义和完美转发</li>
</ul>
<h2 id="第三行代码"><a href="#第三行代码" class="headerlink" title="第三行代码"></a>第三行代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">T</span>(T&amp;&amp; a) : <span class="built_in">m_val</span>(val) &#123; a.m_val = <span class="literal">nullptr</span>; &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这行代码实际上来自于一个类的构造函数，构造函数的一个参数是一个右值引用，为什么将右值引用作为构造函数的参数呢？在解答这个问题之前我们先看一个例子</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() : <span class="built_in">m_ptr</span>(<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">0</span>)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Ctor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">const</span> A&amp; a) : <span class="built_in">m_ptr</span>(<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(*a.m_ptr)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Copy Ctor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>* m_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">getA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">A</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a = <span class="built_in">getA</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// Ctor</span></span><br><span class="line"><span class="comment">// Copy Ctor</span></span><br><span class="line"><span class="comment">// Copy Ctor</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这个例子很简单，一个带有堆内存的类，必须提供一个深拷贝拷贝构造函数，因为默认的拷贝构造函数是浅拷贝，会发生“指针悬挂”的问题。如果不提供深拷贝的拷贝构造函数，上面的测试代码将会发生错误（打开编译选项-fno-elide-constructors），内部的m_ptr将会被释放三次，一次是getA()函数内部创建的对象析构的时候释放一次，第二次是临时右值析构的时候释放一次，第三次是外面构造的a对象释放时释放一次，而这三个对象的m_ptr是同一个指针，这就是所谓的指针悬挂问题</li>
<li>提供深拷贝的拷贝构造函数虽然可以保证正确，但是在有些时候会造成额外的性能损耗，因为有时候这种深拷贝是不必要的</li>
<li>面代码中的getA函数会返回临时变量，然后通过这个临时变量拷贝构造了一个新的对象a，临时变量在拷贝构造完成之后就销毁了，如果堆内存很大的话，那么这个拷贝构造的代价会很大，带来了额外的性能损失。每次都会产生临时变量并造成额外的性能损失，有没有办法避免临时变量造成的性能损失呢？C++11已经有了解决方法，通过移动构造函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() : <span class="built_in">m_ptr</span>(<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">0</span>)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Ctor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">const</span> A&amp; a) : <span class="built_in">m_ptr</span>(<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(*a.m_ptr)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Copy Ctor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">A</span>(A&amp;&amp; a) : <span class="built_in">m_ptr</span>(a.m_ptr) &#123;</span><br><span class="line">        a.m_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Move Ctor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>* m_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">getA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">A</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a = <span class="built_in">getA</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// Ctor</span></span><br><span class="line"><span class="comment">// Move Ctor</span></span><br><span class="line"><span class="comment">// Move Ctor</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这个构造函数并没有做深拷贝，仅仅是将指针的所有者转移到了另外一个对象，同时，将参数对象a的指针置为空，这里仅仅是做了浅拷贝，因此，这个构造函数避免了临时变量的深拷贝问题</li>
<li>上面这个函数其实就是移动构造函数，他的参数是一个右值引用类型，这里的A&amp;&amp;表示右值，为什么？前面已经提到，这里没有发生类型推断，是确定的右值引用类型。为什么会匹配到这个构造函数？因为这个构造函数只能接受右值参数，而函数返回值是右值，所以就会匹配到这个构造函数。这里的A&amp;&amp;可以看作是临时值的标识，对于临时值我们仅仅需要做浅拷贝即可，无需再做深拷贝，从而解决了前面提到的临时变量拷贝构造产生的性能损失的问题。这就是所谓的移动语义，右值引用的一个重要作用是用来支持移动语义的</li>
<li>提供移动构造函数的同时也会提供一个拷贝构造函数，以防止移动不成功的时候还能拷贝构造，使我们的代码更安全</li>
</ul>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul>
<li>有地址的变量就是左值，没有地址的字面量、临时值就是右值</li>
<li>左值引用能指向左值，不能指向右值，但是const左值引用是可以指向右值的</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; ref = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// push_back(5);</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> value_type&amp; value)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>右值引用专为右值而生，可以指向右值，不能指向左值。通过右值引用，右值由“重获新生”，其生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值临时量将会一直存活下去，避免临时对象的拷贝构造和析构</li>
<li>仅仅是当T&amp;&amp; t在发生自动类型推断的时候（如函数模板的类型自动推导，或auto关键字），它是未定的引用类型（universal references），如果被一个左值初始化，它就是一个左值；如果它被一个右值初始化，它就是一个右值，它是左值还是右值取决于它的初始化</li>
<li>为避免临时变量的深拷贝带来的开销，引入移动构造函数，传入右值引用参数，实现浅拷贝</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.cnblogs.com/qicosmos/p/4283455.html">从4行代码看右值引用</a></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>右值引用</tag>
        <tag>右值</tag>
        <tag>移动构造函数</tag>
      </tags>
  </entry>
  <entry>
    <title>带有初始化语句的if/switch语句</title>
    <url>/2022/03/31/C++/%E5%B8%A6%E6%9C%89%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AF%AD%E5%8F%A5%E7%9A%84if-switch%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h1 id="带有初始化语句的if-switch语句"><a href="#带有初始化语句的if-switch语句" class="headerlink" title="带有初始化语句的if/switch语句"></a>带有初始化语句的if/switch语句</h1><ul>
<li>C++17：if条件中用到的新变量在if块内初始化</li>
<li>本应限制于if块内的变量侵入了周边的作用域，若编译器确知变量作用域限制于if块，则可更好的优化代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 不带初始化的if语句</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> x = <span class="built_in">foo</span>(<span class="number">42</span>);</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">40</span>) &#123;</span><br><span class="line">        <span class="comment">// do somthing whth x</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;x &gt; 40&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// do somthing whth x</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;x &lt;= 40&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// auto x = 3;</span></span><br><span class="line"></span><br><span class="line">    cin.<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 不带初始化的if语句</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> x = <span class="built_in">foo</span>(<span class="number">42</span>); x &gt; <span class="number">40</span>) &#123;</span><br><span class="line">        <span class="comment">// do somthing whth x</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;x &gt; 40&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// do somthing whth x</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;x &lt;= 40&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> x = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    cin.<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>switch语句</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">switch</span></span> (<span class="keyword">int</span> i = <span class="built_in">rand</span>(); i) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>异常</title>
    <url>/2022/03/01/C++/%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h1 id="异常机制"><a href="#异常机制" class="headerlink" title="异常机制"></a>异常机制</h1><ul>
<li>异常处理是C++的一项语言机制，用于在程序中处理异常事件。异常事件在C++中表示为异常对象，异常事件发生时，程序使用throw关键字抛出异常表达式，抛出点称为异常出现点，由操作系统为程序设置当前异常对象，然后执行程序的当前异常处理代码块</li>
<li>在包含了异常出现点的最内层的try块，依次匹配catch语句中的异常对象，若匹配成功，则执行catch块内的异常处理语句，然后接着执行try…catch…块之后的代码。如果在当前的try…catch…块内找不到匹配该异常对象的catch语句，则由更外层的try…catch…块来处理该异常。如果当前函数内所有的try…catch…块都不能匹配该异常，则递归回退到调用栈的上一层去处理该异常。如果一直退到主函数main()都不能处理该异常，则调用系统函数terminate()终止程序</li>
<li>异常处理机制的优点：可将异常信息从被调函数带回给主函数</li>
<li>若对异常对象的内容不感兴趣，可省略catch参数，只保留类型</li>
</ul>
<h1 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h1><ul>
<li>执行throw语句时，throw表达式将作为对象被复制构造为一个新的对象，称为异常对象。异常对象放在内存的特殊位置，该位置既不是栈也不是堆，在Windows上是放在线程信息块TIB中。这个构造出来的新对象与本级的try所对应的catch语句进行类型匹配</li>
<li>异常对象是一种特殊的对象，编译器依据异常抛出表达式复制构造异常对象，这要求抛出异常表达式不能是一个不完全类型（一个类型在声明之后定义之前为一个不完全类型，不完全类型意味着该类型没有完整的数据与操作描述），而且可以进行复制构造，这就要求异常抛出表达式的复制构造函数（或移动构造函数）、析构函数不能是私有的</li>
</ul>
<h1 id="noexcept"><a href="#noexcept" class="headerlink" title="noexcept"></a>noexcept</h1><ul>
<li>noexcept修饰符是C++11新提供的异常说明符，用于声明一个函数不会抛出异常。编译器能够针对不抛出异常的函数进行优化，另一个显而易见的好处是你明确了某个函数不会抛出异常，别人调用你的函数时就知道不用针对这个函数进行异常捕获。在C++98中关于异常处理的程序中可能会看到这样的代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="title">throw</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">double</span>)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这是throw作为函数异常说明，前者表示func()这个函数可能会抛出int或double类型的异常，后者表示func()函数不会抛出异常。事实上前者很少被使用，在C++11这种做法已经被摒弃，而后者则被C++11的noexcept异常声明所代替</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="comment">// 等价于void func() throw() &#123; ... &#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在C++11中，编译器并不会在编译期检查函数的noexcept声明，因此被声明为noexcept的函数若携带异常抛出语句还是可以通过编译的。在函数运行时若抛出了异常，编译器可以选择直接调用terminate()函数来终结程序的运行，因此noexcept的一个作用是阻止异常的传播，提高安全性</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// noexcept声明符的语法: noexcept或者noexcept(布尔表达式)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="literal">true</span>)</span> </span>&#123;&#125;    <span class="comment">// noexcept(true)等价于noexcept</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;&#125;                   <span class="comment">// 可能会抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span> </span>&#123;&#125;   <span class="comment">// noexcept(false)等价于什么也不写, 可能会抛出异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// noexcept不能用于区分重载函数</span></span><br><span class="line"><span class="comment">// noexcept函数中抛出异常, 等价于调用std::terminate()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="comment">/* 潜在抛出异常 */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="built_in">f</span>();        <span class="comment">// 合法: 即使f抛出</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="number">42</span>;   <span class="comment">// 合法: 等效于调用 std::terminate()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.cnblogs.com/QG-whz/p/5136883.html">C++异常机制概述</a></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>noexcept</tag>
      </tags>
  </entry>
  <entry>
    <title>引用</title>
    <url>/2022/02/06/C++/%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<h1 id="引用的使用"><a href="#引用的使用" class="headerlink" title="引用的使用"></a>引用的使用</h1><ul>
<li>引用（reference），为对象起了另外一个名字</li>
<li>引用并非对象，相反的，它只是为一个已存在的对象所起的另外一个名字</li>
<li>引用必须初始化，且不能使引用重新绑定到另外一个对象</li>
<li>引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起</li>
<li>引用本身不是对象，不能定义引用的引用</li>
<li>引用和指针的区别：指针指向内存中的某个对象，而引用绑定到内存中的某个对象，它们都实现了对其他对象的间接访问，两者的区别主要有两方面。第一，指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以指向几个不同的对象，引用不是一个对象，无法令引用重新绑定到另外一个对象；第二，指针无须在定义是赋初值，和其他内置类型一样，在块作用域内定义的指针如果没有初始化，也将拥有一个不确定的值，引用必须在定义时赋初值</li>
</ul>
<h1 id="引用的本质"><a href="#引用的本质" class="headerlink" title="引用的本质"></a>引用的本质</h1><ul>
<li>引用的本质就是指针，只是编译器削弱了它的功能，所以引用就是弱化了的指针，一个引用占用一个指针的大小</li>
<li>通过反汇编观察指令（msvc）如下</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="number">10</span>:     <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="number">008B</span>1010 C7 <span class="number">45</span> F8 <span class="number">0</span>A <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> mov         dword ptr [a],<span class="number">0</span>Ah  </span><br><span class="line">    <span class="number">11</span>:     <span class="keyword">int</span>* p = &amp;a;</span><br><span class="line"><span class="number">008B</span>1017 <span class="number">8</span>D <span class="number">45</span> F8             lea         eax,[a]  </span><br><span class="line"><span class="number">008B</span>101A <span class="number">89</span> <span class="number">45</span> F4             mov         dword ptr [p],eax  </span><br><span class="line">    <span class="number">12</span>:     <span class="keyword">int</span>&amp; ref = a;</span><br><span class="line"><span class="number">008B</span>101D <span class="number">8</span>D <span class="number">4</span>D F8             lea         ecx,[a]  </span><br><span class="line"><span class="number">008B</span>1020 <span class="number">89</span> <span class="number">4</span>D F0             mov         dword ptr [ref],ecx  </span><br></pre></td></tr></table></figure>

<h1 id="常引用可以指向不同类型的数据"><a href="#常引用可以指向不同类型的数据" class="headerlink" title="常引用可以指向不同类型的数据"></a>常引用可以指向不同类型的数据</h1><ul>
<li>常引用可以指向不同类型的数据，且此时会产生临时变量，即引用指向的并不是初始化的那个变量</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">long</span>&amp; ref = a;</span><br><span class="line">    a = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;      <span class="comment">// 20</span></span><br><span class="line">    cout &lt;&lt; ref &lt;&lt; endl;    <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">     <span class="number">7</span>:     <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">C7 <span class="number">45</span> F4 <span class="number">0</span>A <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> mov         dword ptr [ebp<span class="number">-0</span>Ch],<span class="number">0</span>Ah  </span><br><span class="line">     <span class="number">8</span>:     <span class="keyword">const</span> <span class="keyword">long</span>&amp; ref = a;</span><br><span class="line">            <span class="comment">// [ebp-24h] 为一个临时变量的地址</span></span><br><span class="line">            <span class="comment">// [ebp-18h] 为引用变量ref的地址</span></span><br><span class="line"><span class="number">8B</span> <span class="number">45</span> F4             mov         eax,dword ptr [ebp<span class="number">-0</span>Ch]  </span><br><span class="line"><span class="number">89</span> <span class="number">45</span> DC             mov         dword ptr [ebp<span class="number">-24</span>h],eax  </span><br><span class="line"><span class="number">8</span>D <span class="number">4</span>D DC             lea         ecx,[ebp<span class="number">-24</span>h]  </span><br><span class="line"><span class="number">89</span> <span class="number">4</span>D E8             mov         dword ptr [ebp<span class="number">-18</span>h],ecx  </span><br><span class="line">     <span class="number">9</span>:     a = <span class="number">20</span>;</span><br><span class="line">C7 <span class="number">45</span> F4 <span class="number">14</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> mov         dword ptr [ebp<span class="number">-0</span>Ch],<span class="number">14</span>h  </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>引用</tag>
      </tags>
  </entry>
  <entry>
    <title>拷贝、赋值和销毁</title>
    <url>/2022/03/22/C++/%E6%8B%B7%E8%B4%9D%E3%80%81%E8%B5%8B%E5%80%BC%E5%92%8C%E9%94%80%E6%AF%81/</url>
    <content><![CDATA[<h1 id="拷贝控制操作"><a href="#拷贝控制操作" class="headerlink" title="拷贝控制操作"></a>拷贝控制操作</h1><ul>
<li>拷贝控制操作：拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符、析构函数</li>
<li>拷贝和移动构造函数：定义了当用同类型的另一个对象初始化本对象时做什么</li>
<li>拷贝和移动赋值运算符：定义了将一个对象赋予同类型的另一个对象时做什么</li>
<li>析构函数：定义了当此类型对象销毁时做什么</li>
<li>编译器会自动定义缺失的操作</li>
<li>拷贝过程：对类类型的成员，会使用其拷贝构造函数来拷贝，内置类型的成员则直接拷贝，虽然不能直接拷贝数组，但合成的拷贝构造函数会逐元素地拷贝一个数组类型的成员</li>
<li>拷贝初始化通常使用拷贝构造函数来完成，但是若一个类有一个移动构造函数，则拷贝构造函数有时会调用移动构造函数而不是拷贝构造函数来完成</li>
<li>拷贝构造函数的参数必须是引用类型，否则会进入死循环</li>
</ul>
<h1 id="编译器是否自动生成拷贝构造函数"><a href="#编译器是否自动生成拷贝构造函数" class="headerlink" title="编译器是否自动生成拷贝构造函数"></a>编译器是否自动生成拷贝构造函数</h1><ul>
<li>若未定义拷贝构造函数，则编译器在进行类对象拷贝构造的时候直接按成员变量赋值，并没有自动生成拷贝构造函数并调用</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a_ = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> b_ = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a1;</span><br><span class="line">    <span class="function">A <span class="title">a2</span><span class="params">(a1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="number">13</span>:     A a1;</span><br><span class="line"> lea         ecx,[ebp<span class="number">-10</span>h]  </span><br><span class="line"> call        <span class="number">003</span>C14A1  </span><br><span class="line">    <span class="number">14</span>:     <span class="function">A <span class="title">a2</span><span class="params">(a1)</span></span>;</span><br><span class="line"> mov         eax,dword ptr [ebp<span class="number">-10</span>h]  </span><br><span class="line"> mov         dword ptr [ebp<span class="number">-20</span>h],eax  <span class="comment">// 拷贝4个字节</span></span><br><span class="line"> mov         ecx,dword ptr [ebp<span class="number">-0</span>Ch]  </span><br><span class="line"> mov         dword ptr [ebp<span class="number">-1</span>Ch],ecx  <span class="comment">// 拷贝4个字节</span></span><br><span class="line"><span class="comment">// 等价于 a2.a_ = a1.a_; a2.b_ = a2.b_;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>构造函数</tag>
      </tags>
  </entry>
  <entry>
    <title>构造函数是否定于与其成员变量的默认初始化值</title>
    <url>/2022/03/25/C++/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%98%AF%E5%90%A6%E5%AE%9A%E4%BA%8E%E4%B8%8E%E5%85%B6%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E9%BB%98%E8%AE%A4%E5%88%9D%E5%A7%8B%E5%8C%96%E5%80%BC/</url>
    <content><![CDATA[<h1 id="未定义构造函数"><a href="#未定义构造函数" class="headerlink" title="未定义构造函数"></a>未定义构造函数</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 未定义构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> _member;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局区: 初始化为0</span></span><br><span class="line">A g_a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 栈: 使用变量时编译报错</span></span><br><span class="line">    A a;</span><br><span class="line">    <span class="comment">// 堆: 未初始化</span></span><br><span class="line">    A* p1 = <span class="keyword">new</span> A;</span><br><span class="line">    <span class="comment">// 堆: 初始化为0</span></span><br><span class="line">    A* p2 = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; g_a._member &lt;&lt; endl;    <span class="comment">// 0</span></span><br><span class="line">    <span class="comment">// 直接编译报错: error C4700: uninitialized local variable &#x27;a&#x27; used</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; a._member &lt;&lt; endl;</span></span><br><span class="line">    cout &lt;&lt; p1-&gt;_member &lt;&lt; endl;    <span class="comment">// -842150451</span></span><br><span class="line">    cout &lt;&lt; p2-&gt;_member &lt;&lt; endl;    <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="定义空的构造函数"><a href="#定义空的构造函数" class="headerlink" title="定义空的构造函数"></a>定义空的构造函数</h1><ul>
<li>如果自定义了构造函数，除了全局区，其他内存空间的成员变量默认都不会被初始化，需要开发人员手动初始化</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义空的构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> _member;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局区: 初始化为0</span></span><br><span class="line">A g_a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 编译器均认为要去调用用户的构造函数去初始化</span></span><br><span class="line">    <span class="comment">// 栈: 未初始化</span></span><br><span class="line">    A a;</span><br><span class="line">    <span class="comment">// 堆: 未初始化</span></span><br><span class="line">    A* p1 = <span class="keyword">new</span> A;</span><br><span class="line">    <span class="comment">// 堆: 未初始化</span></span><br><span class="line">    A* p2 = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; g_a._member &lt;&lt; endl;    <span class="comment">// 0</span></span><br><span class="line">    cout &lt;&lt; a._member &lt;&lt; endl;      <span class="comment">// -858993460</span></span><br><span class="line">    cout &lt;&lt; p1-&gt;_member &lt;&lt; endl;    <span class="comment">// -842150451</span></span><br><span class="line">    cout &lt;&lt; p2-&gt;_member &lt;&lt; endl;    <span class="comment">// -842150451</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>构造函数</tag>
      </tags>
  </entry>
  <entry>
    <title>用于数组的结构化绑定声明</title>
    <url>/2022/03/31/C++/%E7%94%A8%E4%BA%8E%E6%95%B0%E7%BB%84%E7%9A%84%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A%E5%A3%B0%E6%98%8E/</url>
    <content><![CDATA[<h1 id="用于数组的结构化绑定声明"><a href="#用于数组的结构化绑定声明" class="headerlink" title="用于数组的结构化绑定声明"></a>用于数组的结构化绑定声明</h1><ul>
<li>C++17：结构化绑定声明是一个声明语句，意味着声明了一些标识符并对标识符做了初始化，将制定的一些名字绑定到初始化器的子对象或者元素上</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. cv-auto &amp;/&amp;&amp;(可选) [标识符列表] = 表达式;</span></span><br><span class="line"><span class="comment">// 2. cv-auto &amp;/&amp;&amp;(可选) [标识符列表] &#123; 表达式 &#125;;</span></span><br><span class="line"><span class="comment">// 3. cv-auto &amp;/&amp;&amp;(可选) [标识符列表] ( 表达式 );</span></span><br><span class="line"><span class="comment">// cv-auto: 可能由const/volatile修饰的auto关键字</span></span><br><span class="line"><span class="comment">// &amp;/&amp;&amp;: 左值引用或者右值引用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// C++原生数组</span></span><br><span class="line">    <span class="keyword">int</span> priArr[] = &#123;<span class="number">42</span>, <span class="number">21</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="comment">// C++17 模板自动推导</span></span><br><span class="line">    <span class="comment">// 自动推导为 std::array&lt;char, 3&gt;</span></span><br><span class="line">    std::array stdArr = &#123;<span class="string">&#x27;a,&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ai/bi/ci 的基本类型都是int, 只是cv标识或者引用标识不同</span></span><br><span class="line">    <span class="keyword">auto</span> [a1, a2, a3] = priArr;         <span class="comment">// a1 是 priArr[0] 的拷贝, a2, a3类推</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> [b1, b2, b3](priArr);    <span class="comment">// b1 是 priArr[0] 的只读拷贝, b2, b3类推</span></span><br><span class="line">    <span class="keyword">auto</span> &amp;[c1, c2, c3]&#123;priArr&#125;;         <span class="comment">// c1 是 priArr[0] 的引用, c1, c2类推</span></span><br><span class="line"></span><br><span class="line">    c3 = <span class="number">14</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>类内就地初始化</title>
    <url>/2022/03/08/C++/%E7%B1%BB%E5%86%85%E5%B0%B1%E5%9C%B0%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<h1 id="类内就地初始化"><a href="#类内就地初始化" class="headerlink" title="类内就地初始化"></a>类内就地初始化</h1><ul>
<li>C++03：只有静态常量整形成员才能在类中就地初始化</li>
<li>C++11：非静态成员可以在它声明的时候初始化，类内初始值的限制：或者放在花括号里，或者放在等号右边，不能使用圆括号</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">7</span>;         <span class="comment">// Ok</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> b = <span class="number">7</span>;                <span class="comment">// Ok</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> c = <span class="number">7</span>;               <span class="comment">// Error: 非const</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> string d = <span class="string">&quot;ok&quot;</span>;   <span class="comment">// Error: 非整形</span></span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">7</span>;                      <span class="comment">// Ok</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">n</span><span class="params">(<span class="number">7</span>)</span></span>;                       <span class="comment">// Error: 就地初始化不允许小括号初始化</span></span><br><span class="line">    string s&#123; <span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span> &#125;;        <span class="comment">// Ok</span></span><br><span class="line">    string t&#123; <span class="string">&quot;Hello&quot;</span> &#125;;            <span class="comment">// Ok</span></span><br><span class="line">    <span class="keyword">int</span> a[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;            <span class="comment">// Error: 就地初始化中数组类型成员不能自动推断大小</span></span><br><span class="line">    <span class="keyword">int</span> b[<span class="number">3</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;           <span class="comment">// Ok</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="成员初始化顺序"><a href="#成员初始化顺序" class="headerlink" title="成员初始化顺序"></a>成员初始化顺序</h1><ul>
<li>执行次序：就地初始化 -&gt; Ctor初始化列表 -&gt; 在Ctor函数体中为成员赋值</li>
<li>优先级：在Ctor函数体中为成员赋值 -&gt; Ctor初始化列表 -&gt; 就地初始化</li>
<li>若一个成员同时有就地初始化和构造函数列表初始化，则就地初始化语句被忽略不执行</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n = ++x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">S</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">S</span>(<span class="keyword">int</span> arg) :n&#123; arg &#125; &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;  <span class="comment">// 0</span></span><br><span class="line">    S s1;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;  <span class="comment">// 1</span></span><br><span class="line">    S s2&#123; <span class="number">1</span> &#125;;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://wizardforcel.gitbooks.io/cpp-11-faq/content/42.html">类成员的内部初始化</a></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>初始化</tag>
      </tags>
  </entry>
  <entry>
    <title>区别调用构造函数和函数声明</title>
    <url>/2022/03/25/C++/%E5%8C%BA%E5%88%AB%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E/</url>
    <content><![CDATA[<h1 id="区别调用构造函数和函数声明"><a href="#区别调用构造函数和函数声明" class="headerlink" title="区别调用构造函数和函数声明"></a>区别调用构造函数和函数声明</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> _member = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">A</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Call A()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> member) : _member(member)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Call A(int)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A g_a1;                 <span class="comment">// Call A()</span></span><br><span class="line"><span class="function">A <span class="title">g_a2</span><span class="params">()</span></span>;               <span class="comment">// 函数声明</span></span><br><span class="line"><span class="function">A <span class="title">g_a3</span><span class="params">(<span class="number">10</span>)</span></span>;             <span class="comment">// Call A(int)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A g_a1;             <span class="comment">// Call A()</span></span><br><span class="line">    <span class="function">A <span class="title">g_a2</span><span class="params">()</span></span>;           <span class="comment">// 函数声明</span></span><br><span class="line">    <span class="function">A <span class="title">g_a3</span><span class="params">(<span class="number">10</span>)</span></span>;         <span class="comment">// Call A(int)</span></span><br><span class="line"></span><br><span class="line">    A* p1 = <span class="keyword">new</span> A;      <span class="comment">// Call A()</span></span><br><span class="line">    A* p2 = <span class="keyword">new</span> <span class="built_in">A</span>();    <span class="comment">// Call A()</span></span><br><span class="line">    A* p3 = <span class="keyword">new</span> <span class="built_in">A</span>(<span class="number">10</span>);  <span class="comment">// Call A(int)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>菱形继承</title>
    <url>/2022/03/25/C++/%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h1 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> :</span> A &#123;</span><br><span class="line">    <span class="keyword">int</span> b_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span> :</span> A &#123;</span><br><span class="line">    <span class="keyword">int</span> c_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span> :</span> B, C &#123;</span><br><span class="line">    <span class="keyword">int</span> d_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时 sizeof(D) = 20</span></span><br></pre></td></tr></table></figure>

<ul>
<li>带来的问题：最底下子类从基类继承的成员变量冗余、重复；最底下子类无法直接访问基类的成员，有二义性，除非加上其中一个父类的访问作用域</li>
<li>解决办法：使用虚继承，让B、C两个类共用A中的成员，且B、C都必须虚继承A</li>
<li>注意：使用虚继承，也会引入虚表，在B、C类的对象中，会首先存放一个虚表指针，接下来存放B、C类的对应成员变量，最后存放A类的成员变量，且虚表指针指向的虚表，第一个值存放虚表指针与本类起始的偏移量（一般为0），第二个值存放虚基类第一个成员变量与本类起始的偏移量，以此类推</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> :</span> <span class="keyword">virtual</span> A &#123;</span><br><span class="line">    <span class="keyword">int</span> b_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span> :</span> <span class="keyword">virtual</span> A &#123;</span><br><span class="line">    <span class="keyword">int</span> c_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span> :</span> B, C &#123;</span><br><span class="line">    <span class="keyword">int</span> d_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时 sizeof(D) = 24</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>继承基类的构造函数</title>
    <url>/2022/03/09/C++/%E7%BB%A7%E6%89%BF%E5%9F%BA%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="继承基类的构造函数"><a href="#继承基类的构造函数" class="headerlink" title="继承基类的构造函数"></a>继承基类的构造函数</h1><ul>
<li>C++11：派生类不能继承的特殊函数：析构函数和友元函数</li>
<li>继承基类的构造函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// using A::A; 继承所有基类的Ctor</span></span><br><span class="line"><span class="comment">// 不能仅继承指定的某个基类Ctor</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> i) &#123; &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">double</span> d, <span class="keyword">int</span> i) &#123; &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> :</span> A &#123;</span><br><span class="line">    <span class="keyword">using</span> A::A;     <span class="comment">// C++11, 继承基类所有Ctor</span></span><br><span class="line">    <span class="comment">// 编译器自动生成 B(int i) : A(i) &#123; &#125;</span></span><br><span class="line">    <span class="keyword">int</span> d&#123; <span class="number">0</span> &#125;;     <span class="comment">// 就地初始化</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    B b&#123; <span class="number">1</span> &#125;;       <span class="comment">// 调用 A(int i)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>构造函数不能声明为const原因：直到构造函数完成初始化过程，对象才能真正取得其常量属性，因此构造函数在构造过程中可以向其写值</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>构造函数</tag>
      </tags>
  </entry>
  <entry>
    <title>运算符重载</title>
    <url>/2022/03/25/C++/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h1><ul>
<li>第一个版本</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : <span class="built_in">x_</span>(x), <span class="built_in">y_</span>(y) &#123;&#125;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="keyword">const</span> Point&amp; point) &#123;</span><br><span class="line">        x_ = point.x_;</span><br><span class="line">        y_ = point.y_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Point <span class="keyword">operator</span>+(<span class="keyword">const</span> Point&amp; point) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Point</span>(x_ + point.x_, y_ + point.y_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x_ = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> y_ = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Point p1&#123; <span class="number">10</span>, <span class="number">20</span> &#125;;</span><br><span class="line">    Point p2&#123; <span class="number">20</span>, <span class="number">30</span> &#125;;</span><br><span class="line">    Point p3&#123; <span class="number">30</span>, <span class="number">40</span> &#125;;</span><br><span class="line"></span><br><span class="line">    p3 = p1 + p2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当写成(p1 + p2) = p3;时，将p3赋值给一个p1 + p2的临时对象无意义，希望报错，可以返回const Point类型，第二个版本</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : <span class="built_in">x_</span>(x), <span class="built_in">y_</span>(y) &#123;&#125;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="keyword">const</span> Point&amp; point) &#123;</span><br><span class="line">        x_ = point.x_;</span><br><span class="line">        y_ = point.y_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> Point <span class="keyword">operator</span>+(<span class="keyword">const</span> Point&amp; point) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Point</span>(x_ + point.x_, y_ + point.y_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x_ = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> y_ = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>当写成Point p4 = p1 + p2 + p3;，p1 + p2返回的是一个const对象，继续调用operator+，只能调用const成员函数，继续修改为const成员函数，第三个版本</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : <span class="built_in">x_</span>(x), <span class="built_in">y_</span>(y) &#123;&#125;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="keyword">const</span> Point&amp; point) &#123;</span><br><span class="line">        x_ = point.x_;</span><br><span class="line">        y_ = point.y_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> Point <span class="keyword">operator</span>+(<span class="keyword">const</span> Point&amp; point) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Point</span>(x_ + point.x_, y_ + point.y_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x_ = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> y_ = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>静态成员</title>
    <url>/2022/03/09/C++/%E9%9D%99%E6%80%81%E6%88%90%E5%91%98/</url>
    <content><![CDATA[<h1 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h1><ul>
<li>静态成员的声明：在类定义中，关键字static声明不绑定到类实例的成员</li>
<li>静态成员的定义：声明为constexpr类型的静态数据成员必须在类中声明并初始化，自C++17起，可不在类外定义；声明为inline（C++17起）或者const int类型的静态数据成员可以在类中声明并初始化；其他须在类外定义并初始化，且不带static关键字</li>
<li>静态成员存储在数据段（全局区，类似于全局变量），整个程序运行过程中只有一份内存，注意，不能说存在类中，类只是代码</li>
<li>对比全局变量，它可以设定访问权限，达到局部共享的目的</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sizeof(A) = 4</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a_ = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A::b_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A x;</span><br><span class="line">    x.a_ = <span class="number">1</span>;</span><br><span class="line">    x.b_ = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="number">15</span>:     x.a_ = <span class="number">1</span>;</span><br><span class="line"> mov         dword ptr [ebp<span class="number">-0</span>Ch],<span class="number">1</span>  </span><br><span class="line">    <span class="number">16</span>:     x.b_ = <span class="number">2</span>;</span><br><span class="line"> mov         dword ptr ds:[<span class="number">00F</span>7C2FCh],<span class="number">2</span>  <span class="comment">// ds: 数据段</span></span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://en.cppreference.com/w/cpp/language/static">static members</a></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>初始化</tag>
      </tags>
  </entry>
  <entry>
    <title>默认构造函数是否自动生成</title>
    <url>/2022/03/24/C++/%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%98%AF%E5%90%A6%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[<h1 id="默认构造函数是否自动生成"><a href="#默认构造函数是否自动生成" class="headerlink" title="默认构造函数是否自动生成"></a>默认构造函数是否自动生成</h1><ul>
<li>只有在某些特定情况下，编译器才会为类生成空的无参构造函数，并不是说默认情况下，编译器会为每一个类生成空的无参构造函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> _member;</span><br><span class="line">    <span class="built_in">A</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    a._member = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="number">13</span>:     A a;</span><br><span class="line"> lea         ecx,[a]  </span><br><span class="line"> <span class="function">call        <span class="title">A::A</span> <span class="params">(<span class="number">05B</span>137Fh)</span>  <span class="comment">// 调用构造函数</span></span></span><br><span class="line"><span class="function">    14:     a._member =</span> <span class="number">10</span>;</span><br><span class="line"> mov         dword ptr [a],<span class="number">0</span>Ah  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 若去掉A的构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> _member;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    a._member = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="number">10</span>:     A a;</span><br><span class="line">    <span class="number">11</span>:     a._member = <span class="number">10</span>;</span><br><span class="line"> mov         dword ptr [a],<span class="number">0</span>Ah  <span class="comment">// 未调用构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 若增加成员内部初始化, 也会调用构造函数, 用于初始化成员变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> _member = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    a._member = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="编译器自动生成的构造函数"><a href="#编译器自动生成的构造函数" class="headerlink" title="编译器自动生成的构造函数"></a>编译器自动生成的构造函数</h1><ul>
<li>只有在某些特定情况下，编译器才会为类生成空的无参构造函数</li>
<li>成员变量在声明的同时进行了初始化，需要初始化成员变量</li>
<li>有定义虚函数，需要初始化虚函数表</li>
<li>虚继承了其他类，需要初始化虚函数表</li>
<li>包含了对象类型成员，且这个成员有构造函数（编译器生成或者自定义）</li>
<li>父类有构造函数（编译器生成或者自定义）</li>
<li>总结：对象创建后，需要做一些额外的操作时，比如内存操作、函数调用等，编译器一般都会为其自动生成无参的构造函数</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>默认构造函数</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的类型转换</title>
    <url>/2022/03/07/C++/C++%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h1><ul>
<li>隐式类型转换是自动执行的，无需显式的操作符</li>
<li>从小整数类型（char、short）转换到int，或者从float转换到double，这种提升型的转换通常不会造成数值差异</li>
<li>需要注意负数转化为无符号类型通常会用二进制补码表示、浮点数转化为整数会采取截断操作等</li>
</ul>
<h1 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h1><h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h2><ul>
<li>static_cast强制转换只会在编译时检查，但没有运行时类型检查来保证转换的安全性。同时，static_cast也不能去掉expression的const、volitale、或者__unaligned属性</li>
<li>用于类层次结构中基类和子类之间指针或引用的转换。进行上行转换（把子类的指针或引用转换成基类表示）是安全的；进行下行转换（把基类指针或引用转换成子类指针或引用）时，由于没有动态类型检查，所以是不安全的</li>
<li>用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证</li>
<li>把void指针转换成目标类型的指针（不安全）</li>
<li>把任何类型的表达式转换成void类型</li>
<li>将enum class值转化为整数或者浮点数</li>
<li>转换为右值引用</li>
<li>对比dynamic_cast，缺乏运行时安全检测，不能交叉转换（不是同一继承体系的，无法转换），常用于基本数据类型的转换</li>
</ul>
<h2 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h2><ul>
<li>一般用于多态类型的转换，有运行时安全检测，若写代码过程中能够自己确定某个指针一定指向具体哪个类型对象，则可以不调用dynamic_cast做转换，会增加开销</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">B</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A* p1 = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">    A* p2 = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1: &quot;</span> &lt;&lt; p1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2: &quot;</span> &lt;&lt; p2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    B* p3 = <span class="keyword">dynamic_cast</span>&lt;B*&gt;(p1);   <span class="comment">//  call        ___RTDynamicCast (091155Ah) </span></span><br><span class="line">    B* p4 = <span class="keyword">dynamic_cast</span>&lt;B*&gt;(p2);   <span class="comment">//  call        ___RTDynamicCast (091155Ah) </span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p3: &quot;</span> &lt;&lt; p3 &lt;&lt; endl;   <span class="comment">// null, 若直接采用C语言风格强转, 则直接 == p1, 无安全校验</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p4: &quot;</span> &lt;&lt; p4 &lt;&lt; endl;   <span class="comment">// == p2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h2><ul>
<li>属于比较底层的强制转换，没有任何类型检查和格式转换，仅仅是简单的二进制数据拷贝，可以交叉转换，可以将指针和整数互相转换</li>
<li>其转换结果与编译平台息息相关，不具有可移植性，因此在一般的代码中不常见到它。reinterpret_cast只用于底层代码，一般我们都用不到它，如果你的代码中使用到这种转型，务必明白自己在干什么</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;                                 <span class="comment">// 0a 00 00 00</span></span><br><span class="line">    <span class="keyword">double</span> b = a;                               <span class="comment">// 00 00 00 00 00 00 24 40</span></span><br><span class="line">    <span class="keyword">double</span> c = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">double</span>&amp;&gt;(a);    <span class="comment">// 0a 00 00 00 cc cc cc cc</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h2><ul>
<li>一般用于去除const属性，降const转换成非const</li>
<li>用于强制去掉不能被修改的常数特性，但需要特别注意的是const_cast不是用于去除变量的常量性，而是去除指向常数对象的指针或引用的常量性，其去除常量性的对象必须为指针或引用</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> A* p1 = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">    A* p2 = <span class="keyword">const_cast</span>&lt;A*&gt;(p1);</span><br><span class="line">    A* p3 = (A*)p1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述两种写法本质一样, 就是指针赋值而已</span></span><br><span class="line"><span class="comment">// 使用const_cast只是C++的语法而已, 方便理解是去除const属性</span></span><br><span class="line"></span><br><span class="line">    <span class="number">11</span>:     A* p2 = <span class="keyword">const_cast</span>&lt;A*&gt;(p1);</span><br><span class="line"> mov         eax,dword ptr [p1]  </span><br><span class="line"> mov         dword ptr [p2],eax  </span><br><span class="line">    <span class="number">12</span>:     A* p3 = (A*)p1;</span><br><span class="line"> mov         eax,dword ptr [p1]  </span><br><span class="line"> mov         dword ptr [p3],eax  </span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://blog.csdn.net/shuzfan/article/details/77338366">C++ 类型转换</a></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++中的变量初始化</title>
    <url>/2022/02/05/C++/C++%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<h1 id="默认初始化"><a href="#默认初始化" class="headerlink" title="默认初始化"></a>默认初始化</h1><ul>
<li>定义变量时没有指定初值时进行的初始化操作。如int a; MyClass obj;等，这些变量被定义了而不是仅仅被声明，而且没有显示的赋初始值。特别的，如果采用动态分配内存的方式创建的变量，不加括号（如int *p = new int;）也是默认初始化，加了括号（如int *p = new int();）为值初始化。变量的值与变量定义的位置有关</li>
</ul>
<blockquote>
<p>对于内置变量类型（如int，double，bool等），如果定义为全局变量，则变量被默认初始化为0；如果定义为局部变量，变量将拥有未定义的值</p>
<p>对于类类型（如string或其他自定义类型），不管定义予何处，都会执行默认构造函数。如果该类没有默认构造函数，则会引发编译错误</p>
</blockquote>
<ul>
<li>对于内置类型的局部变量，其默认初始化后，值可能为0，比如在g++和msvc中，这可能跟编译器和操作系统有关，具体可以参考：<a href="https://stackoverflow.com/questions/11143354/why-are-local-variables-initialized-to-0-in-g-compiler-for-c-in-ubuntu-linux">Why are local variables initialized to 0 in g++ compiler for c++ in ubuntu linux?</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> global_value;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> local_value;</span><br><span class="line">    <span class="keyword">int</span> *new_value = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;global_value: &quot;</span> &lt;&lt; global_value &lt;&lt; endl;   <span class="comment">// 0</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;local_value: &quot;</span> &lt;&lt; local_value &lt;&lt; endl;     <span class="comment">// 在g++和msvc中可能为0</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;new_value: &quot;</span> &lt;&lt; *new_value &lt;&lt; endl;        <span class="comment">// 未定义</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="值初始化"><a href="#值初始化" class="headerlink" title="值初始化"></a>值初始化</h1><ul>
<li>定义变量时使用了初始化器（即圆括号或者大括号），但却没有提供初始值的情况，如int *p = new int(); vector&lt;string&gt; vec(10)等</li>
<li>注意，当不采用动态分配内存的方式（即不采用new运算符）时，写成int a();是错误的值初始化方式，因为这种方式声明了一个函数而不是进行值初始化。如果一定要进行值初始化，必须结合拷贝初始化使用，即写成int a = int();值初始化和默认初始化一样，对于内置类型初始化为0，对于类类型则调用其默认构造函数，如果没有默认构造函数，则不能进行初始化</li>
<li>只要使用了括号（圆括号或花括号）但没有给出具体初始值，就是值初始化。可以简单理解为括号告诉编译器你希望该对象初始化。没有使用括号，就是默认初始化。可以简单理解成，你放任不管，允许编译器使用默认行为，通常这是糟糕的行为</li>
</ul>
<h1 id="直接初始化和拷贝初始化"><a href="#直接初始化和拷贝初始化" class="headerlink" title="直接初始化和拷贝初始化"></a>直接初始化和拷贝初始化</h1><ul>
<li><p>直接初始化：定义变量时采用小括号的方式进行变量初始化，且小括号里一定要有初始值，如果没有初始值，那就是值初始化了，如int a(12); MyClass obj(param); string s(“123”);等</p>
</li>
<li><p>拷贝初始化：定义变量时采用等号的方式进行变量初始化，如int a = 12; string s = “123”等，拷贝初始化像是给变量赋值，实际上执行了初始化操作，与先定义再赋值本质不同</p>
</li>
<li><p>对于内置类型，直接初始化和拷贝初始化差别可以忽略不计；对于类类型，直接初始化调用类的构造函数（调用参数最匹配的那个），拷贝初始化调用类的拷贝构造函数</p>
</li>
<li><p>对于示例，s的初始化书本说是直接初始化，看起来似乎像是拷贝初始化，其实的确是直接初始化，因为直接初始化是用参数来直接匹配某一个构造函数，而拷贝构造函数和其他构造函数形成了重载，以至于刚好调用了拷贝构造函数</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">dots</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;.&#x27;</span>)</span></span>;   <span class="comment">// 直接初始化</span></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(dots)</span></span>;         <span class="comment">// 直接初始化</span></span><br></pre></td></tr></table></figure>

<ul>
<li>C++语言标准规定拷贝初始化应该是先调用对应的构造函数创建一个临时对象，然后拷贝构造函数再将构造的临时对象拷贝给要创建的对象，如string a = “hello”;，因为“hello”的类型是const char *，所以string类的string(const char *)构造函数会被首先调用，创建一个临时对象，然后拷贝构造函数将这个临时对象复制到a。但是标准还规定，为了提高效率，允许编译器跳过创建临时对象这一步，直接调用构造函数构造要创建的对象，从而忽略调用拷贝构造函数进行优化，这样就完全等价于直接初始化了，当然可以使用-fno-elide-constructors选项来禁用优化</li>
</ul>
<h1 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h1><ul>
<li>列表初始化是C++ 11新引进的初始化方式，它采用一对花括号进行初始化操作。能用直接初始化和拷贝初始化的地方都能用列表初始化，而且列表初始化能对容器进行方便的初始化，因此在新的C++标准中，推荐使用列表初始化的方式进行初始化，如int a{12}; string s{“123”}; vector&lt;int&gt; vec{1,2,3};等</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接列表初始化</span></span><br><span class="line"><span class="keyword">int</span> x&#123;&#125;;</span><br><span class="line"><span class="keyword">int</span> y&#123; <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> array1[]&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">char</span> s1[<span class="number">3</span>]&#123; <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;k&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">char</span> s2[]&#123;<span class="string">&quot;Hello&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝列表初始化</span></span><br><span class="line"><span class="keyword">int</span> z = &#123; <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> array2[] = &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line"><span class="keyword">char</span> s3[] = &#123; <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;k&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">char</span> s4[] = &#123; <span class="string">&quot;Hello&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">char</span> s5[] = <span class="string">&quot;Hello&quot;</span>; </span><br></pre></td></tr></table></figure>

<ul>
<li>用于内置类型的变量时，若使用列表初始化且初始值存在丢失信息的风险，则编译器将报错，即列表初始化不允许“窄化”</li>
</ul>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul>
<li>初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来代替</li>
<li>使用等号（=）初始化一个类变量执行的是拷贝初始化，编译器会把等号右侧的初始值拷贝到新创建的对象中去，不使用等号则执行的是直接初始化</li>
<li>默认初始化是定义对象时，没有使用初始化器，也即没有做任何初始化说明时的行为</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec;</span><br></pre></td></tr></table></figure>

<ul>
<li>值初始化是定义对象时，要求初始化，但没有给出初始值的行为</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>();</span><br><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>&#123;&#125;;  <span class="comment">// C++11</span></span><br></pre></td></tr></table></figure>

<ul>
<li>当用于类类型对象时，初始化的复制形式和直接形式有所不同：直接初始化直接调用与实参匹配的构造函数，复制初始化总是调用复制构造函数。复制初始化首先使用指定构造函数创建一个临时对象，然后用复制构造函数将那个临时对象复制到正在创建的对象</li>
<li>直接初始化和拷贝初始化主要是相对于我们自定义的对象的初始化而言的，对于内置类型，这两者没有区别。对于自定义对象，直接初始化和拷贝初始化区别是直接调用构造函数还是用”=”来进行初始化</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>)</span></span>;     <span class="comment">// 直接初始化，匹配某一构造函数</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">v2</span><span class="params">(<span class="number">10</span>)</span></span>;  <span class="comment">// 直接初始化，匹配某一构造函数</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v3 = v1;    <span class="comment">// 拷贝初始化，使用 = 进行初始化</span></span><br></pre></td></tr></table></figure>

<ul>
<li>列表初始化是C++新标准给出的一种初始化方式，可用于内置类型，也可以用于自定义对象，前者比如数组，后者比如vector</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> array[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>尽量使用列表初始化，除非你有个很好不用它的理由</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://blog.csdn.net/u014359097/article/details/50788911">谈谈C++中各种初始化方式</a></li>
<li><a href="https://segmentfault.com/a/1190000039844285">五花八门的C++初始化规则</a></li>
<li><a href="https://www.cnblogs.com/pluse/p/7088880.html">C++的各种初始化方式</a></li>
<li><a href="https://blog.csdn.net/ljianhui/article/details/9245661">C++的一大误区——深入解释直接初始化与复制初始化的区别</a></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>初始化</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器</title>
    <url>/2022/02/06/C++/%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<h1 id="迭代器使用"><a href="#迭代器使用" class="headerlink" title="迭代器使用"></a>迭代器使用</h1><ul>
<li>提供对对象的间接访问，所有标准容器都可以使用迭代器，但是仅有少数几种才能同时支持下标运算符</li>
<li>二分搜索例子</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vec必须是有序的</span></span><br><span class="line"><span class="comment">// beg和end表示需要搜索的范围</span></span><br><span class="line"><span class="keyword">auto</span> beg = vec.<span class="built_in">begin</span>(), end = vec.<span class="built_in">end</span>();</span><br><span class="line"><span class="keyword">auto</span> mid = beg + (end - beg) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (mid != end &amp;&amp; *mid != sought) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sought &lt; *mid)</span><br><span class="line">        end = mid;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        beg = mid + <span class="number">1</span>;</span><br><span class="line">    mid = beg + (end - beg) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><ul>
<li>C++并没有定义两个迭代器的加法运算，直接把两个迭代器加起来没有意义，但是定义了迭代器的减法运算，两个迭代器相减的结果是两个迭代器之间的距离，所以mid = (beg + end) / 2;不合法</li>
<li>向迭代器添加元素和从迭代器删除元素的代码可能会导致迭代器失效，因此必须保证每次改变容器的操作之后都正确地重新定位迭代器</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> iter = vec.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (iter != vec.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*iter == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">// erase 后一定要重新给迭代器赋值</span></span><br><span class="line">        iter = vec.<span class="built_in">erase</span>(iter);</span><br><span class="line">    &#125;</span><br><span class="line">    ++iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不要保存end返回的迭代器，必须反复调用end</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> begin = vec.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">// 在每个循环步添加/删除元素后都重新计算end</span></span><br><span class="line"><span class="keyword">while</span> (begin != vec.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    ++begin;</span><br><span class="line">    begin = vec.<span class="built_in">insert</span>(begin, <span class="number">42</span>);</span><br><span class="line">    ++begin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
</search>
